
\chapter{The \texttt{grid} package}
\HeaderA{grid-package}{The Grid Graphics Package}{grid.Rdash.package}
\keyword{package}{grid-package}
%
\begin{Description}\relax
A rewrite of the graphics layout capabilities, plus some
support for interaction.
\end{Description}
%
\begin{Details}\relax
This package contains a graphics system which supplements
S-style graphics (see the \pkg{graphics} package).

Further information is available in the following
\LinkA{vignettes}{vignettes}:

\Tabular{ll}{
\code{grid} & Introduction to \code{grid} (\url{../doc/grid.pdf})\\{}
\code{displaylist} & Display Lists in \code{grid} (\url{../doc/displaylist.pdf})\\{}
\code{frame} & Frames and packing grobs (\url{../doc/frame.pdf})\\{}
\code{grobs} & Working with \code{grid} grobs (\url{../doc/grobs.pdf})\\{}
\code{interactive} & Editing \code{grid} Graphics (\url{../doc/interactive.pdf})\\{}
\code{locndimn} & Locations versus Dimensions (\url{../doc/locndimn.pdf})\\{}
\code{moveline} & Demonstrating move-to and line-to (\url{../doc/moveline.pdf})\\{}
\code{nonfinite} & How \code{grid} responds to non-finite values (\url{../doc/nonfinite.pdf})\\{}
\code{plotexample} & Writing \code{grid} Code (\url{../doc/plotexample.pdf})\\{}
\code{rotated} & Rotated Viewports (\url{../doc/rotated.pdf})\\{}
\code{saveload} & Persistent representations (\url{../doc/saveload.pdf})\\{}
\code{sharing} & Modifying multiple grobs simultaneously (\url{../doc/sharing.pdf})\\{}
\code{viewports} & Working with \code{grid} viewports (\url{../doc/viewports.pdf})\\{}
}

For a complete list of functions with individual help pages,
use \code{library(help="grid")}.
\end{Details}
%
\begin{Author}\relax

Paul Murrell \email{paul@stat.auckland.ac.nz}

Maintainer: R Core Team \email{R-core@r-project.org}

\end{Author}
%
\begin{References}\relax
Murrell, P. (2005) \emph{R Graphics}. Chapman \& Hall/CRC Press.
\end{References}
\HeaderA{absolute.size}{ Absolute Size of a Grob }{absolute.size}
\keyword{dplot}{absolute.size}
%
\begin{Description}\relax
This function converts a unit object into absolute units.
Absolute units are unaffected, but non-absolute units are
converted into \code{"null"} units.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
absolute.size(unit)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{unit}]  An object of class \code{"unit"}. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Absolute units are things like \code{"inches"}, \code{"cm"},
and \code{"lines"}.  Non-absolute units are \code{"npc"}
and \code{"native"}.

This function is designed to be used in \code{widthDetails}
and \code{heightDetails} methods.
\end{Details}
%
\begin{Value}
An object of class \code{"unit"}.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{widthDetails}{widthDetails}}
and \code{\LinkA{heightDetails}{heightDetails}} methods.
\end{SeeAlso}
\HeaderA{arrow}{ Describe arrows to add to a line. }{arrow}
\keyword{dplot}{arrow}
%
\begin{Description}\relax
Produces a description of what arrows to add to a line.
The result can be passed to a function that draws a line,
e.g., \code{grid.lines}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
arrow(angle = 30, length = unit(0.25, "inches"),
      ends = "last", type = "open")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{angle}] The angle of the arrow head in degrees (smaller numbers
produce narrower, pointier arrows).  Essentially describes
the width of the arrow head.
\item[\code{length}] A unit specifying the length of the arrow head (from tip
to base).
\item[\code{ends}] One of \code{"last"}, \code{"first"}, or \code{"both"},
indicating which ends of the line to draw arrow heads.
\item[\code{type}] One of \code{"open"} or \code{"closed"} indicating
whether the arrow head should be a closed triangle.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
arrow()
\end{ExampleCode}
\end{Examples}
\HeaderA{calcStringMetric}{ Calculate Metric Information for Text }{calcStringMetric}
\keyword{dplot}{calcStringMetric}
%
\begin{Description}\relax
This function returns the ascent, descent, and width metric
information for a character or expression vector.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
calcStringMetric(text)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{text}]  A character or expression vector. 
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list with three numeric components named ascent, descent, and width.
All values are in inches.
\end{Value}
%
\begin{Section}{WARNING }
 The metric information from this function is based
on the font settings that are in effect when this function is called.
It will not necessarily correspond to the metric information of any
text that is drawn on the page.
\end{Section}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{stringAscent}{stringAscent}}, \code{\LinkA{stringDescent}{stringDescent}},
\code{\LinkA{grobAscent}{grobAscent}}, and \code{\LinkA{grobDescent}{grobDescent}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
grid.segments(.01, .5, .99, .5, gp=gpar(col="grey"))
metrics <- calcStringMetric(letters)
grid.rect(x=1:26/27,
          width=unit(metrics$width, "inches"),
          height=unit(metrics$ascent, "inches"),
          just="bottom",
          gp=gpar(col="red"))
grid.rect(x=1:26/27,
          width=unit(metrics$width, "inches"),
          height=unit(metrics$descent, "inches"),
          just="top",
          gp=gpar(col="red"))
grid.text(letters, x=1:26/27, just="bottom")

test <- function(x) {
    grid.text(x, just="bottom")
    metric <- calcStringMetric(x)
    if (is.character(x)) {
        grid.rect(width=unit(metric$width, "inches"),
                  height=unit(metric$ascent, "inches"),
                  just="bottom",
                  gp=gpar(col=rgb(1,0,0,.5)))
        grid.rect(width=unit(metric$width, "inches"),
                  height=unit(metric$descent, "inches"),
                  just="top",
                  gp=gpar(col=rgb(1,0,0,.5)))
    } else {
        grid.rect(width=unit(metric$width, "inches"),
                  y=unit(.5, "npc") + unit(metric[2], "inches"),
                  height=unit(metric$ascent, "inches"),
                  just="bottom",
                  gp=gpar(col=rgb(1,0,0,.5)))
        grid.rect(width=unit(metric$width, "inches"),
                  height=unit(metric$descent, "inches"),
                  just="bottom",
                  gp=gpar(col=rgb(1,0,0,.5)))        
    }
}

tests <- list("t",
              "test",
              "testy",
              "test\ntwo",
              expression(x),
              expression(y),
              expression(x + y),
              expression(a + b),
              expression(atop(x + y, 2)))

grid.newpage()
nrowcol <- n2mfrow(length(tests))
pushViewport(viewport(layout=grid.layout(nrowcol[1], nrowcol[2]),
                      gp=gpar(cex=5, lwd=.5)))
for (i in 1:length(tests)) {
    col <- (i - 1) %% nrowcol[2] + 1
    row <- (i - 1) %/% nrowcol[2] + 1
    pushViewport(viewport(layout.pos.row=row, layout.pos.col=col))
    test(tests[[i]])
    popViewport()
}

\end{ExampleCode}
\end{Examples}
\HeaderA{convertNative}{ Convert a Unit Object to Native units }{convertNative}
\keyword{dplot}{convertNative}
%
\begin{Description}\relax
\bold{This function is deprecated in grid version 0.8 and will be
made defunct in grid version 1.9}

You should use the \code{convertUnit()} function or one of its
close allies instead.

This function returns a numeric vector containing the specified
x or y locations or dimensions, converted to "user" or "data"
units, relative to the current viewport.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
convertNative(unit, dimension="x", type="location")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{unit}]  A unit object. 
\item[\code{dimension}]  Either "x" or "y". 
\item[\code{type}]  Either "location" or "dimension". 
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A numeric vector.
\end{Value}
%
\begin{Section}{WARNING }
 If you draw objects based on output from these conversion
functions, then resize your device, the objects will be drawn 
incorrectly -- the base R display list will not recalculate these
conversions.  This means that you can only rely on the results of 
these calculations if the size of your device is fixed.
\end{Section}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{grid.convert}{grid.convert}}, \code{\LinkA{unit}{unit}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
pushViewport(viewport(width=unit(.5, "npc"),
                       height=unit(.5, "npc")))
grid.rect()
w <- convertNative(unit(1, "inches"))
h <- convertNative(unit(1, "inches"), "y")
# This rectangle starts off life as 1in square, but if you
# resize the device it will no longer be 1in square
grid.rect(width=unit(w, "native"), height=unit(h, "native"),
          gp=gpar(col="red"))
popViewport(1)

# How to use grid.convert(), etc instead
convertNative(unit(1, "inches")) ==
  convertX(unit(1, "inches"), "native", valueOnly=TRUE)
convertNative(unit(1, "inches"), "y", "dimension") ==
  convertHeight(unit(1, "inches"), "native", valueOnly=TRUE)
\end{ExampleCode}
\end{Examples}
\HeaderA{dataViewport}{ Create a Viewport with Scales based on Data }{dataViewport}
\keyword{dplot}{dataViewport}
%
\begin{Description}\relax
This is a convenience function for producing a viewport with
x- and/or y-scales based on numeric values passed to the function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dataViewport(xData = NULL, yData = NULL, xscale = NULL,
             yscale = NULL, extension = 0.05, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{xData}]  A numeric vector of data. 
\item[\code{yData}]  A numeric vector of data. 
\item[\code{xscale}]  A numeric vector (length 2). 
\item[\code{yscale}]  A numeric vector (length 2). 
\item[\code{extension}]  A numeric.  If length greater than 1, then
first value is used to extend the xscale and second value
is used to extend the yscale.

\item[\code{...}]  All other arguments will be passed to a call to
the \code{viewport()} function. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
If \code{xscale} is not specified then the values in \code{x} are
used to generate an x-scale based on the range of \code{x}, extended
by the proportion specified in \code{extension}.  Similarly for the
y-scale.
\end{Details}
%
\begin{Value}
A grid viewport object.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{viewport}{viewport}} and
\code{\LinkA{plotViewport}{plotViewport}}.
\end{SeeAlso}
\HeaderA{drawDetails}{ Customising grid Drawing }{drawDetails}
\aliasA{draw.details}{drawDetails}{draw.details}
\aliasA{postDrawDetails}{drawDetails}{postDrawDetails}
\aliasA{preDrawDetails}{drawDetails}{preDrawDetails}
\keyword{dplot}{drawDetails}
%
\begin{Description}\relax
These generic hook functions are called whenever a grid grob is drawn.
They provide an opportunity for customising the drawing of a
new class derived from grob (or gTree).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
drawDetails(x, recording)
draw.details(x, recording)
preDrawDetails(x)
postDrawDetails(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}]  A grid grob. 
\item[\code{recording}]  A logical value indicating whether a grob
is being added to the display list or redrawn from the display list. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
These functions are called by the \code{grid.draw} methods for grobs
and gTrees.

\code{preDrawDetails} is called first during the drawing of a grob.
This is where any additional viewports should be pushed (see,
for example, \code{grid:::preDrawDetails.frame}).  Note that
the default behaviour for grobs is to push any viewports in the
\code{vp} slot, and for gTrees is to also push and up any viewports in the
\code{childrenvp} slot so there is typically nothing to do here.

\code{drawDetails} is called next and is where any additional
calculations and graphical output should occur (see, for example,
\code{grid:::drawDetails.xaxis}.  Note that the default behaviour
for gTrees is to draw all grobs in the \code{children} slot
so there is typically nothing to do here.

\code{postDrawDetails} is called last and should reverse anything
done in \code{preDrawDetails} (i.e., pop or up any viewports that were
pushed;  again, see,
for example, \code{grid:::postDrawDetails.frame}).  Note that the
default behaviour for grobs is to pop any viewports that were pushed
so there is typically nothing to do here.

Note that \code{preDrawDetails} and \code{postDrawDetails} are
also called in the calculation of \code{"grobwidth"} and
\code{"grobheight"} units.
\end{Details}
%
\begin{Value}
None of these functions are expected to return a value.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{grid.draw}{grid.draw}} 
\end{SeeAlso}
\HeaderA{editDetails}{ Customising grid Editing }{editDetails}
\keyword{dplot}{editDetails}
%
\begin{Description}\relax
This generic hook function is called whenever a grid grob is edited
via \code{grid.edit} or \code{editGrob}.
This provides an opportunity for customising the editing of a
new class derived from grob (or gTree).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
editDetails(x, specs)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}]  A grid grob. 
\item[\code{specs}]  A list of named elements.  The names indicate the
grob slots to modify and the values are the new values for the slots. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function is called by \code{grid.edit} and \code{editGrob}.
A method should be written for classes derived from grob or gTree
if a change in a slot has an effect on other slots in the grob or
children of a gTree (e.g., see \code{grid:::editDetails.xaxis}).

Note that the slot already has the new value.
\end{Details}
%
\begin{Value}
The function MUST return the modified grob.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{grid.edit}{grid.edit}} 
\end{SeeAlso}
\HeaderA{gEdit}{ Create and Apply Edit Objects }{gEdit}
\aliasA{applyEdit}{gEdit}{applyEdit}
\aliasA{applyEdits}{gEdit}{applyEdits}
\aliasA{gEditList}{gEdit}{gEditList}
\keyword{dplot}{gEdit}
%
\begin{Description}\relax
The functions \code{gEdit} and \code{gEditList} create
objects representing an edit operation (essentially a list
of arguments to \code{editGrob}).

The functions \code{applyEdit} and \code{applyEdits} apply
one or more edit operations to a graphical object.

These functions are most useful for developers creating new
graphical functions and objects.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
gEdit(...)
gEditList(...)
applyEdit(x, edit)
applyEdits(x, edits)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}]  one or more arguments to the \code{editGrob} function
(for \code{gEdit}) or one or more \code{"gEdit"} objects
(for \code{gEditList}).
\item[\code{x}]  a grob (grid graphical object).
\item[\code{edit}]  a \code{"gEdit"} object.
\item[\code{edits}]  either a \code{"gEdit"} object or a \code{"gEditList"}
object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{gEdit} returns an object of class \code{"gEdit"}.

\code{gEditList} returns an object of class \code{"gEditList"}.

\code{applyEdit} and \code{applyEditList} return the modified grob.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}}
\code{\LinkA{editGrob}{editGrob}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.rect(gp=gpar(col="red"))
# same thing, but more verbose
grid.draw(applyEdit(rectGrob(), gEdit(gp=gpar(col="red"))))
\end{ExampleCode}
\end{Examples}
\HeaderA{getNames}{ List the names of grobs on the display list }{getNames}
\keyword{dplot}{getNames}
%
\begin{Description}\relax
Returns a character vector containing the names of all
top-level grobs on the display list.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getNames()
\end{verbatim}
\end{Usage}
%
\begin{Value}
A character vector.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
grid.grill()
getNames()
\end{ExampleCode}
\end{Examples}
\HeaderA{gpar}{Handling Grid Graphical Parameters}{gpar}
\aliasA{get.gpar}{gpar}{get.gpar}
\keyword{dplot}{gpar}
%
\begin{Description}\relax
\code{gpar()} should be used to create a set of graphical
parameter settings.  It returns an object of class \code{"gpar"}.  This is
basically a list of name-value pairs.

\code{get.gpar()} can be used to query the current
graphical parameter settings.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
gpar(...)
get.gpar(names = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}]  Any number of named arguments. 
\item[\code{names}] A character vector of valid graphical parameter names.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
All grid viewports and (predefined) graphical objects have a slot
called \code{gp}, which contains a \code{"gpar"} object.  When
a viewport is pushed onto the viewport stack and when a graphical object
is drawn, the settings in the \code{"gpar"} object are enforced.
In this way, the graphical output is modified by the \code{gp}
settings until the graphical object has finished drawing, or until the
viewport is popped off the viewport stack, or until some other
viewport or graphical object is pushed or begins drawing.

The default parameter settings are defined by the ROOT viewport,
which takes its settings from the graphics device.
These
defaults may differ between devices (e.g., the default \code{fill}
setting is different for a PNG device compared to a PDF device).

Valid parameter names are:

\Tabular{ll}{
col & Colour for lines and borders. \\{}
fill & Colour for filling rectangles, polygons, ... \\{}
alpha & Alpha channel for transparency \\{}
lty & Line type \\{}
lwd & Line width \\{}
lex & Multiplier applied to line width \\{}
lineend & Line end style (round, butt, square) \\{}
linejoin & Line join style (round, mitre, bevel) \\{}
linemitre & Line mitre limit (number greater than 1) \\{}
fontsize & The size of text (in points) \\{}
cex & Multiplier applied to fontsize \\{}
fontfamily & The font family \\{}
fontface & The font face (bold, italic, ...) \\{}
lineheight & The height of a line as a multiple of the size of text \\{}
font & Font face (alias for fontface; for backward compatibility) \\{}
}
For more details of many of these, see the help for the corresponding
graphical parameter \code{\LinkA{par}{par}} in base graphics.  (This may
have a slightly different name, e.g. \code{lend}, \code{ljoin},
\code{lmitre}, \code{family}.)

Colours can be specified in one of the forms returned by
\code{\LinkA{rgb}{rgb}}, as a name (see \code{\LinkA{colors}{colors}}) or as a
positive integer index into the current \LinkA{palette}{palette} (with zero or
negative values being taken as transparent).

The \code{alpha} setting is combined with the alpha channel for
individual colours by multiplying (with both alpha settings
normalised to the range 0 to 1).

The size of text is \code{fontsize}*\code{cex}.  The size of a line
is \code{fontsize}*\code{cex}*\code{lineheight}.

The \code{cex} setting is cumulative;  if a viewport is pushed
with a \code{cex} of 0.5 then another viewport is pushed with a
\code{cex} of 0.5, the effective \code{cex} is 0.25.

The \code{alpha} and \code{lex} settings are also cumulative.

Changes to the \code{fontfamily} may be ignored by some devices,
but is supported by PostScript, PDF, X11, Windows, and Quartz.  The
\code{fontfamily} may be used to specify one
of the Hershey Font families (e.g., \code{HersheySerif})
and this specification will be honoured
on all devices.

The specification of \code{fontface} can be an integer or a string.
If an integer, then it
follows the R base graphics
standard:  1 = plain, 2 = bold, 3 = italic, 4 = bold italic.
If a string, then valid values are: \code{"plain"},
\code{"bold"}, \code{"italic"}, \code{"oblique"}, and
\code{"bold.italic"}.
For the special case of the HersheySerif font family,
\code{"cyrillic"}, \code{"cyrillic.oblique"}, and \code{"EUC"}
are also available.

All parameter values can be vectors of multiple values.  (This will
not always make sense -- for example, viewports will only take
notice of the first parameter value.)

The \code{gamma} parameter is defunct since \R{} 2.7.0.

\code{get.gpar()} returns all current graphical parameter settings.
\end{Details}
%
\begin{Value}
An object of class \code{"gpar"}.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{Hershey}{Hershey}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
gp <- get.gpar()
utils::str(gp)
## These *do* nothing but produce a "gpar" object:
gpar(col = "red")
gpar(col = "blue", lty = "solid", lwd = 3, fontsize = 16)
get.gpar(c("col", "lty"))
grid.newpage()
vp <- viewport(w = .8, h = .8, gp = gpar(col="blue"))
grid.draw(gTree(children=gList(rectGrob(gp = gpar(col="red")),
                     textGrob(paste("The rect is its own colour (red)",
                                    "but this text is the colour",
                                    "set by the gTree (green)",
                                    sep = "\n"))),
      gp = gpar(col="green"), vp = vp))
grid.text("This text is the colour set by the viewport (blue)",
          y = 1, just = c("center", "bottom"),
          gp = gpar(fontsize=20), vp = vp)
grid.newpage()
## example with multiple values for a parameter
pushViewport(viewport())
grid.points(1:10/11, 1:10/11, gp = gpar(col=1:10))
popViewport()
\end{ExampleCode}
\end{Examples}
\HeaderA{gPath}{ Concatenate Grob Names }{gPath}
\keyword{dplot}{gPath}
%
\begin{Description}\relax
This function can be used to generate a grob path for use
in \code{grid.edit} and friends.

A grob path is a list of nested grob names.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
gPath(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}]  Character values which are grob names. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Grob names must only be unique amongst grobs which
share the same parent in a gTree.

This function can be used to generate a specification for
a grob that includes the grob's parent's name
(and the name of its parent and so on).

For interactive use, it is possible to directly specify
a path, but it is strongly recommended that this function
is used otherwise in case the path separator is changed
in future versions of grid.
\end{Details}
%
\begin{Value}
A \code{ gPath } object.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}},
\code{\LinkA{editGrob}{editGrob}},
\code{\LinkA{addGrob}{addGrob}},
\code{\LinkA{removeGrob}{removeGrob}},
\code{\LinkA{getGrob}{getGrob}},
\code{\LinkA{setGrob}{setGrob}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
gPath("g1", "g2")
\end{ExampleCode}
\end{Examples}
\HeaderA{Grid}{Grid Graphics}{Grid}
\keyword{dplot}{Grid}
%
\begin{Description}\relax
General information about the grid graphics package.
\end{Description}
%
\begin{Details}\relax
Grid graphics provides an alternative to the standard R graphics.
The user is able to define arbitrary rectangular regions (called
\emph{viewports}) on the graphics device and define a number of
coordinate systems for each region.  Drawing can be specified to occur
in any viewport using any of the available coordinate systems.

Grid graphics and standard R graphics do not mix!

Type \code{library(help = grid)} to see a list of (public)
Grid graphics functions.
\end{Details}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{grid.layout}{grid.layout}}, and
\code{\LinkA{unit}{unit}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Diagram of a simple layout 
grid.show.layout(grid.layout(4,2,
                     heights=unit(rep(1, 4),
                                  c("lines", "lines", "lines", "null")),
                     widths=unit(c(1, 1), "inches")))
## Diagram of a sample viewport
grid.show.viewport(viewport(x=0.6, y=0.6,
                            w=unit(1, "inches"), h=unit(1, "inches")))
## A flash plotting example
grid.multipanel(vp=viewport(0.5, 0.5, 0.8, 0.8))
\end{ExampleCode}
\end{Examples}
\HeaderA{Grid Viewports}{Create a Grid Viewport}{Grid Viewports}
\aliasA{viewport}{Grid Viewports}{viewport}
\aliasA{vpList}{Grid Viewports}{vpList}
\aliasA{vpStack}{Grid Viewports}{vpStack}
\aliasA{vpTree}{Grid Viewports}{vpTree}
\keyword{dplot}{Grid Viewports}
%
\begin{Description}\relax
These functions create viewports, which describe rectangular regions
on a graphics device and define a number of coordinate systems within
those regions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
viewport(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         width = unit(1, "npc"), height = unit(1, "npc"),
         default.units = "npc", just = "centre", 
         gp = gpar(), clip = "inherit",
         xscale = c(0, 1), yscale = c(0, 1),
         angle = 0,
         layout = NULL,
         layout.pos.row = NULL, layout.pos.col = NULL,
         name = NULL)
vpList(...)
vpStack(...)
vpTree(parent, children)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-location.
\item[\code{y}] A numeric vector or unit object specifying y-location.
\item[\code{width}] A numeric vector or unit object specifying width.
\item[\code{height}] A numeric vector or unit object specifying height.
\item[\code{default.units}] A string indicating the default units to use
if \code{x}, \code{y}, \code{width}, or \code{height}
are only given as numeric vectors. 
\item[\code{just}] A string or numeric
vector specifying the justification of the viewport
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: \code{"left"},
\code{"right"}, \code{"centre"}, \code{"center"}, \code{"bottom"},
and \code{"top"}.  For numeric values, 0 means left alignment
and 1 means right alignment.

\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{clip}] One of \code{"on"}, \code{"inherit"}, or
\code{"off"}, indicating whether to
clip to the extent of this viewport, inherit the clipping region
from the parent viewport, or turn clipping off altogether.
For back-compatibility, a logical value of \code{TRUE} corresponds
to \code{"on"} and \code{FALSE} corresponds to \code{"inherit"}.
\item[\code{xscale}] A numeric vector of length two indicating the minimum and
maximum on the x-scale.
\item[\code{yscale}] A numeric vector of length two indicating the minimum
and maximum on the y-scale.
\item[\code{angle}] A numeric value indicating the angle of rotation of the
viewport.  Positive values indicate the amount of rotation, in
degrees, anticlockwise from the positive x-axis.
\item[\code{layout}] A Grid layout object which splits the viewport into
subregions.
\item[\code{layout.pos.row}] A numeric vector giving the
rows occupied by this viewport in its
parent's layout.
\item[\code{layout.pos.col}] A numeric vector giving the
columns occupied by this viewport in its
parent's layout.
\item[\code{name}] A character value to uniquely identify the viewport
once it has been pushed onto the viewport tree.  
\item[\code{...}] Any number of grid viewport objects.
\item[\code{parent}] A grid viewport object.
\item[\code{children}] A vpList object.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The location and size of a viewport are relative to the coordinate
systems defined by the viewport's parent (either a graphical device
or another viewport).  The location and size can be specified in a
very flexible way by specifying them with unit objects.
When specifying the location of a viewport, specifying
both \code{layout.pos.row} and \code{layout.pos.col} as \code{NULL}
indicates that
the viewport ignores its parent's layout and specifies its own
location and size (via its \code{locn}).  If only one of
\code{layout.pos.row} and \code{layout.pos.col} is \code{NULL}, this
means occupy ALL of the appropriate row(s)/column(s).  For example,
\code{layout.pos.row = 1} and \code{layout.pos.col = NULL} means
occupy all of row 1.  Specifying non-\code{NULL} values for both
\code{layout.pos.row} and \code{layout.pos.col} means occupy the
intersection of the appropriate rows and columns.  If a vector of
length two is
specified for \code{layout.pos.row} or \code{layout.pos.col}, this
indicates a range of rows or columns to occupy.  For example,
\code{layout.pos.row = c(1, 3)} and \code{layout.pos.col = c(2, 4)}
means occupy cells in the intersection of rows 1, 2, and 3, and
columns, 2, 3, and 4.

Clipping obeys only the most recent viewport clip setting.
For example, if you clip to viewport1, then clip to viewport2,
the clipping region is determined wholly by viewport2, the
size and shape of viewport1 is irrelevant (until viewport2
is popped of course).

If a viewport is rotated (because of its own \code{angle} setting
or because it is within another viewport which is rotated) then
the \code{clip} flag is ignored.

Viewport names need not be unique.  When pushed, viewports
sharing the same parent must have unique names, which means that
if you push a viewport with the same name as an existing viewport,
the existing viewport will be replaced in the viewport tree.
A viewport name can be any string, but
grid uses the
reserved name \code{"ROOT"} for the top-level viewport.  Also,
when specifying a viewport name in \code{downViewport}
and \code{seekViewport}, it is possible to provide a viewport
path, which consists of several names concatenated using the
separator  (currently \code{::}).  Consequently, it is not
advisable to use this separator in viewport names.

The viewports in a \code{vpList} are pushed in parallel.  The
viewports in a \code{vpStack} are pushed in series.  When a
\code{vpTree} is pushed, the parent is pushed first, then the
children are pushed in parallel.
\end{Details}
%
\begin{Value}
An R object of class \code{viewport}.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{pushViewport}{pushViewport}},
\code{\LinkA{popViewport}{popViewport}},
\code{\LinkA{downViewport}{downViewport}},
\code{\LinkA{seekViewport}{seekViewport}},
\code{\LinkA{upViewport}{upViewport}},
\code{\LinkA{unit}{unit}},
\code{\LinkA{grid.layout}{grid.layout}},
\code{\LinkA{grid.show.layout}{grid.show.layout}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Diagram of a sample viewport
grid.show.viewport(viewport(x=0.6, y=0.6,
                   w=unit(1, "inches"), h=unit(1, "inches")))
# Demonstrate viewport clipping
clip.demo <- function(i, j, clip1, clip2) {
  pushViewport(viewport(layout.pos.col=i,
                         layout.pos.row=j))
  pushViewport(viewport(width=0.6, height=0.6, clip=clip1))
  grid.rect(gp=gpar(fill="white"))
  grid.circle(r=0.55, gp=gpar(col="red", fill="pink"))
  popViewport()
  pushViewport(viewport(width=0.6, height=0.6, clip=clip2))
  grid.polygon(x=c(0.5, 1.1, 0.6, 1.1, 0.5, -0.1, 0.4, -0.1),
               y=c(0.6, 1.1, 0.5, -0.1, 0.4, -0.1, 0.5, 1.1),
               gp=gpar(col="blue", fill="light blue"))
  popViewport(2)
}

grid.newpage()
grid.rect(gp=gpar(fill="grey"))
pushViewport(viewport(layout=grid.layout(2, 2)))
clip.demo(1, 1, FALSE, FALSE)
clip.demo(1, 2, TRUE, FALSE)
clip.demo(2, 1, FALSE, TRUE)
clip.demo(2, 2, TRUE, TRUE)
popViewport()
# Demonstrate turning clipping off
grid.newpage()
pushViewport(viewport(w=.5, h=.5, clip="on"))
grid.rect()
grid.circle(r=.6, gp=gpar(lwd=10))
pushViewport(viewport(clip="inherit"))
grid.circle(r=.6, gp=gpar(lwd=5, col="grey"))
pushViewport(viewport(clip="off"))
grid.circle(r=.6)
popViewport(3)
# Demonstrate vpList, vpStack, and vpTree
grid.newpage()
tree <- vpTree(viewport(w=0.8, h=0.8, name="A"),
               vpList(vpStack(viewport(x=0.1, y=0.1, w=0.5, h=0.5,
                                       just=c("left", "bottom"), name="B"),
                              viewport(x=0.1, y=0.1, w=0.5, h=0.5, 
                                       just=c("left", "bottom"), name="C"),
                              viewport(x=0.1, y=0.1, w=0.5, h=0.5, 
                                       just=c("left", "bottom"), name="D")),
                      viewport(x=0.5, w=0.4, h=0.9,
                               just="left", name="E")))
pushViewport(tree)
for (i in LETTERS[1:5]) {
  seekViewport(i)
  grid.rect()
  grid.text(current.vpTree(FALSE),
            x=unit(1, "mm"), y=unit(1, "npc") - unit(1, "mm"),
            just=c("left", "top"),
            gp=gpar(fontsize=8))
}
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.add}{Add a Grid Graphical Object}{grid.add}
\aliasA{addGrob}{grid.add}{addGrob}
\aliasA{setChildren}{grid.add}{setChildren}
\keyword{dplot}{grid.add}
%
\begin{Description}\relax
Add a grob to a gTree or a descendant of a gTree.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.add(gPath, child, strict = FALSE, grep = FALSE,
         global = FALSE, allDevices = FALSE, redraw = TRUE) 

addGrob(gTree, child, gPath = NULL, strict = FALSE, grep = FALSE,
        global = FALSE, warn = TRUE)

setChildren(x, children)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{gTree, x}] A gTree object.
\item[\code{gPath}]  A gPath object. For \code{grid.add} this
specifies a gTree on the display list.  For \code{addGrob} this
specifies a descendant of the specified gTree. 
\item[\code{child}]  A grob object. 
\item[\code{children}]  A gList object. 
\item[\code{strict}]  A boolean indicating whether the gPath must be
matched exactly. 
\item[\code{grep}] A boolean indicating whether the \code{gPath} should
be treated as a regular expression.  Values are recycled across
elements of the \code{gPath} (e.g., \code{c(TRUE, FALSE)} means
that every odd element of the \code{gPath} will be treated as
a regular expression).

\item[\code{global}]  A boolean indicating whether the function should affect
just the first match of the \code{gPath}, or whether all matches
should be affected.

\item[\code{warn}] A logical to indicate whether failing to find the
specified gPath should trigger an error.  
\item[\code{allDevices}]  A boolean indicating whether all open devices
should
be searched for matches, or just the current device.
NOT YET IMPLEMENTED.

\item[\code{redraw}] A logical value to indicate whether to redraw the grob. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{addGrob} copies the specified grob and returns a modified
grob.

\code{grid.add} destructively modifies a grob on the display list.
If \code{redraw}
is \code{TRUE} it then redraws everything to reflect the change.

\code{setChildren} is a basic function for setting all children
of a gTree at once (instead of repeated calls to \code{addGrob}).
\end{Details}
%
\begin{Value}
\code{addGrob} returns a grob object;  \code{grid.add} returns \code{NULL}.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}}, \code{\LinkA{getGrob}{getGrob}},
\code{\LinkA{addGrob}{addGrob}}, \code{\LinkA{removeGrob}{removeGrob}}.
\end{SeeAlso}
\HeaderA{grid.arrows}{ Draw Arrows }{grid.arrows}
\aliasA{arrowsGrob}{grid.arrows}{arrowsGrob}
\keyword{dplot}{grid.arrows}
%
\begin{Description}\relax
Functions to create and draw arrows at either end of a line, or at
either end of a 
line.to, lines, or segments grob.

These functions have been deprecated in favour of \code{arrow}
arguments to the line-related primitives.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.arrows(x = c(0.25, 0.75), y = 0.5, default.units = "npc",
            grob = NULL,
            angle = 30, length = unit(0.25, "inches"),
            ends = "last", type = "open", name = NULL,
            gp = gpar(), draw = TRUE, vp = NULL)

arrowsGrob(x = c(0.25, 0.75), y = 0.5, default.units = "npc",
            grob = NULL,
            angle = 30, length = unit(0.25, "inches"),
            ends = "last", type = "open", name = NULL,
            gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-values.
\item[\code{y}] A numeric vector or unit object specifying y-values.
\item[\code{default.units}] A string indicating the default units to use
if \code{x} or \code{y} are only given as numeric vectors. 
\item[\code{grob}]  A grob to add arrows to;  currently can only be
a line.to, lines, or segments grob. 
\item[\code{angle}]  A numeric specifying (half) the width of the arrow head
(in degrees). 
\item[\code{length}]  A unit object specifying the length of the arrow head. 
\item[\code{ends}]  One of \code{"first"}, \code{"last"}, or \code{"both"},
indicating which end of the line to add arrow heads. 
\item[\code{type}]  Either \code{"open"} or \code{"closed"} to indicate
the type of arrow head.   
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create an arrows grob (a graphical object describing 
arrows), but only \code{grid.arrows()}
draws the arrows (and then only if \code{draw} is \code{TRUE}).

If the grob argument is specified, this overrides any x
and/or y arguments.
\end{Details}
%
\begin{Value}
An arrows grob.  \code{grid.arrows()} returns the value invisibly.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{grid.line.to}{grid.line.to}},
\code{\LinkA{grid.lines}{grid.lines}},
\code{\LinkA{grid.segments}{grid.segments}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: ## to avoid lots of deprecation warnings
pushViewport(viewport(layout=grid.layout(2, 4)))
pushViewport(viewport(layout.pos.col=1,
                       layout.pos.row=1))
grid.rect(gp=gpar(col="grey"))
grid.arrows()
popViewport()
pushViewport(viewport(layout.pos.col=2,
                       layout.pos.row=1))
grid.rect(gp=gpar(col="grey"))
grid.arrows(angle=15, type="closed")
popViewport()
pushViewport(viewport(layout.pos.col=3,
                       layout.pos.row=1))
grid.rect(gp=gpar(col="grey"))
grid.arrows(angle=5, length=unit(0.1, "npc"),
            type="closed", gp=gpar(fill="white"))
popViewport()
pushViewport(viewport(layout.pos.col=4,
                       layout.pos.row=1))
grid.rect(gp=gpar(col="grey"))
grid.arrows(x=unit(0:80/100, "npc"),
            y=unit(1 - (0:80/100)^2, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=1,
                       layout.pos.row=2))
grid.rect(gp=gpar(col="grey"))
grid.arrows(ends="both")
popViewport()
pushViewport(viewport(layout.pos.col=2,
                       layout.pos.row=2))
grid.rect(gp=gpar(col="grey"))
# Recycling arguments
grid.arrows(x=unit(1:10/11, "npc"), y=unit(1:3/4, "npc"))
popViewport()
pushViewport(viewport(layout.pos.col=3,
                       layout.pos.row=2))
grid.rect(gp=gpar(col="grey"))
# Drawing arrows on a segments grob
gs <- segmentsGrob(x0=unit(1:4/5, "npc"),
                   x1=unit(1:4/5, "npc"))
grid.arrows(grob=gs, length=unit(0.1, "npc"),
            type="closed", gp=gpar(fill="white"))
popViewport()
pushViewport(viewport(layout.pos.col=4,
                       layout.pos.row=2))
grid.rect(gp=gpar(col="grey"))
# Arrows on a lines grob
# Name these because going to grid.edit them later
gl <- linesGrob(name="curve", x=unit(0:80/100, "npc"),
                y=unit((0:80/100)^2, "npc"))
grid.arrows(name="arrowOnLine", grob=gl, angle=15, type="closed",
            gp=gpar(fill="black"))
popViewport()
pushViewport(viewport(layout.pos.col=1,
                       layout.pos.row=2))
grid.move.to(x=0.5, y=0.8)
popViewport()
pushViewport(viewport(layout.pos.col=4,
                       layout.pos.row=1))
# Arrows on a line.to grob
glt <- lineToGrob(x=0.5, y=0.2, gp=gpar(lwd=3))
grid.arrows(grob=glt, ends="first", gp=gpar(lwd=3))
popViewport(2)
grid.edit(gPath("arrowOnLine", "curve"), y=unit((0:80/100)^3, "npc"))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.bezier}{ Draw a Bezier Curve }{grid.bezier}
\aliasA{bezierGrob}{grid.bezier}{bezierGrob}
\keyword{dplot}{grid.bezier}
%
\begin{Description}\relax
These functions create and draw Bezier Curves (a curve drawn
relative to 4 control points).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.bezier(...)
bezierGrob(x = c(0, 0.5, 1, 0.5), y = c(0.5, 1, 0.5, 0),
            id = NULL, id.lengths = NULL,
            default.units = "npc", arrow = NULL, 
            name = NULL, gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-locations of
spline control points.
\item[\code{y}] A numeric vector or unit object specifying y-locations of
spline control points.
\item[\code{id}] A numeric vector used to separate locations in \code{x} and
\code{y} into multiple beziers.  All locations with the same
\code{id} belong to the same bezier.
\item[\code{id.lengths}] A numeric vector used to separate locations in \code{x} and
\code{y} into multiple bezier.  Specifies consecutive blocks of
locations which make up separate beziers.
\item[\code{default.units}] A string indicating the default units to use
if \code{x} or \code{y}
are only given as numeric vectors. 
\item[\code{arrow}] A list describing arrow heads to place at either end
of the bezier, as produced by the \code{arrow} function.
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object (or NULL).
\item[\code{...}] Arguments to be passed to \code{bezierGrob}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a beziergrob (a graphical object describing a
Bezier curve), but only \code{grid.bezier}
draws the Bezier curve.

A Bezier curve is a line drawn relative to 4 control points.  

Missing values are not allowed for \code{x} and \code{y}
(i.e., it is not valid for a control point to be missing).

The curve is currently drawn using an approximation based on
X-splines.
\end{Details}
%
\begin{Value}
A grob object.
\end{Value}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{arrow}{arrow}}.

\code{\LinkA{grid.xspline}{grid.xspline}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
x <- c(0.2, 0.2, 0.4, 0.4)
y <- c(0.2, 0.4, 0.4, 0.2)

grid.newpage()
grid.bezier(x, y)
grid.bezier(c(x, x + .4), c(y + .4, y + .4),
            id=rep(1:2, each=4))
grid.segments(.4, .6, .6, .6)
grid.bezier(x, y,
            gp=gpar(lwd=3, fill="black"),
            arrow=arrow(type="closed"),
            vp=viewport(x=.9))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.cap}{Capture a raster image}{grid.cap}
\keyword{dplot}{grid.cap}
%
\begin{Description}\relax
Capture the current contents of a graphics device as a raster
(bitmap) image.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.cap()
\end{verbatim}
\end{Usage}
%
\begin{Details}\relax
This function is only implemented for on-screen graphics devices.
\end{Details}
%
\begin{Value}
A matrix of R colour names.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grid.raster}{grid.raster}}

\code{\LinkA{dev.capabilities}{dev.capabilities}} to see if it is supported.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
dev.new(width=.5, height=.5)
grid.rect()
grid.text("hi")
cap <- grid.cap()
dev.off()

grid.raster(cap, width=.5, height=.5, interpolate=FALSE)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.circle}{ Draw a Circle }{grid.circle}
\aliasA{circleGrob}{grid.circle}{circleGrob}
\keyword{dplot}{grid.circle}
%
\begin{Description}\relax
Functions to create and draw a circle.  
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.circle(x=0.5, y=0.5, r=0.5, default.units="npc", name=NULL,
            gp=gpar(), draw=TRUE, vp=NULL)
circleGrob(x=0.5, y=0.5, r=0.5, default.units="npc", name=NULL,
            gp=gpar(), vp=NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-locations.
\item[\code{y}] A numeric vector or unit object specifying y-locations.
\item[\code{r}] A numeric vector or unit object specifying radii.
\item[\code{default.units}] A string indicating the default units to use
if \code{x}, \code{y}, \code{width}, or \code{height}
are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a circle grob (a graphical object describing a
circle), but only \code{grid.circle()}
draws the circle (and then only if \code{draw} is \code{TRUE}).

The radius may be given in any
units;  if the units are \emph{relative} (e.g., \code{"npc"} or
\code{"native"}) then the radius will be different depending on
whether it is interpreted as a width or as a height.  In such cases,
the smaller of these two values will be the result.  To see the
effect, type \code{grid.circle()} and adjust the size of the window.

What happens for very small radii is device-dependent: the
circle may become invisible or be shown at a fixed minimum size.  As
from \R{} 2.15.0, circles of zero radius will not be plotted.
\end{Details}
%
\begin{Value}
A circle grob.  \code{grid.circle()} returns the value invisibly.
\end{Value}
%
\begin{Section}{Warning}
Negative values for the radius are silently converted to their
absolute value.

\end{Section}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
\HeaderA{grid.clip}{Set the Clipping Region}{grid.clip}
\aliasA{clipGrob}{grid.clip}{clipGrob}
\keyword{dplot}{grid.clip}
%
\begin{Description}\relax
These functions set the clipping region within the current viewport
\emph{without} altering the current coordinate system.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.clip(...)
clipGrob(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         width = unit(1, "npc"), height = unit(1, "npc"),
         just = "centre", hjust = NULL, vjust = NULL, 
         default.units = "npc", name = NULL, vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-location.
\item[\code{y}] A numeric vector or unit object specifying y-location.
\item[\code{width}] A numeric vector or unit object specifying width.
\item[\code{height}] A numeric vector or unit object specifying height.
\item[\code{just}] The justification of the clip rectangle
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: \code{"left"},
\code{"right"}, \code{"centre"}, \code{"center"}, \code{"bottom"},
and \code{"top"}.  For numeric values, 0 means left alignment
and 1 means right alignment.

\item[\code{hjust}] A numeric vector specifying horizontal justification.
If specified, overrides the \code{just} setting.
\item[\code{vjust}] A numeric vector specifying vertical justification.
If specified, overrides the \code{just} setting.
\item[\code{default.units}] A string indicating the default units to use
if \code{x}, \code{y}, \code{width}, or \code{height}
are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{vp}] A Grid viewport object (or NULL).
\item[\code{...}] Arguments passed to \code{clipGrob}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a clip rectangle (a graphical object describing
a clip rectangle), but only \code{grid.clip}
enforces the clipping.

Pushing or popping a viewport \emph{always} overrides the clip
region set by a clip grob, regardless of whether that viewport
explicitly enforces a clipping region.
\end{Details}
%
\begin{Value}
\code{clipGrob} returns a clip grob.  
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# draw across entire viewport, but clipped
grid.clip(x = 0.3, width = 0.1)
grid.lines(gp=gpar(col="green", lwd=5))
# draw across entire viewport, but clipped (in different place)
grid.clip(x = 0.7, width = 0.1)
grid.lines(gp=gpar(col="red", lwd=5))
# Viewport sets new clip region
pushViewport(viewport(width=0.5, height=0.5, clip=TRUE))
grid.lines(gp=gpar(col="grey", lwd=3))
# Return to original viewport;  get 
# clip region from previous grid.clip()
# (NOT from previous viewport clip region)
popViewport()
grid.lines(gp=gpar(col="black"))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.collection}{Create a Coherent Group of Grid Graphical Objects}{grid.collection}
\keyword{dplot}{grid.collection}
%
\begin{Description}\relax
This function is deprecated; please use \code{gTree}.

This function creates a graphical object which contains
several other graphical objects.  When it is drawn, it draws
all of its children.  

It may be convenient to name the elements of the collection.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.collection(..., gp=gpar(), draw=TRUE, vp=NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] Zero or more objects of class \code{"grob"}.
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value to indicate whether to produce
graphical output.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A collection grob.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grid.grob}{grid.grob}}.
\end{SeeAlso}
\HeaderA{grid.convert}{ Convert Between Different grid Coordinate Systems }{grid.convert}
\aliasA{convertHeight}{grid.convert}{convertHeight}
\aliasA{convertUnit}{grid.convert}{convertUnit}
\aliasA{convertWidth}{grid.convert}{convertWidth}
\aliasA{convertX}{grid.convert}{convertX}
\aliasA{convertY}{grid.convert}{convertY}
\aliasA{grid.convertHeight}{grid.convert}{grid.convertHeight}
\aliasA{grid.convertWidth}{grid.convert}{grid.convertWidth}
\aliasA{grid.convertX}{grid.convert}{grid.convertX}
\aliasA{grid.convertY}{grid.convert}{grid.convertY}
\keyword{dplot}{grid.convert}
%
\begin{Description}\relax
These functions take a unit object and convert it to an
equivalent
unit object in a different coordinate system.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
convertX(x, unitTo, valueOnly = FALSE) 
convertY(x, unitTo, valueOnly = FALSE) 
convertWidth(x, unitTo, valueOnly = FALSE) 
convertHeight(x, unitTo, valueOnly = FALSE) 
convertUnit(x, unitTo,
             axisFrom = "x", typeFrom = "location",
             axisTo = axisFrom, typeTo = typeFrom,
             valueOnly = FALSE)
grid.convertX(x, unitTo, valueOnly = FALSE) 
grid.convertY(x, unitTo, valueOnly = FALSE) 
grid.convertWidth(x, unitTo, valueOnly = FALSE) 
grid.convertHeight(x, unitTo, valueOnly = FALSE) 
grid.convert(x, unitTo,
             axisFrom = "x", typeFrom = "location",
             axisTo = axisFrom, typeTo = typeFrom,
             valueOnly = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}]  A unit object. 
\item[\code{unitTo}]  The coordinate system to convert the unit to.
See the \code{\LinkA{unit}{unit}} function for valid coordinate systems.
\item[\code{axisFrom}]  Either \code{"x"} or \code{"y"} to indicate
whether the unit object represents a value in the x- or
y-direction. 
\item[\code{typeFrom}]  Either \code{"location"} or \code{"dimension"}
to indicate whether the unit object represents a location or a
length. 
\item[\code{axisTo}]  Same as \code{axisFrom}, but applies to the unit object
that is to be created. 
\item[\code{typeTo}]  Same as \code{typeFrom}, but applies to the unit object
that is to be created. 
\item[\code{valueOnly}]  A logical indicating.  If \code{TRUE} then
the function does not return a unit object, but rather only the
converted numeric values. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The \code{convertUnit} function allows for general-purpose
conversions.  The other four functions are just more convenient
front-ends to it for the most common conversions.

The conversions occur within the current viewport.

It is not currently possible to convert to all valid coordinate systems
(e.g., "strwidth" or "grobwidth").  I'm not sure if all of these
are impossible, they just seem implausible at this stage.

In normal usage of grid, these functions should not be necessary.
If you want to express a location or dimension in inches rather
than user coordinates then you should simply do something like
\code{unit(1, "inches")} rather than something like
\code{unit(0.134, "native")}.

In some cases, however, it is necessary for the user to
perform calculations on a unit value and this function becomes
necessary.  In such cases, please take note of the warning below.

The grid.* versions are just previous incarnations which have
been deprecated.
\end{Details}
%
\begin{Value}
A unit object in the specified coordinate system
(unless \code{valueOnly} is \code{TRUE} in which case
the returned value is a numeric).
\end{Value}
%
\begin{Section}{Warning}
The conversion is only valid for the current device size.
If the device is resized then at least some conversions will
become invalid.  For example, suppose that I create a unit
object as follows: \code{oneinch <- convertUnit(unit(1, "inches"),
    "native"}.  Now if I resize the device, the unit object in
oneinch no longer corresponds to a physical length of 1 inch.

\end{Section}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{unit}{unit}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## A tautology
convertX(unit(1, "inches"), "inches")
## The physical units
convertX(unit(2.54, "cm"), "inches")
convertX(unit(25.4, "mm"), "inches")
convertX(unit(72.27, "points"), "inches")
convertX(unit(1/12*72.27, "picas"), "inches")
convertX(unit(72, "bigpts"), "inches")
convertX(unit(1157/1238*72.27, "dida"), "inches")
convertX(unit(1/12*1157/1238*72.27, "cicero"), "inches")
convertX(unit(65536*72.27, "scaledpts"), "inches")
convertX(unit(1/2.54, "inches"), "cm")
convertX(unit(1/25.4, "inches"), "mm")
convertX(unit(1/72.27, "inches"), "points")
convertX(unit(1/(1/12*72.27), "inches"), "picas")
convertX(unit(1/72, "inches"), "bigpts")
convertX(unit(1/(1157/1238*72.27), "inches"), "dida")
convertX(unit(1/(1/12*1157/1238*72.27), "inches"), "cicero")
convertX(unit(1/(65536*72.27), "inches"), "scaledpts")

pushViewport(viewport(width=unit(1, "inches"),
                       height=unit(2, "inches"),
                       xscale=c(0, 1),
                       yscale=c(1, 3)))
  ## Location versus dimension
  convertY(unit(2, "native"), "inches")
  convertHeight(unit(2, "native"), "inches")
  ## From "x" to "y" (the conversion is via "inches")
  convertUnit(unit(1, "native"), "native",
               axisFrom="x", axisTo="y")
  ## Convert several values at once
  convertX(unit(c(0.5, 2.54), c("npc", "cm")),
                c("inches", "native"))
popViewport()
## Convert a complex unit
convertX(unit(1, "strwidth", "Hello"), "native")
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.copy}{Make a Copy of a Grid Graphical Object}{grid.copy}
\keyword{dplot}{grid.copy}
%
\begin{Description}\relax
This function is redundant and will disappear in future versions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.copy(grob)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{grob}] A grob object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A copy of the grob object.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grid.grob}{grid.grob}}.
\end{SeeAlso}
\HeaderA{grid.curve}{ Draw a Curve Between Locations }{grid.curve}
\aliasA{arcCurvature}{grid.curve}{arcCurvature}
\aliasA{curveGrob}{grid.curve}{curveGrob}
\keyword{dplot}{grid.curve}
%
\begin{Description}\relax
These functions create and draw a curve from one location
to another.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.curve(...)
curveGrob(x1, y1, x2, y2, default.units = "npc",
          curvature = 1, angle = 90, ncp = 1, shape = 0.5,
          square = TRUE, squareShape = 1, 
          inflect = FALSE, arrow = NULL, open = TRUE,
          debug = FALSE,
          name = NULL, gp = gpar(), vp = NULL)
arcCurvature(theta)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x1}] A numeric vector or unit object specifying the x-location of
the start point.
\item[\code{y1}] A numeric vector or unit object specifying the y-location of
the start point.
\item[\code{x2}] A numeric vector or unit object specifying the x-location of
the end point.
\item[\code{y2}] A numeric vector or unit object specifying the y-location of
the end point.
\item[\code{default.units}] A string indicating the default units to use
if \code{x1}, \code{y1}, \code{x2} or \code{y2}
are only given as numeric values.
\item[\code{curvature}] A numeric value giving the amount of curvature.
Negative values produce left-hand curves, positive values
produce right-hand curves, and zero produces a straight line.
\item[\code{angle}] A numeric value between 0 and 180,
giving an amount to skew the control
points of the curve.  Values less than 90 skew the curve towards
the start point and values greater than 90 skew the curve
towards the end point.
\item[\code{ncp}] The number of control points used to draw the curve.
More control points creates a smoother curve.
\item[\code{shape}] A numeric vector of values between -1 and 1, which
control the shape of the curve relative to its control points.
See \code{grid.xspline} for more details.
\item[\code{square}] A logical value that controls whether control
points for the curve are created city-block fashion or
obliquely.  When \code{ncp} is 1 and \code{angle} is 90,
this is typically \code{TRUE}, otherwise this should probably
be set to \code{FALSE} (see Examples below).
\item[\code{squareShape}] A \code{shape} value to control the behaviour
of the curve relative to any additional control point that
is inserted if \code{square} is \code{TRUE}.
\item[\code{inflect}] A logical value specifying whether the curve
should be cut in half and inverted (see Examples below).
\item[\code{arrow}] A list describing arrow heads to place at either end
of the curve, as produced by the \code{arrow} function.
\item[\code{open}] A logical value indicating whether to close the curve
(connect the start and end points).
\item[\code{debug}] A logical value indicating whether debugging
information should be drawn.
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object (or NULL).
\item[\code{...}] Arguments to be passed to \code{curveGrob}.
\item[\code{theta}] An angle (in degrees).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a curve grob (a graphical object describing an
curve), but only \code{grid.curve}
draws the curve.

The \code{arcCurvature} function can be used to calculate a
\code{curvature} such that control points are generated on
an arc corresponding to angle \code{theta}.  This is typically
used in conjunction with a large \code{ncp} to produce a curve
corresponding to the desired arc.
\end{Details}
%
\begin{Value}
A grob object.
\end{Value}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{grid.xspline}{grid.xspline}},
\code{\LinkA{arrow}{arrow}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
curveTest <- function(i, j, ...) {
  pushViewport(viewport(layout.pos.col=j, layout.pos.row=i))
  do.call("grid.curve", c(list(x1=.25, y1=.25, x2=.75, y2=.75), list(...)))
  grid.text(sub("list\\((.*)\\)", "\\1",
                deparse(substitute(list(...)))),
            y=unit(1, "npc"))
  popViewport()
}
# grid.newpage()
pushViewport(plotViewport(c(0, 0, 1, 0),
                          layout=grid.layout(2, 1, heights=c(2, 1))))
pushViewport(viewport(layout.pos.row=1,
                      layout=grid.layout(3, 3, respect=TRUE)))
curveTest(1, 1)
curveTest(1, 2, inflect=TRUE)
curveTest(1, 3, angle=135)
curveTest(2, 1, arrow=arrow())
curveTest(2, 2, ncp=8)
curveTest(2, 3, shape=0)
curveTest(3, 1, curvature=-1)
curveTest(3, 2, square=FALSE)
curveTest(3, 3, debug=TRUE)
popViewport()
pushViewport(viewport(layout.pos.row=2,
                      layout=grid.layout(3, 3)))
curveTest(1, 1)
curveTest(1, 2, inflect=TRUE)
curveTest(1, 3, angle=135)
curveTest(2, 1, arrow=arrow())
curveTest(2, 2, ncp=8)
curveTest(2, 3, shape=0)
curveTest(3, 1, curvature=-1)
curveTest(3, 2, square=FALSE)
curveTest(3, 3, debug=TRUE)
popViewport(2)
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.display.list}{Control the Grid Display List}{grid.display.list}
\aliasA{engine.display.list}{grid.display.list}{engine.display.list}
\keyword{dplot}{grid.display.list}
%
\begin{Description}\relax
Turn the Grid display list on or off.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.display.list(on=TRUE)
engine.display.list(on=TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{on}] A logical value to indicate whether the display list
should be on or off.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
All drawing and viewport-setting operations are (by default)
recorded in the Grid display list.  This allows redrawing
to occur following an editing operation.

This display list could get very large so it may be useful to
turn it off in some cases;  this will of course disable redrawing.

All graphics output is also recorded on the main display list
of the R graphics engine (by default).  This supports redrawing
following a device resize and allows copying between devices.

Turning off this display list means that grid will redraw from its
own display list for device resizes and copies.  This will be slower
than using the graphics engine display list.
\end{Details}
%
\begin{Value}
None.
\end{Value}
%
\begin{Section}{WARNING}
Turning the display list on causes the display list to be erased!

Turning off both the grid display list and the graphics engine
display list will result in no redrawing whatsoever.
\end{Section}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
\HeaderA{grid.DLapply}{ Modify the Grid Display List }{grid.DLapply}
\keyword{dplot}{grid.DLapply}
%
\begin{Description}\relax
Call a function on each element of the current display list
and replace the element with the result.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.DLapply(FUN, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{FUN}] A function.
\item[\code{...}] Further arguments to pass to \code{FUN} .
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This is an insanely dangerous function (for the grid display list).

Two token efforts are made to try to avoid ending up with complete
garbage on the display list:

\begin{enumerate}

\item The display list is only replaced once all new elements have
been generated (so an error during generation does not result in a
half-finished display list).
\item All new elements must be either \code{NULL} or inherit from
the class of the element that they are replacing.

\end{enumerate}

\end{Details}
%
\begin{Value}
The side effect of this function is to modify the grid display list.
\end{Value}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
grid.rect(width=.5, height=.5, gp=gpar(fill="grey"))
grid.DLapply(function(x) { if (is.grob(x)) x$gp <- gpar(); x })
grid.refresh()
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.draw}{Draw a grid grob}{grid.draw}
\keyword{dplot}{grid.draw}
%
\begin{Description}\relax
Produces graphical output from a graphical object.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.draw(x, recording=TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] An object of class \code{"grob"} or NULL.
\item[\code{recording}] A logical value to indicate whether the drawing
operation should be recorded on the Grid display list.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This is a generic function with methods for grob and gTree objects.

The grob and gTree methods automatically push any viewports in a
\code{vp} slot and automatically apply any \code{gpar} settings
in a \code{gp} slot.  In addition, the gTree method pushes and
ups any viewports in a \code{childrenvp} slot and automatically
calls \code{grid.draw} for any grobs in a \code{children} slot.

The methods for grob and gTree call the generic hook functions
\code{preDrawDetails}, \code{drawDetails}, and \code{postDrawDetails}
to allow classes derived from grob or gTree to perform
additional viewport pushing/popping and produce additional
output beyond the default behaviour for grobs and gTrees.
\end{Details}
%
\begin{Value}
None.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
## Create a graphical object, but don't draw it
l <- linesGrob()
## Draw it
grid.draw(l)
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.edit}{Edit the Description of a Grid Graphical Object}{grid.edit}
\aliasA{editGrob}{grid.edit}{editGrob}
\aliasA{grid.gedit}{grid.edit}{grid.gedit}
\keyword{dplot}{grid.edit}
%
\begin{Description}\relax
Changes the value of one of the slots of a grob
and redraws the grob.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.edit(gPath, ..., strict = FALSE, grep = FALSE,
          global = FALSE, allDevices = FALSE, redraw = TRUE)

grid.gedit(..., grep = TRUE, global = TRUE)

editGrob(grob, gPath = NULL, ..., strict = FALSE, grep = FALSE,
         global = FALSE, warn = TRUE) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{grob}] A grob object.
\item[\code{...}] Zero or more named arguments specifying new slot values.
\item[\code{gPath}]  A gPath object. For \code{grid.edit} this
specifies a grob on the display list.  For \code{editGrob} this
specifies a descendant of the specified grob. 
\item[\code{strict}]  A boolean indicating whether the gPath must be
matched exactly. 
\item[\code{grep}] A boolean indicating whether the \code{gPath} should
be treated as a regular expression.  Values are recycled across
elements of the \code{gPath} (e.g., \code{c(TRUE, FALSE)} means
that every odd element of the \code{gPath} will be treated as
a regular expression).

\item[\code{global}]  A boolean indicating whether the function should affect
just the first match of the \code{gPath}, or whether all matches
should be affected.

\item[\code{warn}] A logical to indicate whether failing to find the
specified gPath should trigger an error.  
\item[\code{allDevices}]  A boolean indicating whether all open devices
should
be searched for matches, or just the current device.
NOT YET IMPLEMENTED.

\item[\code{redraw}] A logical value to indicate whether to redraw the grob. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{editGrob} copies the specified grob and returns a modified
grob.

\code{grid.edit} destructively modifies a grob on the display list.
If \code{redraw}
is \code{TRUE} it then redraws everything to reflect the change.

Both functions call \code{editDetails} to allow a grob to perform
custom actions and \code{validDetails} to check that the modified grob
is still coherent.

\code{grid.gedit} (\code{g} for global) is just a convenience wrapper for
\code{grid.edit} with different defaults.
\end{Details}
%
\begin{Value}
\code{editGrob} returns a grob object;  \code{grid.edit} returns \code{NULL}.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}}, \code{\LinkA{getGrob}{getGrob}},
\code{\LinkA{addGrob}{addGrob}}, \code{\LinkA{removeGrob}{removeGrob}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
grid.xaxis(name = "xa", vp = viewport(width=.5, height=.5))
grid.edit("xa", gp = gpar(col="red"))
# won't work because no ticks (at is NULL)
try(grid.edit(gPath("xa", "ticks"), gp = gpar(col="green")))
grid.edit("xa", at = 1:4/5)
# Now it should work
try(grid.edit(gPath("xa", "ticks"), gp = gpar(col="green")))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.frame}{ Create a Frame for Packing Objects }{grid.frame}
\aliasA{frameGrob}{grid.frame}{frameGrob}
\keyword{dplot}{grid.frame}
%
\begin{Description}\relax
These functions, together with \code{grid.pack},
\code{grid.place}, \code{packGrob}, and \code{placeGrob} are part of a
GUI-builder-like interface to constructing graphical images.
The idea is that you create a frame with this function then
use \code{grid.pack} or whatever to pack/place objects into the frame.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.frame(layout=NULL, name=NULL, gp=gpar(), vp=NULL, draw=TRUE)
frameGrob(layout=NULL, name=NULL, gp=gpar(), vp=NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{layout}]  A Grid layout, or NULL. This can be used to initialise
the frame with a number of rows and columns, with initial widths
and heights, etc. 
\item[\code{name}]  A character identifier. 
\item[\code{vp}]  An object of class \code{viewport}, or NULL. 
\item[\code{gp}]  An object of class \code{gpar};  typically the output from
a call to the function \code{gpar}.
\item[\code{draw}]  Should the frame be drawn.  
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a frame grob (a graphical object describing a
frame), but only \code{grid.frame()}
draws the frame (and then only if \code{draw} is \code{TRUE}).
Nothing will actually be
drawn, but it will put the frame on the display list, which means
that the output will be dynamically updated as objects are packed
into the frame.  Possibly useful for debugging.
\end{Details}
%
\begin{Value}
A frame grob.  \code{grid.frame()} returns the value invisibly.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grid.pack}{grid.pack}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
grid.frame(name="gf", draw=TRUE)
grid.pack("gf", rectGrob(gp=gpar(fill="grey")), width=unit(1, "null"))
grid.pack("gf", textGrob("hi there"), side="right")
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.function}{Draw a curve representing a function}{grid.function}
\aliasA{functionGrob}{grid.function}{functionGrob}
\aliasA{grid.abline}{grid.function}{grid.abline}
\keyword{dplot}{grid.function}
%
\begin{Description}\relax
Draw a curve representing a function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.function(...)
functionGrob(f, n = 101, range = "x", units = "native",
             name = NULL, gp=gpar(), vp = NULL)

grid.abline(intercept, slope, ...) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}]  A function that must take a single argument
and return a list with two numeric components named \code{x} and
\code{y}.
\item[\code{n}]  The number values that will be generated as input
to the function \code{f}.
\item[\code{range}]  Either \code{"x"}, \code{"y"}, or a numeric vector.
See the `Details' section.
\item[\code{units}] A string indicating the units to use
for the \code{x} and \code{y} values generated by the function.
\item[\code{intercept}]  Numeric.
\item[\code{slope}]  Numeric. 
\item[\code{...}]  Arguments passed to \code{grid.function()}
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{n} values are generated and passed to the function \code{f}
and a series of lines are
drawn through the resulting \code{x} and \code{y} values.

The generation of the \code{n} values depends on the value of 
\code{range}.  In the default case, \code{dim} is
\code{"x"}, which means that a set
of \code{x} values are generated covering the range of the current
viewport scale in the x-dimension.  If \code{dim} is \code{"y"}
then values are generated from the current y-scale instead.
If \code{range} is a numeric vector, then values are generated
from that range.

\code{grid.abline()} provides a simple front-end for a straight
line parameterized by \code{intercept} and \code{slope}.
\end{Details}
%
\begin{Value}
A functiongrob grob.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
    # abline
    # NOTE: in ROOT viewport on screen, (0, 0) at top-left
    #       and "native" is pixels!
    grid.function(function(x) list(x=x, y=0 + 1*x))
    # a more "normal" viewport with default normalized "native" coords
    grid.newpage()
    pushViewport(viewport())
    grid.function(function(x) list(x=x, y=0 + 1*x))
    # slightly simpler
    grid.newpage()
    pushViewport(viewport())
    grid.abline()
    # sine curve
    grid.newpage()
    pushViewport(viewport(xscale=c(0, 2*pi), yscale=c(-1, 1)))
    grid.function(function(x) list(x=x, y=sin(x)))
    # constrained sine curve
    grid.newpage()
    pushViewport(viewport(xscale=c(0, 2*pi), yscale=c(-1, 1)))
    grid.function(function(x) list(x=x, y=sin(x)),
                  range=0:1)
    # inverse sine curve
    grid.newpage()
    pushViewport(viewport(xscale=c(-1, 1), yscale=c(0, 2*pi)))
    grid.function(function(y) list(x=sin(y), y=y),
                  range="y")
    # parametric function
    grid.newpage()
    pushViewport(viewport(xscale=c(-1, 1), yscale=c(-1, 1)))
    grid.function(function(t) list(x=cos(t), y=sin(t)),
                  range=c(0, 9*pi/5))
    # physical abline
    grid.newpage()
    grid.function(function(x) list(x=x, y=0 + 1*x),
                  units="in")
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.get}{Get a Grid Graphical Object}{grid.get}
\aliasA{getGrob}{grid.get}{getGrob}
\aliasA{grid.gget}{grid.get}{grid.gget}
\keyword{dplot}{grid.get}
%
\begin{Description}\relax
Retrieve a grob or a descendant of a grob.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.get(gPath, strict = FALSE, grep = FALSE, global = FALSE,
         allDevices = FALSE)

grid.gget(..., grep = TRUE, global = TRUE)

getGrob(gTree, gPath, strict = FALSE, grep = FALSE, global = FALSE) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{gTree}] A gTree object.
\item[\code{gPath}]  A gPath object. For \code{grid.get} this
specifies a grob on the display list.  For \code{getGrob} this
specifies a descendant of the specified gTree. 
\item[\code{strict}]  A boolean indicating whether the gPath must be
matched exactly. 
\item[\code{grep}] A boolean indicating whether the \code{gPath} should
be treated as a regular expression.  Values are recycled across
elements of the \code{gPath} (e.g., \code{c(TRUE, FALSE)} means
that every odd element of the \code{gPath} will be treated as
a regular expression).

\item[\code{global}]  A boolean indicating whether the function should affect
just the first match of the \code{gPath}, or whether all matches
should be affected.

\item[\code{allDevices}]  A boolean indicating whether all open devices
should
be searched for matches, or just the current device.
NOT YET IMPLEMENTED.

\item[\code{...}]  Arguments that are passed to \code{grid.get}. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{grid.gget} (\code{g} for global) is just a convenience wrapper for
\code{grid.get} with different defaults.
\end{Details}
%
\begin{Value}
A grob object.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}}, \code{\LinkA{getGrob}{getGrob}},
\code{\LinkA{addGrob}{addGrob}}, \code{\LinkA{removeGrob}{removeGrob}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.xaxis(name="xa")
grid.get("xa")
grid.get(gPath("xa", "ticks"))

grid.draw(gTree(name="gt", children=gList(xaxisGrob(name="axis"))))
grid.get(gPath("gt", "axis", "ticks"))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.grab}{ Grab the current grid output }{grid.grab}
\aliasA{grid.grabExpr}{grid.grab}{grid.grabExpr}
\keyword{dplot}{grid.grab}
%
\begin{Description}\relax
Creates a gTree object from the current grid display list
or from a scene generated by user-specified code.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.grab(warn = 2, wrap = FALSE, ...)
grid.grabExpr(expr, warn = 2, wrap = FALSE, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{expr}]  An expression to be evaluated.  Typically,
some calls to grid drawing functions. 
\item[\code{warn}]  An integer specifying the amount of warnings
to emit.  0 means no warnings, 1 means warn when it is
certain that the grab will not faithfully represent the
original scene. 2 means warn if there's any possibility
that the grab will not faithfully represent the
original scene.

\item[\code{wrap}]  A logical indicating how the output should
be captured. If \code{TRUE}, each non-grob element on the
display list is captured by wrapping it in a grob.  

\item[\code{...}]  arguments passed to gTree, for example, a
name and/or class for the gTree that is created.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
There are four ways to capture grid output as a gTree.

There are two functions for capturing output:
use \code{grid.grab} to capture an existing drawing
and \code{grid.grabExpr} to capture the output from
an expression (without drawing anything).

For each of these functions, the output can be captured in
two ways.  One way tries to be clever and make a
gTree with a childrenvp slot containing all viewports on
the display list (including those
that are popped) and every
grob on the display list as a child of the new
gTree;  each child has a vpPath in the vp slot so that it is
drawn in the appropriate viewport.
In other words, the gTree contains all elements on the display
list, but in a slightly altered form.

The other way, \code{wrap=TRUE},
is to create a grob for every element on the
display list (and make all of those grobs children of the
gTree).

The first approach creates a more compact and elegant gTree,
which is more flexible to work with,
but is not guaranteed to faithfully replicate all possible
grid output.  The second approach is more brute force, and
harder to work with, but
should always faithfully replicate the original output.
\end{Details}
%
\begin{Value}
A gTree object.
\end{Value}
%
\begin{SeeAlso}\relax
 \code{\LinkA{gTree}{gTree}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
pushViewport(viewport(w=.5, h=.5))
grid.rect()
grid.points(stats::runif(10), stats::runif(10))
popViewport()
grab <- grid.grab()
grid.newpage()
grid.draw(grab)
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.grill}{Draw a Grill}{grid.grill}
\keyword{dplot}{grid.grill}
%
\begin{Description}\relax
This function draws a grill within a Grid viewport.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.grill(h = unit(seq(0.25, 0.75, 0.25), "npc"),
           v = unit(seq(0.25, 0.75, 0.25), "npc"),
           default.units = "npc", gp=gpar(col = "grey"), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{h}] A numeric vector or unit object
indicating the horizontal location of the
vertical grill lines.
\item[\code{v}] A numeric vector or unit object
indicating the vertical location of the
horizontal grill lines.
\item[\code{default.units}] A string indicating the default units to use
if \code{h} or \code{v} are only given as numeric vectors.
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}.
\end{SeeAlso}
\HeaderA{grid.grob}{Create a Grid Graphical Object}{grid.grob}
\aliasA{childNames}{grid.grob}{childNames}
\aliasA{gList}{grid.grob}{gList}
\aliasA{grob}{grid.grob}{grob}
\aliasA{grobTree}{grid.grob}{grobTree}
\aliasA{gTree}{grid.grob}{gTree}
\aliasA{is.grob}{grid.grob}{is.grob}
\keyword{dplot}{grid.grob}
%
\begin{Description}\relax
These functions create grid graphical objects.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.grob(list.struct, cl = NULL, draw = TRUE)
grob(..., name = NULL, gp = NULL, vp = NULL, cl = NULL)
gTree(..., name = NULL, gp = NULL, vp = NULL, children = NULL, 
      childrenvp = NULL, cl = NULL)
grobTree(..., name = NULL, gp = NULL, vp = NULL, 
         childrenvp = NULL, cl = NULL)
childNames(gTree)
gList(...)
is.grob(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}]  For \code{grob} and \code{gTree}, the
named slots describing important features of
the graphical object. For \code{gList} and \code{grobTree},
a series of grob objects. 
\item[\code{list.struct}] A list (preferably with each element named).
\item[\code{name}]  A character identifier for the grob.  Used to find the
grob on the display list and/or as a child of another grob. 
\item[\code{children}]  A gList object. 
\item[\code{childrenvp}]  A viewport object (or \code{NULL}).
\item[\code{gp}] A gpar object, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A viewport object (or \code{NULL}).
\item[\code{cl}] A string giving the class attribute for the \code{list.struct}
\item[\code{draw}] A logical value to indicate whether to produce
graphical output.
\item[\code{gTree}] A gTree object.
\item[\code{x}]  An R object. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
These functions can be used to create a basic grob, gTree, or gList
object, or a new class derived from one of these.

A grid graphical object (grob) is a description of a graphical
item.  These basic classes provide default behaviour for
validating, drawing,
and modifying graphical objects.  Both call the function
\code{validDetails} to check that the object returned is coherent.

A gTree can have other grobs as children;  when a gTree is drawn, it
draws all of its children.  Before drawing its children, a gTree
pushes its childrenvp slot and then navigates back up (calls
\code{upViewport}) so that the children can specify their location
within the childrenvp via a vpPath.

Grob names need not be unique in general, but all children of a
gTree must have different names.  
A grob name can be any string, though
it is not
advisable to use the gPath separator  (currently \code{::}) in
grob names.

The function \code{childNames} returns the names of the grobs
which are children of a gTree.

All grid primitives (\code{grid.lines}, \code{grid.rect}, ...) and
some higher-level grid components (e.g., \code{grid.xaxis} and
\code{grid.yaxis}) are derived from these classes.

\code{grobTree} is just a convenient wrapper for \code{gTree}
when the only components of the gTree are grobs (so all
unnamed arguments become children of the gTree).

\code{grid.grob} is deprecated.

\end{Details}
%
\begin{Value}
A grob object.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grid.draw}{grid.draw}},
\code{\LinkA{grid.edit}{grid.edit}},
\code{\LinkA{grid.get}{grid.get}}.
\end{SeeAlso}
\HeaderA{grid.layout}{Create a Grid Layout}{grid.layout}
\keyword{dplot}{grid.layout}
%
\begin{Description}\relax
This function returns a Grid layout, which describes a subdivision
of a rectangular region.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.layout(nrow = 1, ncol = 1,
        widths = unit(rep(1, ncol), "null"),
        heights = unit(rep(1, nrow), "null"),
        default.units = "null", respect = FALSE,
        just="centre")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{nrow}] An integer describing the number of rows in the layout.
\item[\code{ncol}] An integer describing the number of columns in the layout.
\item[\code{widths}] A numeric vector or unit object
describing the widths of the columns
in the layout.
\item[\code{heights}] A numeric vector or unit object
describing the heights of the rows
in the layout.
\item[\code{default.units}] A string indicating the default units to use
if \code{widths} or \code{heights} are only given as numeric vectors. 
\item[\code{respect}] A logical value or a numeric matrix.
If a logical, this indicates whether
row heights and column widths should respect each other.
If a matrix, non-zero values indicate that the corresponding
row and column should be respected (see examples below).

\item[\code{just}] A string or numeric
vector specifying how the 
layout should be
justified if it is not the same size as its parent viewport.
If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: \code{"left"},
\code{"right"}, \code{"centre"}, \code{"center"}, \code{"bottom"},
and \code{"top"}.  For numeric values, 0 means left alignment
and 1 means right alignment. NOTE that in this context,
\code{"left"}, for example, means align the left
edge of the left-most layout column with the left edge of the
parent viewport.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The unit objects given for the \code{widths} and \code{heights}
of a layout may use a special \code{units} that only has
meaning for layouts.  This is the \code{"null"} unit, which
indicates what relative fraction of the available width/height the
column/row occupies.  See the reference for a better description
of relative widths and heights in layouts.
\end{Details}
%
\begin{Value}
A Grid layout object.
\end{Value}
%
\begin{Section}{WARNING}
This function must NOT be confused with the base R graphics function
\code{layout}.  In particular, do not use \code{layout} in
combination with Grid graphics.  The documentation for
\code{layout} may provide some useful information and this
function should behave identically in comparable situations.  The
\code{grid.layout} 
function has \emph{added} the ability to specify a broader range
of units for row heights and column widths, and allows for nested
layouts (see \code{viewport}).
\end{Section}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{References}\relax
Murrell, P. R. (1999), Layouts: A Mechanism for Arranging
Plots on a Page, \emph{Journal of Computational and Graphical
Statistics}, \bold{8}, 121--134.
\end{References}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{grid.show.layout}{grid.show.layout}},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{layout}{layout}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## A variety of layouts (some a bit mid-bending ...)
layout.torture()
## Demonstration of layout justification
grid.newpage()
testlay <- function(just="centre") {
  pushViewport(viewport(layout=grid.layout(1, 1, widths=unit(1, "inches"),
                          heights=unit(0.25, "npc"),
                          just=just)))
  pushViewport(viewport(layout.pos.col=1, layout.pos.row=1))
  grid.rect()
  grid.text(paste(just, collapse="-"))
  popViewport(2)
}
testlay()
testlay(c("left", "top"))
testlay(c("right", "top"))
testlay(c("right", "bottom"))
testlay(c("left", "bottom"))
testlay(c("left"))
testlay(c("right"))
testlay(c("bottom"))
testlay(c("top"))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.lines}{Draw Lines in a Grid Viewport}{grid.lines}
\aliasA{grid.polyline}{grid.lines}{grid.polyline}
\aliasA{linesGrob}{grid.lines}{linesGrob}
\aliasA{polylineGrob}{grid.lines}{polylineGrob}
\keyword{dplot}{grid.lines}
%
\begin{Description}\relax
These functions create and draw a series of lines.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.lines(x = unit(c(0, 1), "npc"),
          y = unit(c(0, 1), "npc"), 
          default.units = "npc", 
          arrow = NULL, name = NULL,
          gp=gpar(), draw = TRUE, vp = NULL)
linesGrob(x = unit(c(0, 1), "npc"),
          y = unit(c(0, 1), "npc"), 
          default.units = "npc", 
          arrow = NULL, name = NULL,
          gp=gpar(), vp = NULL)
grid.polyline(...)
polylineGrob(x = unit(c(0, 1), "npc"),
             y = unit(c(0, 1), "npc"), 
             id=NULL, id.lengths=NULL,
             default.units = "npc", 
             arrow = NULL, name = NULL,
             gp=gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-values.
\item[\code{y}] A numeric vector or unit object specifying y-values.
\item[\code{default.units}] A string indicating the default units to use
if \code{x} or \code{y} are only given as numeric vectors. 
\item[\code{arrow}] A list describing arrow heads to place at either end
of the line, as produced by the \code{arrow} function.
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or NULL).
\item[\code{id}] A numeric vector used to separate locations in \code{x} and
\code{y} into multiple lines.  All locations with the same
\code{id} belong to the same line.
\item[\code{id.lengths}] A numeric vector used to separate locations in \code{x} and
\code{y} into multiple lines.  Specifies consecutive blocks of
locations which make up separate lines.
\item[\code{...}] Arguments passed to \code{polylineGrob}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The first two functions create a lines grob (a graphical object describing
lines), and \code{grid.lines}
draws the lines (if \code{draw} is \code{TRUE}).

The second two functions create or draw a polyline grob,
which is just like a lines grob, except that there can be
multiple distinct lines drawn.
\end{Details}
%
\begin{Value}
A lines grob or a polyline grob.
\code{grid.lines} returns a lines grob invisibly.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{arrow}{arrow}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.lines()
# Using id (NOTE: locations are not in consecutive blocks)
grid.newpage()
grid.polyline(x=c((0:4)/10, rep(.5, 5), (10:6)/10, rep(.5, 5)),
             y=c(rep(.5, 5), (10:6/10), rep(.5, 5), (0:4)/10),
             id=rep(1:5, 4),
             gp=gpar(col=1:5, lwd=3))
# Using id.lengths
grid.newpage()
grid.polyline(x=outer(c(0, .5, 1, .5), 5:1/5),
             y=outer(c(.5, 1, .5, 0), 5:1/5),
             id.lengths=rep(4, 5),
             gp=gpar(col=1:5, lwd=3))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.locator}{ Capture a Mouse Click }{grid.locator}
\keyword{dplot}{grid.locator}
%
\begin{Description}\relax
Allows the user to click the mouse once within the current
graphics
device and returns the location of the mouse click within the
current viewport, in the specified coordinate system.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.locator(unit = "native")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{unit}]  The coordinate system in which to return the location
of the mouse click.
See the \code{\LinkA{unit}{unit}} function for valid coordinate systems.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function is modal (like the graphics package
function \code{locator}) so
the command line and graphics drawing is blocked until
the use has clicked the mouse  in the current device.
\end{Details}
%
\begin{Value}
A unit object representing the location of the mouse click within the
current viewport, in the specified coordinate system.

If the user did not click mouse button 1, the function
(invisibly) returns \code{NULL}.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{viewport}{viewport}}, \code{\LinkA{unit}{unit}},
\code{locator} in package \pkg{graphics}, and for an application
see \code{\LinkA{trellis.focus}{trellis.focus}} and
\code{\LinkA{panel.identify}{panel.identify}} in package
\Rhref{http://CRAN.R-project.org/package=lattice}{\pkg{lattice}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
if (interactive()) {
  ## Need to write a more sophisticated unit as.character method
  unittrim <- function(unit) {
    sub("^([0-9]+|[0-9]+[.][0-9])[0-9]*", "\\1", as.character(unit))
  }
  do.click <- function(unit) {
    click.locn <- grid.locator(unit)
    grid.segments(unit.c(click.locn$x, unit(0, "npc")),
                  unit.c(unit(0, "npc"), click.locn$y),
                  click.locn$x, click.locn$y,
                  gp=gpar(lty="dashed", col="grey"))
    grid.points(click.locn$x, click.locn$y, pch=16, size=unit(1, "mm"))
    clickx <- unittrim(click.locn$x)
    clicky <- unittrim(click.locn$y)
    grid.text(paste("(", clickx, ", ", clicky, ")", sep=""),
              click.locn$x + unit(2, "mm"), click.locn$y,
              just="left")
  }
  do.click("inches")
  pushViewport(viewport(width=0.5, height=0.5,
                         xscale=c(0, 100), yscale=c(0, 10)))
  grid.rect()
  grid.xaxis()
  grid.yaxis()
  do.click("native")
  popViewport()  
}
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.ls}{ List the names of grobs or viewports }{grid.ls}
\aliasA{grobPathListing}{grid.ls}{grobPathListing}
\aliasA{nestedListing}{grid.ls}{nestedListing}
\aliasA{pathListing}{grid.ls}{pathListing}
\keyword{dplot}{grid.ls}
%
\begin{Description}\relax
Returns a listing of the names of grobs or viewports.

This is a generic function with methods for grobs (including
gTrees) and viewports (including vpTrees).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.ls(x=NULL, grobs=TRUE, viewports=FALSE, fullNames=FALSE,
        recursive=TRUE, print=TRUE, flatten=TRUE, ...)

nestedListing(x, gindent="  ", vpindent=gindent) 
pathListing(x, gvpSep=" | ", gAlign=TRUE) 
grobPathListing(x, ...) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A grob or viewport or \code{NULL}.  If \code{NULL}, the current
grid display list is listed.

For print functions, this should be the result of a call to
\code{grid.ls}.
\item[\code{grobs}] A logical value indicating whether to list grobs.
\item[\code{viewports}] A logical value indicating whether to list
viewports.
\item[\code{fullNames}] A logical value indicating whether to embellish
object names with information about the object type.
\item[\code{recursive}] A logical value indicating whether recursive
structures should also list their children.
\item[\code{print}] A logical indicating whether to print the listing
or a function that will print the listing.
\item[\code{flatten}] A logical value indicating whether to flatten
the listing.  Otherwise a more complex hierarchical object is
produced.
\item[\code{gindent}] The indent used to show nesting in the output for
grobs.
\item[\code{vpindent}] The indent used to show nesting in the output for
viewports.
\item[\code{gvpSep}] The string used to separate viewport paths from grob
paths.
\item[\code{gAlign}] Logical indicating whether to align the left hand
edge of all grob paths.
\item[\code{...}] Arguments passed to the \code{print} function.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
If the argument \code{x} is \code{NULL}, the current contents
of the grid display list are listed (both viewports and grobs).
In other words, all objects representing the current scene
are listed.

Otherwise, \code{x} should be a grob or a viewport.

The default behaviour of this function is to print information
about the grobs in the current scene.  It is also possible to
add information about the viewports in the scene.  By default,
the listing is recursive, so all children of gTrees and all
nested viewports are reported.

The format of the information can be controlled via the \code{print}
argument, which can be given a function to perform the formatting.
The \code{nestedListing} function produces a line per grob or
viewport, with indenting used to show nesting.  The \code{pathListing}
function produces a line per grob or viewport, with viewport paths
and grob paths used to show nesting.  The \code{grobPathListing}
is a simple derivation that only shows lines for grobs.  The user
can define new functions.
\end{Details}
%
\begin{Value}
The result of this function is either a \code{"gridFlatListing"}
object (if \code{flatten} is \code{TRUE}) or a \code{"gridListing"}
object.

The former is a simple (flat) list of vectors.  This is convenient,
for example,
for working programmatically with the list of grob and viewport
names, or for writing a new display function for the listing.

The latter is a more complex hierarchical object (list of lists),
but it does contain more detailed information so may be of use for
more advanced customisations.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}}
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# A gTree, called "parent", with childrenvp vpTree (vp2 within vp1)
# and child grob, called "child", with vp vpPath (down to vp2)
sampleGTree <- gTree(name="parent",
                     children=gList(grob(name="child", vp="vp1::vp2")),
                     childrenvp=vpTree(parent=viewport(name="vp1"),
                                       children=vpList(viewport(name="vp2"))))
grid.ls(sampleGTree)
# Show viewports too
grid.ls(sampleGTree, view=TRUE)
# Only show viewports
grid.ls(sampleGTree, view=TRUE, grob=FALSE)
# Alternate displays
# nested listing, custom indent
grid.ls(sampleGTree, view=TRUE, print=nestedListing, gindent="--")
# path listing
grid.ls(sampleGTree, view=TRUE, print=pathListing)
# path listing, without grobs aligned
grid.ls(sampleGTree, view=TRUE, print=pathListing, gAlign=FALSE)
# grob path listing 
grid.ls(sampleGTree, view=TRUE, print=grobPathListing)
# path listing, grobs only
grid.ls(sampleGTree, print=pathListing)
# path listing, viewports only
grid.ls(sampleGTree, view=TRUE, grob=FALSE, print=pathListing)
# raw flat listing
str(grid.ls(sampleGTree, view=TRUE, print=FALSE))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.move.to}{ Move or Draw to a Specified Position }{grid.move.to}
\aliasA{grid.line.to}{grid.move.to}{grid.line.to}
\aliasA{lineToGrob}{grid.move.to}{lineToGrob}
\aliasA{moveToGrob}{grid.move.to}{moveToGrob}
\keyword{dplot}{grid.move.to}
%
\begin{Description}\relax
Grid has the notion of a current location.  These functions
sets that location.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.move.to(x = 0, y = 0, default.units = "npc", name = NULL,
             draw = TRUE, vp = NULL)

moveToGrob(x = 0, y = 0, default.units = "npc", name = NULL, vp = NULL)

grid.line.to(x = 1, y = 1, default.units = "npc",
             arrow = NULL, name = NULL,
             gp = gpar(), draw = TRUE, vp = NULL)

lineToGrob(x = 1, y = 1, default.units = "npc", arrow = NULL,
           name = NULL, gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric value or a unit object specifying an x-value.
\item[\code{y}] A numeric value or a unit object specifying a y-value.
\item[\code{default.units}] A string indicating the default units to use
if \code{x} or \code{y} are only given as numeric values. 
\item[\code{arrow}] A list describing arrow heads to place at either end
of the line, as produced by the \code{arrow} function.
\item[\code{name}]  A character identifier. 
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a move.to/line.to grob (a graphical object describing a
move-to/line-to), but only \code{grid.move.to/line.to()}
draws the move.to/line.to (and then only if \code{draw} is \code{TRUE}).  
\end{Details}
%
\begin{Value}
A move.to/line.to grob.
\code{grid.move.to/line.to()} returns the value invisibly.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{arrow}{arrow}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
grid.move.to(0.5, 0.5)
grid.line.to(1, 1)
grid.line.to(0.5, 0)
pushViewport(viewport(x=0, y=0, w=0.25, h=0.25, just=c("left", "bottom")))
grid.rect()
grid.grill()
grid.line.to(0.5, 0.5)
popViewport()
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.newpage}{Move to a New Page on a Grid Device}{grid.newpage}
\keyword{dplot}{grid.newpage}
%
\begin{Description}\relax
This function erases the current device or moves to a new page.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.newpage(recording = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{recording}] A logical value to indicate whether the new-page
operation should be saved onto the Grid display list.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The new page is painted with the fill colour
(\code{\LinkA{gpar}{gpar}("fill")}), which is often transparent.  For devices
with a \emph{canvas} colour (the on-screen devices \code{X11},
\code{windows} and \code{quartz}), the page is first painted with the
canvas colour and then the background colour.

There are two hooks called \code{"before.grid.newpage"} and
\code{"grid.newpage"} (see \code{\LinkA{setHook}{setHook}}).  The latter
is used in the testing code to annotate the new page.  The hook
function(s) are called with no argument.  (If the value is a character
string, \code{get} is called on it from within the \pkg{grid}
namespace.)
\end{Details}
%
\begin{Value}
None.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid}
\end{SeeAlso}
\HeaderA{grid.null}{ Null Graphical Object }{grid.null}
\aliasA{nullGrob}{grid.null}{nullGrob}
\keyword{dplot}{grid.null}
%
\begin{Description}\relax
These functions create a NULL graphical object,
which has zero width, zero height, and draw nothing.
It can be used as a place-holder or as an invisible
reference point for other drawing.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
nullGrob(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         default.units = "npc",
         name = NULL, vp = NULL)
grid.null(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-location.
\item[\code{y}] A numeric vector or unit object specifying y-location.
\item[\code{default.units}] A string indicating the default units to use
if \code{x}, \code{y}, \code{width}, or \code{height}
are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{vp}] A Grid viewport object (or NULL).
\item[\code{...}] Arguments passed to \code{nullGrob()}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A null grob.  
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
grid.null(name="ref")
grid.rect(height=grobHeight("ref"))
grid.segments(0, 0, grobX("ref", 0), grobY("ref", 0))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.pack}{ Pack an Object within a Frame }{grid.pack}
\aliasA{packGrob}{grid.pack}{packGrob}
\keyword{dplot}{grid.pack}
%
\begin{Description}\relax
This functions, together with \code{grid.frame} and \code{frameGrob}
are part of a
GUI-builder-like interface to constructing graphical images.
The idea is that you create a frame with \code{grid.frame} or
\code{frameGrob} then
use this functions to pack objects into the frame.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.pack(gPath, grob, redraw = TRUE, side = NULL,
          row = NULL, row.before = NULL, row.after = NULL,
          col = NULL, col.before = NULL, col.after = NULL,
          width = NULL, height = NULL,
          force.width = FALSE, force.height = FALSE, border = NULL,
          dynamic = FALSE)

packGrob(frame, grob, side = NULL,
          row = NULL, row.before = NULL, row.after = NULL,
          col = NULL, col.before = NULL, col.after = NULL,
          width = NULL, height = NULL,
          force.width = FALSE, force.height = FALSE, border = NULL,
          dynamic = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{gPath}]  A gPath object, which specifies a frame on the
display list.
\item[\code{frame}]  An object of class \code{frame}, typically the output
from a call to \code{grid.frame}. 
\item[\code{grob}]  An object of class \code{grob}.  The object to be
packed. 
\item[\code{redraw}]  A boolean indicating whether the output should be updated. 
\item[\code{side}]  One of \code{"left"}, \code{"top"}, \code{"right"},
\code{"bottom"} to indicate which side to pack the object on. 
\item[\code{row}]  Which row to add the object to.  Must be between 1 and
the-number-of-rows-currently-in-the-frame + 1, or \code{NULL} in
which case the object occupies all rows. 
\item[\code{row.before}]  Add the object to a new row just before this row. 
\item[\code{row.after}]  Add the object to a new row just after this row. 
\item[\code{col}]  Which col to add the object to.  Must be between 1 and
the-number-of-cols-currently-in-the-frame + 1, or \code{NULL} in
which case the object occupies all cols.  
\item[\code{col.before}] Add the object to a new col just before this col.
\item[\code{col.after}]  Add the object to a new col just after this col. 
\item[\code{width}]  Specifies the width of the column that the object is
added to (rather than allowing the width to be taken from the object). 
\item[\code{height}]  Specifies the height of the row that the object is
added to (rather than allowing the height to be taken from the
object). 
\item[\code{force.width}]  A logical value indicating whether the width of
the column that the grob is being packed into should be EITHER the
width specified in the call to \code{grid.pack} OR the maximum of
that width and the pre-existing width. 
\item[\code{force.height}]  A logical value indicating whether the height of
the column that the grob is being packed into should be EITHER the
height specified in the call to \code{grid.pack} OR the maximum of
that height and the pre-existing height. 
\item[\code{border}]  A \code{unit} object of length 4 indicating the borders
around the object. 
\item[\code{dynamic}]  If the width/height is taken from the grob being
packed, this boolean flag indicates whether the grobwidth/height
unit refers directly to the grob, or uses a gPath to the grob.
In the latter case, changes to the grob will trigger a
recalculation of the width/height.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{packGrob} modifies the given frame grob and returns the modified
frame grob.

\code{grid.pack} destructively modifies a frame grob on the display
list (and redraws the display list if \code{redraw} is \code{TRUE}).

These are (meant to be) very flexible functions.  There are many
different
ways to specify where the new object is to be added relative to the
objects already in the frame.  The function checks that the
specification is not self-contradictory.

NOTE that the width/height of the row/col that the object is added to
is taken from the object itself unless the \code{width}/\code{height}
is specified.
\end{Details}
%
\begin{Value}
\code{packGrob} returns a frame grob, but \code{grid.pack} returns
\code{NULL}.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grid.frame}{grid.frame}},
\code{\LinkA{grid.place}{grid.place}},
\code{\LinkA{grid.edit}{grid.edit}}, and \code{\LinkA{gPath}{gPath}}.
\end{SeeAlso}
\HeaderA{grid.path}{ Draw a Path }{grid.path}
\aliasA{pathGrob}{grid.path}{pathGrob}
\keyword{dplot}{grid.path}
%
\begin{Description}\relax
These functions create and draw a path.
The final point will automatically
be connected to the initial point.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pathGrob(x, y,
         id=NULL, id.lengths=NULL,
         rule="winding",
         default.units="npc",
         name=NULL, gp=gpar(), vp=NULL)
grid.path(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-locations.
\item[\code{y}] A numeric vector or unit object specifying y-locations.
\item[\code{id}] A numeric vector used to separate locations in \code{x} and
\code{y} into sub-paths.  All locations with the same
\code{id} belong to the same sub-path.
\item[\code{id.lengths}] A numeric vector used to separate locations in \code{x} and
\code{y} into sub-paths.  Specifies consecutive blocks of
locations which make up separate sub-paths.
\item[\code{rule}] A character value specifying the fill rule: either
\code{"winding"} or \code{"evenodd"}.
\item[\code{default.units}] A string indicating the default units to use
if \code{x} or \code{y}
are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object (or NULL).
\item[\code{...}] Arguments passed to \code{pathGrob()}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a path grob (a graphical object describing a
path), but only \code{grid.path} draws the path (and then only if
\code{draw} is \code{TRUE}).

A path is like a polygon except that the former can contain holes, as
interpreted by the fill rule; these fill a region if the path border
encircles it an odd or non-zero number of times, respectively.

Not all graphics devices support this function: for example
\code{xfig} and \code{pictex} do not.
\end{Details}
%
\begin{Value}
A grob object.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
pathSample <- function(x, y, rule, gp = gpar()) {
    if (is.na(rule))
        grid.path(x, y, id = rep(1:2, each = 4), gp = gp)
    else 
        grid.path(x, y, id = rep(1:2, each = 4), rule = rule, gp = gp)
    if (!is.na(rule))
        grid.text(paste("Rule:", rule), y = 0, just = "bottom")
}

pathTriplet <- function(x, y, title) {
    pushViewport(viewport(height = 0.9, layout = grid.layout(1, 3),
                          gp = gpar(cex = .7)))
    grid.rect(y = 1, height = unit(1, "char"), just = "top",
              gp = gpar(col = NA, fill = "grey"))
    grid.text(title, y = 1, just = "top")
    pushViewport(viewport(layout.pos.col = 1))
    pathSample(x, y, rule = "winding",
               gp = gpar(fill = "grey"))
    popViewport()
    pushViewport(viewport(layout.pos.col = 2))
    pathSample(x, y, rule = "evenodd",
               gp = gpar(fill = "grey"))
    popViewport()
    pushViewport(viewport(layout.pos.col = 3))
    pathSample(x, y, rule = NA)
    popViewport()
    popViewport()
}

pathTest <- function() {
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(5, 1)))
    pushViewport(viewport(layout.pos.row = 1))
    pathTriplet(c(.1, .1, .9, .9, .2, .2, .8, .8),
                c(.1, .9, .9, .1, .2, .8, .8, .2),
                "Nested rectangles, both clockwise")
    popViewport()
    pushViewport(viewport(layout.pos.row = 2))
    pathTriplet(c(.1, .1, .9, .9, .2, .8, .8, .2),
                c(.1, .9, .9, .1, .2, .2, .8, .8),
                "Nested rectangles, outer clockwise, inner anti-clockwise")
    popViewport()
    pushViewport(viewport(layout.pos.row = 3))
    pathTriplet(c(.1, .1, .4, .4, .6, .9, .9, .6),
                c(.1, .4, .4, .1, .6, .6, .9, .9),
                "Disjoint rectangles")
    popViewport()
    pushViewport(viewport(layout.pos.row = 4))
    pathTriplet(c(.1, .1, .6, .6, .4, .4, .9, .9),
                c(.1, .6, .6, .1, .4, .9, .9, .4),
                "Overlapping rectangles, both clockwise")
    popViewport()
    pushViewport(viewport(layout.pos.row = 5))
    pathTriplet(c(.1, .1, .6, .6, .4, .9, .9, .4),
                c(.1, .6, .6, .1, .4, .4, .9, .9),
                "Overlapping rectangles, one clockwise, other anti-clockwise")
    popViewport()
    popViewport()
}

pathTest()
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.place}{ Place an Object within a Frame }{grid.place}
\aliasA{placeGrob}{grid.place}{placeGrob}
\keyword{dplot}{grid.place}
%
\begin{Description}\relax
These functions provide a simpler (and faster) alternative
to the \code{grid.pack()} and \code{packGrob}
functions.  They can be used to place objects within the existing
rows and columns of a frame layout.  They do not provide the ability to
add new rows and columns nor do they affect the
heights and widths of the rows and columns.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.place(gPath, grob, row = 1, col = 1, redraw = TRUE)
placeGrob(frame, grob, row = NULL, col = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{gPath}]  A gPath object, which specifies a frame on the
display list.
\item[\code{frame}]  An object of class \code{frame}, typically the output
from a call to \code{grid.frame}. 
\item[\code{grob}]  An object of class \code{grob}.  The object to be
placed. 
\item[\code{row}]  Which row to add the object to.  Must be between 1 and
the-number-of-rows-currently-in-the-frame. 
\item[\code{col}]  Which col to add the object to.  Must be between 1 and
the-number-of-cols-currently-in-the-frame.  
\item[\code{redraw}]  A boolean indicating whether the output should be updated. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{placeGrob} modifies the given frame grob and returns the modified
frame grob.

\code{grid.place} destructively modifies a frame grob on the display
list (and redraws the display list if \code{redraw} is \code{TRUE}).

\end{Details}
%
\begin{Value}
\code{placeGrob} returns a frame grob, but \code{grid.place} returns
\code{NULL}.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grid.frame}{grid.frame}},
\code{\LinkA{grid.pack}{grid.pack}},
\code{\LinkA{grid.edit}{grid.edit}}, and \code{\LinkA{gPath}{gPath}}.
\end{SeeAlso}
\HeaderA{grid.plot.and.legend}{ A Simple Plot and Legend Demo }{grid.plot.and.legend}
\keyword{dplot}{grid.plot.and.legend}
%
\begin{Description}\relax
This function is just a wrapper for a simple demonstration of how
a basic plot and legend can be drawn from scratch using grid.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.plot.and.legend()
\end{verbatim}
\end{Usage}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
grid.plot.and.legend()
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.points}{Draw Data Symbols}{grid.points}
\aliasA{pointsGrob}{grid.points}{pointsGrob}
\keyword{dplot}{grid.points}
%
\begin{Description}\relax
These functions create and draw data symbols.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.points(x = stats::runif(10),
            y = stats::runif(10),
            pch = 1, size = unit(1, "char"),
            default.units = "native", name = NULL,
            gp = gpar(), draw = TRUE, vp = NULL)
pointsGrob(x = stats::runif(10),
           y = stats::runif(10),
           pch = 1, size = unit(1, "char"),
           default.units = "native", name = NULL,
           gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-values.
\item[\code{y}] A numeric vector or unit object specifying y-values.
\item[\code{pch}] A numeric or character vector indicating what sort of
plotting symbol to use.  See \code{\LinkA{points}{points}} for the
interpretation of these values.
\item[\code{size}] A unit object specifying the size of the plotting symbols.
\item[\code{default.units}] A string indicating the default units to use
if \code{x} or \code{y} are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a points grob (a graphical object describing
points), but only \code{grid.points} draws the points (and then only
if \code{draw} is \code{TRUE}).
\end{Details}
%
\begin{Value}
A points grob.  \code{grid.points} returns the value invisibly.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
\HeaderA{grid.polygon}{ Draw a Polygon }{grid.polygon}
\aliasA{polygonGrob}{grid.polygon}{polygonGrob}
\keyword{dplot}{grid.polygon}
%
\begin{Description}\relax
These functions create and draw a polygon.
The final point will automatically
be connected to the initial point.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.polygon(x=c(0, 0.5, 1, 0.5), y=c(0.5, 1, 0.5, 0),
             id=NULL, id.lengths=NULL,
             default.units="npc", name=NULL,
             gp=gpar(), draw=TRUE, vp=NULL)
polygonGrob(x=c(0, 0.5, 1, 0.5), y=c(0.5, 1, 0.5, 0),
             id=NULL, id.lengths=NULL,
             default.units="npc", name=NULL,
             gp=gpar(), vp=NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-locations.
\item[\code{y}] A numeric vector or unit object specifying y-locations.
\item[\code{id}] A numeric vector used to separate locations in \code{x} and
\code{y} into multiple polygons.  All locations with the same
\code{id} belong to the same polygon.
\item[\code{id.lengths}] A numeric vector used to separate locations in \code{x} and
\code{y} into multiple polygons.  Specifies consecutive blocks of
locations which make up separate polygons.
\item[\code{default.units}] A string indicating the default units to use
if \code{x}, \code{y}, \code{width}, or \code{height}
are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a polygon grob (a graphical object describing a
polygon), but only \code{grid.polygon}
draws the polygon (and then only if \code{draw} is \code{TRUE}).  
\end{Details}
%
\begin{Value}
A grob object.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.polygon()
# Using id (NOTE: locations are not in consecutive blocks)
grid.newpage()
grid.polygon(x=c((0:4)/10, rep(.5, 5), (10:6)/10, rep(.5, 5)),
             y=c(rep(.5, 5), (10:6/10), rep(.5, 5), (0:4)/10),
             id=rep(1:5, 4),
             gp=gpar(fill=1:5))
# Using id.lengths
grid.newpage()
grid.polygon(x=outer(c(0, .5, 1, .5), 5:1/5),
             y=outer(c(.5, 1, .5, 0), 5:1/5),
             id.lengths=rep(4, 5),
             gp=gpar(fill=1:5))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.pretty}{ Generate a Sensible Set of Breakpoints }{grid.pretty}
\keyword{dplot}{grid.pretty}
%
\begin{Description}\relax
Produces a pretty set of breakpoints within the range given.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.pretty(range)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{range}]  A numeric vector 
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A numeric vector of breakpoints.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
\HeaderA{grid.prompt}{ Prompt before New Page }{grid.prompt}
\keyword{dplot}{grid.prompt}
%
\begin{Description}\relax
This function can be used to control whether the user
is prompted before starting a new page of output.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.prompt(ask)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ask}]  a logical value.  If \code{TRUE}, the user
is prompted before a new page of output is started. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Yhis is deprecated in favour of \code{\LinkA{devAskNewPage}{devAskNewPage}} as a
single setting inside the device affects both the base and grid
graphics systems.

The default value when a device is opened is taken from the
setting of \code{\LinkA{options}{options}("device.ask.default")}.
\end{Details}
%
\begin{Value}
The current prompt setting \emph{before} any new setting is applied.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{grid.newpage}{grid.newpage}} 
\end{SeeAlso}
\HeaderA{grid.raster}{Render a raster object}{grid.raster}
\aliasA{rasterGrob}{grid.raster}{rasterGrob}
\keyword{dplot}{grid.raster}
%
\begin{Description}\relax
Render a raster object (bitmap image) at the given location, size,
and orientation.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.raster(image,
            x = unit(0.5, "npc"), y = unit(0.5, "npc"),
            width = NULL, height = NULL,
            just = "centre", hjust = NULL, vjust = NULL,
            interpolate = TRUE, default.units = "npc",
            name = NULL, gp = gpar(), vp = NULL)

rasterGrob(image,
           x = unit(0.5, "npc"), y = unit(0.5, "npc"),
           width = NULL, height = NULL,
           just = "centre", hjust = NULL, vjust = NULL,
           interpolate = TRUE, default.units = "npc",
           name = NULL, gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{image}] 
Any R object that can be coerced to a raster object.

\item[\code{x}] A numeric vector or unit object specifying x-location.
\item[\code{y}] A numeric vector or unit object specifying y-location.
\item[\code{width}] A numeric vector or unit object specifying width.
\item[\code{height}] A numeric vector or unit object specifying height.
\item[\code{just}] The justification of the rectangle 
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: \code{"left"},
\code{"right"}, \code{"centre"}, \code{"center"}, \code{"bottom"},
and \code{"top"}.  For numeric values, 0 means left alignment
and 1 means right alignment.

\item[\code{hjust}] A numeric vector specifying horizontal justification.
If specified, overrides the \code{just} setting.
\item[\code{vjust}] A numeric vector specifying vertical justification.
If specified, overrides the \code{just} setting.
\item[\code{default.units}] A string indicating the default units to use
if \code{x}, \code{y}, \code{width}, or \code{height}
are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object (or NULL).
\item[\code{interpolate}] 
A logical value indicating whether to linearly interpolate the
image (the alternative is to use nearest-neighbour interpolation,
which gives a more blocky result).

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Neither \code{width} nor \code{height} needs to be specified,
in which case, the aspect ratio of the image is preserved.  If
both \code{width} and \code{height} are specified, it is likely
that the image will be distorted.

Not all graphics devices are capable of rendering raster images
and some may not be able to produce rotated images (i.e., if
a raster object is rendered within a rotated viewport).

All graphical parameter settings in \code{gp} will be ignored,
including \code{alpha}.
\end{Details}
%
\begin{Value}
A rastergrob grob.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{as.raster}{as.raster}}.

\code{\LinkA{dev.capabilities}{dev.capabilities}} to see if it is supported.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
redGradient <- matrix(hcl(0, 80, seq(50, 80, 10)),
                      nrow=4, ncol=5)
# interpolated 
grid.newpage()
grid.raster(redGradient)
# blocky
grid.newpage()
grid.raster(redGradient, interpolate=FALSE)
# blocky and stretched
grid.newpage()
grid.raster(redGradient, interpolate=FALSE, height=unit(1, "npc"))

# The same raster drawn several times
grid.newpage()
grid.raster(0, x=1:3/4, y=1:3/4, w=.1, interp=FALSE)
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.record}{ Encapsulate calculations and drawing }{grid.record}
\aliasA{recordGrob}{grid.record}{recordGrob}
\keyword{dplot}{grid.record}
%
\begin{Description}\relax
Evaluates an expression that includes both calculations
and drawing that depends on the calculations so that
both the calculations and the drawing will be rerun when
the scene is redrawn (e.g., device resize or editing).

Intended \emph{only} for expert use.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
recordGrob(expr, list, name=NULL, gp=NULL, vp=NULL)
grid.record(expr, list, name=NULL, gp=NULL, vp=NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{expr}] object of mode \code{\LinkA{expression}{expression}} or \code{call} or
an unevaluated expression.
\item[\code{list}] a list defining the environment in which \code{expr} is to
be evaluated.
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
A grob is created of special class \code{"recordedGrob"}
(and drawn, in the case of \code{grid.record}).
The \code{drawDetails} method for this class
evaluates the expression with the list as the evaluation
environment (and the grid Namespace as the parent of that
environment).
\end{Details}
%
\begin{Note}\relax
 This function \emph{must} be used instead of the
function \code{recordGraphics};  all of the dire warnings
about using \code{recordGraphics} responsibly also apply here.
\end{Note}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{recordGraphics}{recordGraphics}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.record({
              w <- convertWidth(unit(1, "inches"), "npc")
              grid.rect(width=w)
            },
            list())
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.rect}{Draw rectangles }{grid.rect}
\aliasA{rectGrob}{grid.rect}{rectGrob}
\keyword{dplot}{grid.rect}
%
\begin{Description}\relax
These functions create and draw rectangles.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.rect(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
          width = unit(1, "npc"), height = unit(1, "npc"),
          just = "centre", hjust = NULL, vjust = NULL,
          default.units = "npc", name = NULL,
          gp=gpar(), draw = TRUE, vp = NULL)
rectGrob(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         width = unit(1, "npc"), height = unit(1, "npc"),
         just = "centre", hjust = NULL, vjust = NULL, 
         default.units = "npc", name = NULL,
         gp=gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-location.
\item[\code{y}] A numeric vector or unit object specifying y-location.
\item[\code{width}] A numeric vector or unit object specifying width.
\item[\code{height}] A numeric vector or unit object specifying height.
\item[\code{just}] The justification of the rectangle 
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: \code{"left"},
\code{"right"}, \code{"centre"}, \code{"center"}, \code{"bottom"},
and \code{"top"}.  For numeric values, 0 means left alignment
and 1 means right alignment.

\item[\code{hjust}] A numeric vector specifying horizontal justification.
If specified, overrides the \code{just} setting.
\item[\code{vjust}] A numeric vector specifying vertical justification.
If specified, overrides the \code{just} setting.
\item[\code{default.units}] A string indicating the default units to use
if \code{x}, \code{y}, \code{width}, or \code{height}
are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a rect grob (a graphical object describing
rectangles), but only \code{grid.rect}
draws the rectangles (and then only if \code{draw} is \code{TRUE}).

\end{Details}
%
\begin{Value}
A rect grob.  \code{grid.rect} returns the value invisibly.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
\HeaderA{grid.refresh}{ Refresh the current grid scene }{grid.refresh}
\keyword{dplot}{grid.refresh}
%
\begin{Description}\relax
Replays the current grid display list.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.refresh()
\end{verbatim}
\end{Usage}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
\HeaderA{grid.remove}{Remove a Grid Graphical Object}{grid.remove}
\aliasA{grid.gremove}{grid.remove}{grid.gremove}
\aliasA{removeGrob}{grid.remove}{removeGrob}
\keyword{dplot}{grid.remove}
%
\begin{Description}\relax
Remove a grob from a gTree or a descendant of a gTree.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.remove(gPath, warn = TRUE, strict  =  FALSE, grep = FALSE,
            global = FALSE, allDevices = FALSE, redraw = TRUE)

grid.gremove(..., grep = TRUE, global = TRUE)

removeGrob(gTree, gPath, strict = FALSE, grep = FALSE,
           global = FALSE, warn = TRUE) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{gTree}] A gTree object.
\item[\code{gPath}]  A gPath object. For \code{grid.remove} this
specifies a gTree on the display list.  For \code{removeGrob} this
specifies a descendant of the specified gTree. 
\item[\code{strict}]  A boolean indicating whether the gPath must be
matched exactly. 
\item[\code{grep}] A boolean indicating whether the \code{gPath} should
be treated as a regular expression.  Values are recycled across
elements of the \code{gPath} (e.g., \code{c(TRUE, FALSE)} means
that every odd element of the \code{gPath} will be treated as
a regular expression).

\item[\code{global}]  A boolean indicating whether the function should affect
just the first match of the \code{gPath}, or whether all matches
should be affected.

\item[\code{allDevices}]  A boolean indicating whether all open devices
should
be searched for matches, or just the current device.
NOT YET IMPLEMENTED.

\item[\code{warn}] A logical to indicate whether failing to find the
specified grob should trigger an error.  
\item[\code{redraw}] A logical value to indicate whether to redraw the grob. 
\item[\code{...}]  Arguments that are passed to \code{grid.get}. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{removeGrob} copies the specified grob and returns a modified
grob.

\code{grid.remove} destructively modifies a grob on the display list.
If \code{redraw}
is \code{TRUE} it then redraws everything to reflect the change.

\code{grid.gremove} (\code{g} for global) is just a convenience wrapper for
\code{grid.remove} with different defaults.
\end{Details}
%
\begin{Value}
\code{removeGrob} returns a grob object;  \code{grid.remove} returns
\code{NULL}.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}}, \code{\LinkA{getGrob}{getGrob}},
\code{\LinkA{removeGrob}{removeGrob}}, \code{\LinkA{removeGrob}{removeGrob}}.
\end{SeeAlso}
\HeaderA{grid.segments}{ Draw Line Segments }{grid.segments}
\aliasA{segmentsGrob}{grid.segments}{segmentsGrob}
\keyword{dplot}{grid.segments}
%
\begin{Description}\relax
These functions create and draw line segments.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.segments(x0 = unit(0, "npc"), y0 = unit(0, "npc"),
              x1 = unit(1, "npc"), y1 = unit(1, "npc"),
              default.units = "npc", 
              arrow = NULL,
              name = NULL, gp = gpar(), draw = TRUE, vp = NULL)
segmentsGrob(x0 = unit(0, "npc"), y0 = unit(0, "npc"),
              x1 = unit(1, "npc"), y1 = unit(1, "npc"),
              default.units = "npc", 
              arrow = NULL, name = NULL, gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x0}]  Numeric indicating the starting x-values of the line segments. 
\item[\code{y0}]  Numeric indicating the starting y-values of the line
segments. 
\item[\code{x1}]  Numeric indicating the stopping x-values of the line
segments. 
\item[\code{y1}]  Numeric indicating the stopping y-values of the line segments.
\item[\code{default.units}]  A string. 
\item[\code{arrow}] A list describing arrow heads to place at either end
of the line segments, as produced by the \code{arrow} function.
\item[\code{name}]  A character identifier. 
\item[\code{gp}]  An object of class \code{gpar}. 
\item[\code{draw}]  A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a segments grob (a graphical object describing
segments), but only \code{grid.segments}
draws the segments (and then only if \code{draw} is \code{TRUE}).

\end{Details}
%
\begin{Value}
A segments grob.  \code{grid.segments} returns the value invisibly.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{arrow}{arrow}}
\end{SeeAlso}
\HeaderA{grid.set}{Set a Grid Graphical Object}{grid.set}
\aliasA{setGrob}{grid.set}{setGrob}
\keyword{dplot}{grid.set}
%
\begin{Description}\relax
Replace a grob or a descendant of a grob.

\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.set(gPath, newGrob, strict = FALSE, grep = FALSE,
         redraw = TRUE)
 
setGrob(gTree, gPath, newGrob, strict = FALSE, grep = FALSE) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{gTree}] A gTree object.
\item[\code{gPath}]  A gPath object. For \code{grid.set} this
specifies a grob on the display list.  For \code{setGrob} this
specifies a descendant of the specified gTree. 
\item[\code{newGrob}]  A grob object. 
\item[\code{strict}]  A boolean indicating whether the gPath must be
matched exactly. 
\item[\code{grep}] A boolean indicating whether the \code{gPath} should
be treated as a regular expression.  Values are recycled across
elements of the \code{gPath} (e.g., \code{c(TRUE, FALSE)} means
that every odd element of the \code{gPath} will be treated as
a regular expression).

\item[\code{redraw}] A logical value to indicate whether to redraw the grob. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
\code{setGrob} copies the specified grob and returns a modified
grob.

\code{grid.set} destructively replaces a grob on the display list.
If \code{redraw}
is \code{TRUE} it then redraws everything to reflect the change.

These functions should not normally be called by the user.
\end{Details}
%
\begin{Value}
\code{setGrob} returns a grob object;  \code{grid.set} returns \code{NULL}.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grid.grob}{grid.grob}}.
\end{SeeAlso}
\HeaderA{grid.show.layout}{Draw a Diagram of a Grid Layout}{grid.show.layout}
\keyword{dplot}{grid.show.layout}
%
\begin{Description}\relax
This function uses Grid graphics to draw a diagram of a
Grid layout.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.show.layout(l, newpage=TRUE, bg = "light grey",
             cell.border = "blue", cell.fill = "light blue",
             cell.label = TRUE, label.col = "blue",
             unit.col = "red", vp = NULL) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{l}] A Grid layout object.
\item[\code{newpage}] A logical value indicating whether to move on
to a new page before drawing the diagram.
\item[\code{bg}] The colour used for the background.
\item[\code{cell.border}] The colour used to draw the borders of the cells
in the layout.
\item[\code{cell.fill}] The colour used to fill the cells in the layout.
\item[\code{cell.label}] A logical indicating whether the layout cells
should be labelled.
\item[\code{label.col}] The colour used for layout cell labels.
\item[\code{unit.col}] The colour used for labelling the widths/heights of
columns/rows.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
A viewport is created within \code{vp} to provide a margin for
annotation, and the layout is drawn within that new viewport.
The margin is filled with light grey, the new viewport is filled
with white and framed with a black border, and the layout regions
are filled with light blue and framed with a blue border.
The diagram is annotated with the widths and heights (including units)
of the columns and rows of the layout using red text. (All colours
are defaults and may be customised via function arguments.)
\end{Details}
%
\begin{Value}
None.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{grid.layout}{grid.layout}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Diagram of a simple layout 
grid.show.layout(grid.layout(4,2,
                     heights=unit(rep(1, 4),
                                  c("lines", "lines", "lines", "null")),
                     widths=unit(c(1, 1), "inches")))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.show.viewport}{Draw a Diagram of a Grid Viewport}{grid.show.viewport}
\keyword{dplot}{grid.show.viewport}
%
\begin{Description}\relax
This function uses Grid graphics to draw a diagram of
a Grid viewport.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.show.viewport(v, parent.layout = NULL, newpage = TRUE,
                   border.fill="light grey",
                   vp.col="blue", vp.fill="light blue",
                   scale.col="red",
                   vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{v}] A Grid viewport object.
\item[\code{parent.layout}] A grid layout object.  If this is not NULL and
the viewport given in \code{v} has its location specified relative
to the layout, then the diagram shows the layout and which cells
\code{v} occupies within the layout.
\item[\code{newpage}] A logical value to indicate whether to move to
a new page before drawing the diagram.
\item[\code{border.fill}] Colour to fill the border margin.
\item[\code{vp.col}] Colour for the border of the viewport region.
\item[\code{vp.fill}] Colour to fill the viewport region.
\item[\code{scale.col}] Colour to draw the viewport axes.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
A viewport is created within \code{vp} to provide a margin for
annotation, and the diagram is drawn within that new viewport.
By default, the margin is filled with light grey, the new viewport is filled
with white and framed with a black border, and the viewport region
is filled with light blue and framed with a blue border.
The diagram is annotated with the width and height (including units)
of the viewport, the (x, y) location of the viewport, and
the x- and y-scales of the viewport, using red lines and text.
\end{Details}
%
\begin{Value}
None.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Diagram of a sample viewport
grid.show.viewport(viewport(x=0.6, y=0.6,
                            w=unit(1, "inches"), h=unit(1, "inches")))
grid.show.viewport(viewport(layout.pos.row=2, layout.pos.col=2:3),
                   grid.layout(3, 4))
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.text}{Draw Text}{grid.text}
\aliasA{textGrob}{grid.text}{textGrob}
\keyword{dplot}{grid.text}
%
\begin{Description}\relax
These functions create and draw text and \LinkA{plotmath}{plotmath} expressions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.text(label, x = unit(0.5, "npc"), y = unit(0.5, "npc"), 
          just = "centre", hjust = NULL, vjust = NULL, rot = 0,
          check.overlap = FALSE, default.units = "npc",
          name = NULL, gp = gpar(), draw = TRUE, vp = NULL)

textGrob(label, x = unit(0.5, "npc"), y = unit(0.5, "npc"), 
          just = "centre", hjust = NULL, vjust = NULL, rot = 0,
          check.overlap = FALSE, default.units = "npc",
          name = NULL, gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{label}] A character or \LinkA{expression}{expression} vector.  Other
objects are coerced by \code{\LinkA{as.graphicsAnnot}{as.graphicsAnnot}}.
\item[\code{x}] A numeric vector or unit object specifying x-values.
\item[\code{y}] A numeric vector or unit object specifying y-values.
\item[\code{just}] The justification of the text 
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: \code{"left"},
\code{"right"}, \code{"centre"}, \code{"center"}, \code{"bottom"},
and \code{"top"}.  For numeric values, 0 means left alignment
and 1 means right alignment.

\item[\code{hjust}] A numeric vector specifying horizontal justification.
If specified, overrides the \code{just} setting.
\item[\code{vjust}] A numeric vector specifying vertical justification.
If specified, overrides the \code{just} setting.
\item[\code{rot}] The angle to rotate the text.
\item[\code{check.overlap}] A logical value to indicate whether to
check for and omit overlapping text.
\item[\code{default.units}] A string indicating the default units to use
if \code{x} or \code{y}
are only given as numeric vectors. 
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or NULL).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a text grob (a graphical object describing
text), but only \code{grid.text}
draws the text (and then only if \code{draw} is \code{TRUE}).

If the \code{label} argument is an expression, the output is
formatted as a mathematical annotation, as for base graphics text.

\end{Details}
%
\begin{Value}
A text grob.  \code{grid.text} returns the value invisibly.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
x <- stats::runif(20)
y <- stats::runif(20)
rot <- stats::runif(20, 0, 360)
grid.text("SOMETHING NICE AND BIG", x=x, y=y, rot=rot,
          gp=gpar(fontsize=20, col="grey"))
grid.text("SOMETHING NICE AND BIG", x=x, y=y, rot=rot,
          gp=gpar(fontsize=20), check=TRUE)
grid.newpage()
draw.text <- function(just, i, j) {
  grid.text("ABCD", x=x[j], y=y[i], just=just)
  grid.text(deparse(substitute(just)), x=x[j], y=y[i] + unit(2, "lines"),
            gp=gpar(col="grey", fontsize=8))
}
x <- unit(1:4/5, "npc")
y <- unit(1:4/5, "npc")
grid.grill(h=y, v=x, gp=gpar(col="grey"))
draw.text(c("bottom"), 1, 1)
draw.text(c("left", "bottom"), 2, 1)
draw.text(c("right", "bottom"), 3, 1)
draw.text(c("centre", "bottom"), 4, 1)
draw.text(c("centre"), 1, 2)
draw.text(c("left", "centre"), 2, 2)
draw.text(c("right", "centre"), 3, 2)
draw.text(c("centre", "centre"), 4, 2)
draw.text(c("top"), 1, 3)
draw.text(c("left", "top"), 2, 3)
draw.text(c("right", "top"), 3, 3)
draw.text(c("centre", "top"), 4, 3)
draw.text(c(), 1, 4)
draw.text(c("left"), 2, 4)
draw.text(c("right"), 3, 4)
draw.text(c("centre"), 4, 4)
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.xaxis}{Draw an X-Axis}{grid.xaxis}
\aliasA{xaxisGrob}{grid.xaxis}{xaxisGrob}
\keyword{dplot}{grid.xaxis}
%
\begin{Description}\relax
These functions create and draw an x-axis.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.xaxis(at = NULL, label = TRUE, main = TRUE,
           edits = NULL, name = NULL,
           gp = gpar(), draw = TRUE, vp = NULL)

xaxisGrob(at = NULL, label = TRUE, main = TRUE,
          edits = NULL, name = NULL,
          gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{at}] A numeric vector of x-value locations for the tick marks.
\item[\code{label}] A logical value indicating whether to draw the labels
on the tick marks, or an expression or character vector which
specify the labels to use.  If not logical, must be the same
length as the \code{at} argument.
\item[\code{main}] A logical value indicating whether to draw the axis
at the bottom (\code{TRUE}) or at the top (\code{FALSE}) of the
viewport.
\item[\code{edits}] A gEdit or gEditList containing edit operations
to apply (to the children of the axis)
when the axis is first created and during redrawing
whenever \code{at} is \code{NULL}.

\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport obect (or \code{NULL}).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create an xaxis grob (a graphical object describing an
xaxis), but only \code{grid.xaxis}
draws the xaxis (and then only if \code{draw} is \code{TRUE}).
\end{Details}
%
\begin{Value}
An xaxis grob.  \code{grid.xaxis} returns the value invisibly.
\end{Value}
%
\begin{Section}{Children}
If the \code{at} slot of an xaxis grob is not \code{NULL} then
the xaxis will have the following children:
\begin{description}

\item[major]  representing the line at the base of the
tick marks.
\item[ticks] representing the tick marks.
\item[labels] representing the tick labels.

\end{description}


If the \code{at} slot is \code{NULL} then there are no children
and ticks are drawn based on the current viewport scale.
\end{Section}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{grid.yaxis}{grid.yaxis}}
\end{SeeAlso}
\HeaderA{grid.xspline}{ Draw an Xspline }{grid.xspline}
\aliasA{xsplineGrob}{grid.xspline}{xsplineGrob}
\keyword{dplot}{grid.xspline}
%
\begin{Description}\relax
These functions create and draw an xspline, a curve drawn
relative to control points.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.xspline(...)
xsplineGrob(x = c(0, 0.5, 1, 0.5), y = c(0.5, 1, 0.5, 0),
            id = NULL, id.lengths = NULL,
            default.units = "npc",
            shape = 0, open = TRUE, arrow = NULL, repEnds = TRUE,
            name = NULL, gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector or unit object specifying x-locations of
spline control points.
\item[\code{y}] A numeric vector or unit object specifying y-locations of
spline control points.
\item[\code{id}] A numeric vector used to separate locations in \code{x} and
\code{y} into multiple xsplines.  All locations with the same
\code{id} belong to the same xspline.
\item[\code{id.lengths}] A numeric vector used to separate locations in \code{x} and
\code{y} into multiple xspline.  Specifies consecutive blocks of
locations which make up separate xsplines.
\item[\code{default.units}] A string indicating the default units to use
if \code{x} or \code{y}
are only given as numeric vectors. 
\item[\code{shape}] A numeric vector of values between -1 and 1, which
control the shape of the spline relative to the control points.
\item[\code{open}] A logical value indicating whether the spline is 
a line or a closed shape.
\item[\code{arrow}] A list describing arrow heads to place at either end
of the xspline, as produced by the \code{arrow} function.
\item[\code{repEnds}] A logical value indicating whether the first and
last control points should be replicated for drawing the curve
(see Details below).
\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{vp}] A Grid viewport object (or NULL).
\item[\code{...}] Arguments to be passed to \code{xsplineGrob}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create an xspline grob (a graphical object describing an
xspline), but only \code{grid.xspline}
draws the xspline.

An xspline is a line drawn relative to control points.  For each
control point, the line
may pass through (interpolate) the control point or it
may only approach (approximate) the control
point;  the behaviour is determined by a shape parameter for each
control point.

If the shape parameter is greater than zero, the spline
approximates the control points (and is
very similar to a cubic B-spline when the shape is
1).  If the shape parameter is less than zero, the spline interpolates
the control points (and is very similar to a Catmull-Rom spline when
the shape is -1).  If the shape parameter is 0, the spline forms a
sharp corner at that control point.

For open xsplines, the start and end control points must have a shape
of 0 (and non-zero values are silently converted to zero without warning).

For open xsplines, by default the start and end control points are
actually replicated before the curve is drawn.  A curve is drawn
between (interpolating or approximating)
the second and third of each set of four control points, so
this default behaviour ensures that
the resulting curve starts at the first control point you have
specified and ends at the last control point.  
The default
behaviour can be turned off via the \code{repEnds} argument,
in which case the curve that is drawn starts (approximately) at
the second control point and ends (approximately) at the first and
second-to-last control point.

The \code{repEnds} argument is ignored for closed xsplines.

Missing values are not allowed for \code{x} and \code{y}
(i.e., it is not valid for a control point to be missing).

For closed xsplines, a curve is automatically drawn 
between the final control point and the initial control point.
\end{Details}
%
\begin{Value}
A grob object.
\end{Value}
%
\begin{References}\relax
Blanc, C. and Schlick, C. (1995),
"X-splines : A Spline Model Designed for the End User",
in \emph{Proceedings of SIGGRAPH 95}, pp. 377--386. 
\url{http://dept-info.labri.fr/~schlick/DOC/sig1.html}
\end{References}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{arrow}{arrow}}.

\code{\LinkA{xspline}{xspline}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
x <- c(0.25, 0.25, 0.75, 0.75)
y <- c(0.25, 0.75, 0.75, 0.25)

xsplineTest <- function(s, i, j, open) {
  pushViewport(viewport(layout.pos.col=j, layout.pos.row=i))
  grid.points(x, y, default.units="npc", pch=16, size=unit(2, "mm"))
  grid.xspline(x, y, shape=s, open=open, gp=gpar(fill="grey"))
  grid.text(s, gp=gpar(col="grey"),
            x=unit(x, "npc") + unit(c(-1, -1, 1, 1), "mm"),
            y=unit(y, "npc") + unit(c(-1, 1, 1, -1), "mm"),
            hjust=c(1, 1, 0, 0),
            vjust=c(1, 0, 0, 1))
  popViewport()
}

pushViewport(viewport(width=.5, x=0, just="left",
                      layout=grid.layout(3, 3, respect=TRUE)))
pushViewport(viewport(layout.pos.row=1))
grid.text("Open Splines", y=1, just="bottom")
popViewport()
xsplineTest(c(0, -1, -1, 0), 1, 1, TRUE)
xsplineTest(c(0, -1,  0, 0), 1, 2, TRUE)
xsplineTest(c(0, -1,  1, 0), 1, 3, TRUE)
xsplineTest(c(0,  0, -1, 0), 2, 1, TRUE)
xsplineTest(c(0,  0,  0, 0), 2, 2, TRUE)
xsplineTest(c(0,  0,  1, 0), 2, 3, TRUE)
xsplineTest(c(0,  1, -1, 0), 3, 1, TRUE)
xsplineTest(c(0,  1,  0, 0), 3, 2, TRUE)
xsplineTest(c(0,  1,  1, 0), 3, 3, TRUE)
popViewport()
pushViewport(viewport(width=.5, x=1, just="right",
                      layout=grid.layout(3, 3, respect=TRUE)))
pushViewport(viewport(layout.pos.row=1))
grid.text("Closed Splines", y=1, just="bottom")
popViewport()
xsplineTest(c(-1, -1, -1, -1), 1, 1, FALSE)
xsplineTest(c(-1, -1,  0, -1), 1, 2, FALSE)
xsplineTest(c(-1, -1,  1, -1), 1, 3, FALSE)
xsplineTest(c( 0,  0, -1,  0), 2, 1, FALSE)
xsplineTest(c( 0,  0,  0,  0), 2, 2, FALSE)
xsplineTest(c( 0,  0,  1,  0), 2, 3, FALSE)
xsplineTest(c( 1,  1, -1,  1), 3, 1, FALSE)
xsplineTest(c( 1,  1,  0,  1), 3, 2, FALSE)
xsplineTest(c( 1,  1,  1,  1), 3, 3, FALSE)
popViewport()
\end{ExampleCode}
\end{Examples}
\HeaderA{grid.yaxis}{Draw a Y-Axis}{grid.yaxis}
\aliasA{yaxisGrob}{grid.yaxis}{yaxisGrob}
\keyword{dplot}{grid.yaxis}
%
\begin{Description}\relax
These functions create and draw a y-axis.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grid.yaxis(at = NULL, label = TRUE, main = TRUE,
           edits = NULL, name = NULL,
           gp = gpar(), draw = TRUE, vp = NULL)

yaxisGrob(at = NULL, label = TRUE, main = TRUE,
          edits = NULL, name = NULL,
          gp = gpar(), vp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{at}] A numeric vector of y-value locations for the tick marks.
\item[\code{label}] A logical value indicating whether to draw the labels
on the tick marks, or an expression or character vector which
specify the labels to use.  If not logical, must be the same
length as the \code{at} argument.
\item[\code{main}] A logical value indicating whether to draw the axis
at the left (\code{TRUE}) or at the right (\code{FALSE}) of the
viewport.
\item[\code{edits}] A gEdit or gEditList containing edit operations
to apply (to the children of the axis)
when the axis is first created and during redrawing
whenever \code{at} is \code{NULL}.

\item[\code{name}]  A character identifier. 
\item[\code{gp}] An object of class \code{gpar}, typically the output
from a call to the function \code{gpar}.  This is basically
a list of graphical parameter settings.
\item[\code{draw}] A logical value indicating whether graphics output
should be produced.
\item[\code{vp}] A Grid viewport object (or \code{NULL}).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Both functions create a yaxis grob (a graphical object describing a
yaxis), but only \code{grid.yaxis}
draws the yaxis (and then only if \code{draw} is \code{TRUE}).

\end{Details}
%
\begin{Value}
A yaxis grob.  \code{grid.yaxis} returns the value invisibly.
\end{Value}
%
\begin{Section}{Children}
If the \code{at} slot of an xaxis grob is not \code{NULL} then
the xaxis will have the following children:
\begin{description}

\item[major]  representing the line at the base of the
tick marks.
\item[ticks] representing the tick marks.
\item[labels] representing the tick labels.

\end{description}


If the \code{at} slot is \code{NULL} then there are no children
and ticks are drawn based on the current viewport scale.
\end{Section}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\LinkA{Grid}{Grid},
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{grid.xaxis}{grid.xaxis}}
\end{SeeAlso}
\HeaderA{grobName}{Generate a Name for a Grob}{grobName}
\keyword{dplot}{grobName}
%
\begin{Description}\relax
This function generates a unique (within-session) name for
a grob, based on the grob's class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grobName(grob = NULL, prefix = "GRID")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{grob}] A grob object or \code{NULL}.
\item[\code{prefix}] The prefix part of the name.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A character string of the form \code{prefix.class(grob).index}
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
\HeaderA{grobWidth}{Create a Unit Describing the Width of a Grob}{grobWidth}
\aliasA{grobAscent}{grobWidth}{grobAscent}
\aliasA{grobDescent}{grobWidth}{grobDescent}
\aliasA{grobHeight}{grobWidth}{grobHeight}
\keyword{dplot}{grobWidth}
%
\begin{Description}\relax
These functions create a unit object describing the width or height of
a grob.  They are generic.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grobWidth(x)
grobHeight(x)
grobAscent(x)
grobDescent(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A grob object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A unit object. 
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{unit}{unit}} and
\code{\LinkA{stringWidth}{stringWidth}}
\end{SeeAlso}
\HeaderA{grobX}{Create a Unit Describing a Grob Boundary Location}{grobX}
\aliasA{grobY}{grobX}{grobY}
\keyword{dplot}{grobX}
%
\begin{Description}\relax
These functions create a unit object describing a location somewhere
on the boundary of
a grob.  They are generic.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
grobX(x, theta)
grobY(x, theta)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A grob, or gList, or gTree, or gPath.
\item[\code{theta}] An angle indicating where the location is
on the grob boundary.  Can be one of \code{"east"},
\code{"north"}, \code{"west"}, or \code{"south"},
which correspond to angles 0, 90, 180, and 270,
respectively.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The angle is anti-clockwise with zero corresponding to a line
with an origin centred between the extreme
points of the shape, and pointing at 3 o'clock.

If the grob describes a single shape, the boundary value should
correspond to the exact edge of the shape.

If the grob describes multiple shapes, the boundary
value will either correspond to the edge of a bounding box around all of
the shapes described by the grob (for multiple rectangles, circles,
xsplines, or text), or to a 
convex hull around all vertices of all shapes described by the grob
(for multiple polygons, points, lines, polylines, 
and segments).

Points grobs are currently a special case because the convex hull
is based on the data symbol \emph{locations} and does not take
into account the extent of the data symbols themselves.

The extents of any arrow heads are currently \emph{not} taken into account.
\end{Details}
%
\begin{Value}
A unit object. 
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{unit}{unit}} and
\code{\LinkA{grobWidth}{grobWidth}}
\end{SeeAlso}
\HeaderA{plotViewport}{ Create a Viewport with a Standard Plot Layout }{plotViewport}
\keyword{dplot}{plotViewport}
%
\begin{Description}\relax
This is a convenience function for producing a viewport with
the common S-style plot layout -- i.e., a central
plot region surrounded by margins given in terms of a
number of lines of text.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plotViewport(margins=c(5.1, 4.1, 4.1, 2.1), ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{margins}]  A numeric vector interpreted in the same way
as \code{par(mar)} in base graphics. 
\item[\code{...}]  All other arguments will be passed to a call to
the \code{viewport()} function. 
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A grid viewport object.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{viewport}{viewport}} and
\code{\LinkA{dataViewport}{dataViewport}}.
\end{SeeAlso}
\HeaderA{pop.viewport}{Pop a Viewport off the Grid Viewport Stack}{pop.viewport}
\keyword{dplot}{pop.viewport}
%
\begin{Description}\relax
Grid maintains a viewport stack --- a list of nested drawing
contexts.

This function makes the parent of the specified viewport the
new default viewport.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pop.viewport(n=1, recording=TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{n}] An integer giving the number of viewports to pop.
Defaults to 1.
\item[\code{recording}] A logical value to indicate whether the set-viewport
operation should be recorded on the Grid display list.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None.
\end{Value}
%
\begin{Section}{Warning}
This function has been deprecated.  Please use \code{popViewport}
instead.
\end{Section}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{push.viewport}{push.viewport}}.
\end{SeeAlso}
\HeaderA{push.viewport}{Push a Viewport onto the Grid Viewport Stack}{push.viewport}
\keyword{dplot}{push.viewport}
%
\begin{Description}\relax
Grid maintains a viewport stack --- a list of nested drawing
contexts.

This function makes the specified viewport the default viewport
and makes its parent the previous default viewport (i.e.,
nests the specified context within the previous default context).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
push.viewport(..., recording=TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] One or more objects of class \code{"viewport"}, or
\code{NULL}.
\item[\code{recording}] A logical value to indicate whether the set-viewport
operation should be recorded on the Grid display list.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
None.
\end{Value}
%
\begin{Section}{Warning}
This function has been deprecated.  Please use \code{pushViewport}
instead.
\end{Section}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{pop.viewport}{pop.viewport}}.
\end{SeeAlso}
\HeaderA{Querying the Viewport Tree}{Get the Current Grid Viewport (Tree)}{Querying the Viewport Tree}
\aliasA{current.transform}{Querying the Viewport Tree}{current.transform}
\aliasA{current.viewport}{Querying the Viewport Tree}{current.viewport}
\aliasA{current.vpPath}{Querying the Viewport Tree}{current.vpPath}
\aliasA{current.vpTree}{Querying the Viewport Tree}{current.vpTree}
\keyword{dplot}{Querying the Viewport Tree}
%
\begin{Description}\relax
\code{current.viewport()}
returns the viewport that Grid is going to draw into.

\code{current.vpTree} returns the entire Grid viewport tree.

\code{current.vpPath} returns the viewport path to the current viewport.

\code{current.transform} returns the transformation
matrix for the current viewport.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
current.viewport(vp=NULL)
current.vpTree(all=TRUE)
current.vpPath()
current.transform()
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vp}] A Grid viewport object.  Use of this argument has been deprecated.
\item[\code{all}] A logical value indicating whether the entire viewport
tree should be returned.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
If \code{all} is \code{FALSE} then
\code{current.vpTree} only returns the subtree below
the current viewport.
\end{Details}
%
\begin{Value}
A Grid viewport object from \code{current.viewport} or
\code{current.vpTree}.

\code{current.transform} returns a 4x4 transformation matrix.

The viewport path returned by \code{current.vpPath} is \code{NULL}
if the current viewport is the \code{ROOT} viewport
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{viewport}{viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
pushViewport(viewport(width=0.8, height=0.8, name="A"))
pushViewport(viewport(x=0.1, width=0.3, height=0.6,
  just="left", name="B"))
upViewport(1)
pushViewport(viewport(x=0.5, width=0.4, height=0.8,
  just="left", name="C"))
pushViewport(viewport(width=0.8, height=0.8, name="D"))
current.vpPath()
upViewport(1)
current.vpPath()
current.vpTree()
current.viewport()
current.vpTree(all=FALSE)
popViewport(0)
\end{ExampleCode}
\end{Examples}
\HeaderA{roundrect}{Draw a rectangle with rounded corners}{roundrect}
\aliasA{grid.roundrect}{roundrect}{grid.roundrect}
\aliasA{roundrectGrob}{roundrect}{roundrectGrob}
\keyword{dplot}{roundrect}
%
\begin{Description}\relax
Draw a \emph{single} rectangle with rounded corners.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
roundrectGrob(x=0.5, y=0.5, width=1, height=1,
              default.units="npc",
              r=unit(0.1, "snpc"),
              just="centre",
              name=NULL, gp=NULL, vp=NULL) 
grid.roundrect(...) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x, y, width, height}] The location and size of the rectangle.
\item[\code{default.units}] A string indicating the default units to use
if \code{x}, \code{y}, \code{width}, or \code{height}
are only given as numeric vectors. 
\item[\code{r}] The radius of the rounded corners.
\item[\code{just}] The justification of the rectangle relative to its
location.
\item[\code{name}] A name to identify the grob.
\item[\code{gp}] Graphical parameters to apply to the grob.
\item[\code{vp}] A viewport object or \code{NULL}.
\item[\code{...}] Arguments to be passed to \code{roundrectGrob()}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
At present, this function can only be used to draw \emph{one}
rounded rectangle.
\end{Details}
%
\begin{Examples}
\begin{ExampleCode}
grid.roundrect(width=.5, height=.5, name="rr")
theta <- seq(0, 360, length=50)
for (i in 1:50) 
    grid.circle(x=grobX("rr", theta[i]),
                y=grobY("rr", theta[i]),
                r=unit(1, "mm"),
                gp=gpar(fill="black"))
\end{ExampleCode}
\end{Examples}
\HeaderA{showGrob}{Label grid grobs.}{showGrob}
\keyword{dplot}{showGrob}
%
\begin{Description}\relax
Produces a graphical display of (by default) the current grid scene,
with labels showing the names of each grob in the scene.
It is also possible to label only specific grobs in the scene.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
showGrob(x = NULL,
         gPath = NULL, strict = FALSE, grep = FALSE,
         recurse = TRUE, depth = NULL,
         labelfun = grobLabel, ...) 
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] 
If \code{NULL}, the current grid scene is labelled.
Otherwise, a grob (or gTree) to draw and then label.

\item[\code{gPath}] 
A path identifying a subset of the current scene or grob
to be labelled.

\item[\code{strict}] 
Logical indicating whether the gPath is strict.

\item[\code{grep}] 
Logical indicating whether the gPath is a regular expression.

\item[\code{recurse}] 
Should the children of gTrees also be labelled?

\item[\code{depth}] 
Only display grobs at the specified depth (may be a vector
of depths).

\item[\code{labelfun}] 
Function used to generate a label from each grob.

\item[\code{...}] 
Arguments passed to \code{labelfun} to control fine details
of the generated label.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
None of the labelling is recorded on the grid display list so the
original scene can be reproduced by calling \code{grid.refresh}.
\end{Details}
%
\begin{SeeAlso}\relax
\code{\LinkA{grob}{grob}} and
\code{\LinkA{gTree}{gTree}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
    grid.newpage()
    gt <- gTree(childrenvp=vpStack(
                  viewport(x=0, width=.5, just="left", name="vp"),
                  viewport(y=.5, height=.5, just="bottom", name="vp2")),
                children=gList(rectGrob(vp="vp::vp2", name="child")),
                name="parent")
    grid.draw(gt)
    showGrob()
    showGrob(gPath="child")
    showGrob(recurse=FALSE)
    showGrob(depth=1)
    showGrob(depth=2)
    showGrob(depth=1:2)
    showGrob(gt)
    showGrob(gt, gPath="child")
    showGrob(just="left", gp=gpar(col="red", cex=.5), rot=45)
    showGrob(labelfun=function(grob, ...) {
        x <- grobX(grob, "west")
        y <- grobY(grob, "north")
        gTree(children=gList(rectGrob(x=x, y=y,
                width=stringWidth(grob$name) + unit(2, "mm"),
                height=stringHeight(grob$name) + unit(2, "mm"),
                gp=gpar(col=NA, fill=rgb(1, 0, 0, .5)),
                just=c("left", "top")),
                textGrob(grob$name,
                         x=x + unit(1, "mm"), y=y - unit(1, "mm"),
                         just=c("left", "top"))))
    })

## Not run: 
    # Examples from higher-level packages

    library(lattice)
    # Ctrl-c after first example
    example(histogram)
    showGrob()
    showGrob(gPath="plot_01.ylab")
    
    library(ggplot2)
    # Ctrl-c after first example
    example(qplot)
    showGrob()
    showGrob(recurse=FALSE)
    showGrob(gPath="panel-3-3")
    showGrob(gPath="axis.title", grep=TRUE)
    showGrob(depth=2)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{showViewport}{Display grid viewports.}{showViewport}
\keyword{dplot}{showViewport}
%
\begin{Description}\relax
Produces a graphical display of (by default) the current
grid viewport tree.  It is also possible to display only
specific viewports.  Each viewport is drawn as a rectangle
and the leaf viewports are labelled with the viewport name.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
showViewport(vp = NULL, recurse = TRUE, depth = NULL,
             newpage = FALSE, leaves = FALSE,
             col = rgb(0, 0, 1, 0.2), fill = rgb(0, 0, 1, 0.1),
             label = TRUE, nrow = 3, ncol = nrow)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{vp}] 
If \code{NULL}, the current viewport tree is displayed.
Otherwise, a viewport (or vpList, or vpStack, or vpTree) or
a vpPath that specifies which viewport to display.

\item[\code{recurse}] 
Should the children of the specified viewport also be displayed?

\item[\code{depth}] 
Only display viewports at the specified depth (may be a vector
of depths).

\item[\code{newpage}] 
Start a new page for the display?  Otherwise, the viewports
are displayed on top of the current plot.

\item[\code{leaves}] 
Produce a matrix of smaller displays, with each leaf viewport
in its own display.

\item[\code{col}] 
The colour used to draw the border of the rectangle for each
viewport \emph{and} to draw the label for each viewport.
If a vector, then the first colour is used for the
top-level viewport, the second colour is used for its children,
the third colour for their children, and so on.

\item[\code{fill}] 
The colour used to fill each viewport.  May be a vector as per
\code{col}.

\item[\code{label}] 
Should the viewports be labelled (with the viewport name)?

\item[\code{nrow, ncol}] 
The number of rows and columns when \code{leaves} is \code{TRUE}.
Otherwise ignored.

\end{ldescription}
\end{Arguments}
%
\begin{SeeAlso}\relax
\code{\LinkA{viewport}{viewport}} and
\code{\LinkA{grid.show.viewport}{grid.show.viewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showViewport(viewport(width=.5, height=.5))

showViewport(vpStack(viewport(width=.5, height=.5),
                     viewport(width=.5, height=.5)),
             newpage=TRUE)

showViewport(vpStack(viewport(width=.5, height=.5),
                     viewport(width=.5, height=.5)),
             fill=rgb(1:0, 0:1, 0, .1),
             newpage=TRUE)
\end{ExampleCode}
\end{Examples}
\HeaderA{stringWidth}{Create a Unit Describing the Width and Height of a String or Math Expression}{stringWidth}
\aliasA{stringAscent}{stringWidth}{stringAscent}
\aliasA{stringDescent}{stringWidth}{stringDescent}
\aliasA{stringHeight}{stringWidth}{stringHeight}
\keyword{dplot}{stringWidth}
%
\begin{Description}\relax
These functions create a unit object describing the width or height of
a string.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
stringWidth(string)
stringHeight(string)
stringAscent(string)
stringDescent(string)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{string}] A character vector or a language object (as used for
`\LinkA{plotmath}{plotmath}' calls.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A \code{\LinkA{unit}{unit}} object.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{unit}{unit}} and
\code{\LinkA{grobWidth}{grobWidth}}

\code{strwidth} in the \pkg{graphics} package for more details of the
typographic concepts behind the computations.
\end{SeeAlso}
\HeaderA{unit}{Function to Create a Unit Object}{unit}
\keyword{dplot}{unit}
%
\begin{Description}\relax
This function creates a unit object --- a vector of unit values.
A unit value is typically just a single numeric value with an
associated unit.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unit(x, units, data=NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A numeric vector.
\item[\code{units}] A character vector specifying the units for the
corresponding numeric values.
\item[\code{data}] This argument is used to supply extra information
for special \code{unit} types.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Unit objects allow the user to specify locations and dimensions
in a large number of different coordinate systems.  All drawing
occurs relative to a viewport and the \code{units} specifies
what coordinate system to use within that viewport.

Possible \code{units} (coordinate systems) are:
\begin{description}

\item[\code{"npc"}] Normalised Parent Coordinates (the default).
The origin of the viewport is (0, 0) and the viewport has a width
and height of 1 unit.  For example, (0.5, 0.5) is the centre of
the viewport.
\item[\code{"cm"}] Centimetres.
\item[\code{"inches"}] Inches.  1 in = 2.54 cm.
\item[\code{"mm"}] Millimetres.  10 mm = 1 cm.
\item[\code{"points"}] Points.  72.27 pt = 1 in.
\item[\code{"picas"}] Picas.  1 pc = 12 pt.
\item[\code{"bigpts"}] Big Points.  72 bp = 1 in.
\item[\code{"dida"}] Dida. 1157 dd = 1238 pt.
\item[\code{"cicero"}] Cicero.  1 cc = 12 dd.
\item[\code{"scaledpts"}] Scaled Points.  65536 sp = 1 pt.
\item[\code{"lines"}] Lines of text.  Locations and dimensions
are in terms of multiples of the default text size of the viewport
(as specified by the viewport's \code{fontsize} and \code{lineheight}).
\item[\code{"char"}] Multiples of nominal font height of the
viewport (as specified by the viewport's \code{fontsize}).
\item[\code{"native"}] Locations and dimensions are relative to
the viewport's \code{xscale} and \code{yscale}.
\item[\code{"snpc"}] Square Normalised Parent Coordinates.
Same as Normalised Parent Coordinates, except gives the same answer for
horizontal and vertical locations/dimensions.  It uses the
\emph{lesser} of npc-width and npc-height.  This is useful for making
things which are a proportion of the viewport, but have to be square 
(or have a fixed aspect ratio).
\item[\code{"strwidth"}] Multiples of the width of the string
specified in the \code{data} argument.  The font size is
determined by the pointsize of the viewport.
\item[\code{"strheight"}] Multiples of the height of the string
specified in the \code{data} argument.  The font size is
determined by the pointsize of the viewport.
\item[\code{"grobwidth"}] Multiples of the width of the grob
specified in the \code{data} argument.
\item[\code{"grobheight"}] Multiples of the height of the grob
specified in the \code{data} argument.

\end{description}


A number of variations are also allowed for the most common units.
For example, it is possible to use \code{"in"} or \code{"inch"}
instead of \code{"inches"} and \code{"centimetre"} or
\code{"centimeter"} instead of \code{"cm"}.

A special \code{units} value of \code{"null"} is also allowed,
but only makes sense when used in specifying widths of columns
or heights of rows in grid layouts (see \code{\LinkA{grid.layout}{grid.layout}}).

The \code{data} argument must be a list when the \code{unit.length()}
is greater than 1.  For example,
\code{unit(rep(1, 3), c("npc", "strwidth", "inches"),
        data=list(NULL, "my string", NULL))}.

It is possible to subset unit objects in the normal way
(e.g., \code{unit(1:5, "npc")[2:4]}), but a special function
\code{unit.c} is provided for combining unit objects.

Certain arithmetic and summary operations are defined for
unit objects.  In particular, it is possible to add and subtract
unit objects (e.g., \code{unit(1, "npc") - unit(1, "inches")}),
and to specify the minimum or maximum of a list
of unit objects (e.g., \code{min(unit(0.5, "npc"), unit(1,
    "inches"))}).
\end{Details}
%
\begin{Value}
An object of class \code{"unit"}. 
\end{Value}
%
\begin{Section}{WARNING}
There is a special function \code{unit.c} for concatenating
several unit objects.

The \code{c} function will not give the right answer.

There used to be \code{"mylines"}, \code{"mychar"}, \code{"mystrwidth"},
\code{"mystrheight"} units.  These will still be accepted, but
work exactly the same as
\code{"lines"}, \code{"char"}, \code{"strwidth"},
\code{"strheight"}.
\end{Section}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{unit.c}{unit.c}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
unit(1, "npc")
unit(1:3/4, "npc")
unit(1:3/4, "npc") + unit(1, "inches")
min(unit(0.5, "npc"), unit(1, "inches"))
unit.c(unit(0.5, "npc"), unit(2, "inches") + unit(1:3/4, "npc"),
       unit(1, "strwidth", "hi there"))
\end{ExampleCode}
\end{Examples}
\HeaderA{unit.c}{Combine Unit Objects}{unit.c}
\keyword{dplot}{unit.c}
%
\begin{Description}\relax
This function produces a new unit object by combining the
unit objects specified as arguments.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unit.c(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] An arbitrary number of unit objects.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An object of class \code{unit}.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{unit}{unit}}.
\end{SeeAlso}
\HeaderA{unit.length}{Length of a Unit Object}{unit.length}
\keyword{dplot}{unit.length}
%
\begin{Description}\relax
The length of a unit object is defined as the number of unit
values in the unit object.

This function has been deprecated in favour of a unit method for
the generic \code{length} function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unit.length(unit)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{unit}] A unit object.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An integer value.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{unit}{unit}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
length(unit(1:3, "npc"))
length(unit(1:3, "npc") + unit(1, "inches"))
length(max(unit(1:3, "npc") + unit(1, "inches")))
length(max(unit(1:3, "npc") + unit(1, "strwidth", "a"))*4)
length(unit(1:3, "npc") + unit(1, "strwidth", "a")*4)
\end{ExampleCode}
\end{Examples}
\HeaderA{unit.pmin}{ Parallel Unit Minima and Maxima }{unit.pmin}
\aliasA{unit.pmax}{unit.pmin}{unit.pmax}
\keyword{dplot}{unit.pmin}
%
\begin{Description}\relax
Returns a unit object whose i'th value is the minimum (or maximum)
of the i'th values of the arguments.  
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unit.pmin(...)
unit.pmax(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}]  One or more unit objects. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The length of the result is the maximum of the lengths of the
arguments;  shorter arguments are recycled in the usual manner.
\end{Details}
%
\begin{Value}
A unit object.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
max(unit(1:3, "cm"), unit(0.5, "npc"))
unit.pmax(unit(1:3, "cm"), unit(0.5, "npc"))
\end{ExampleCode}
\end{Examples}
\HeaderA{unit.rep}{ Replicate Elements of Unit Objects }{unit.rep}
\keyword{dplot}{unit.rep}
%
\begin{Description}\relax
Replicates the units according to the values given in \code{times} and
\code{length.out}.

This function has been deprecated in favour of a unit method for
the generic \code{rep} function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
unit.rep(x, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}]  An object of class \code{"unit"}. 
\item[\code{...}] arguments to be passed to \code{\LinkA{rep}{rep}} such as
\code{times} and \code{length.out}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
An object of class \code{"unit"}.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{rep}{rep}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
rep(unit(1:3, "npc"), 3)
rep(unit(1:3, "npc"), 1:3)
rep(unit(1:3, "npc") + unit(1, "inches"), 3)
rep(max(unit(1:3, "npc") + unit(1, "inches")), 3)
rep(max(unit(1:3, "npc") + unit(1, "strwidth", "a"))*4, 3)
rep(unit(1:3, "npc") + unit(1, "strwidth", "a")*4, 3)
\end{ExampleCode}
\end{Examples}
\HeaderA{valid.just}{Validate a Justification}{valid.just}
\keyword{dplot}{valid.just}
%
\begin{Description}\relax
This utility function is useful for determining
whether a justification specification is valid.
An error is given if the justification is not valid.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
valid.just(just)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{just}] A justification either as a character value,
e.g., \code{"left"}, or as a numeric value, e.g., 0.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function is useful within a \code{validDetails} method
when writing a new grob class.
\end{Details}
%
\begin{Value}
A numeric representation of the justification (e.g.,
\code{"left"} becomes 0, \code{"right"} becomes 1, etc, ...).
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
\HeaderA{validDetails}{ Customising grid grob Validation }{validDetails}
\keyword{dplot}{validDetails}
%
\begin{Description}\relax
This generic hook function is called whenever a grid grob is created
or
edited
via \code{grob}, \code{gTree}, \code{grid.edit} or \code{editGrob}.
This provides an opportunity for customising the validation of a
new class derived from grob (or gTree).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
validDetails(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}]  A grid grob. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function is called by \code{grob}, \code{gTree},
\code{grid.edit} and \code{editGrob}.
A method should be written for classes derived from grob or gTree
to validate the values of slots specific to the new class.
(e.g., see \code{grid:::validDetails.axis}).

Note that the standard slots for grobs and gTrees are automatically
validated (e.g., \code{vp}, \code{gp} slots for grobs and,
in addition, \code{children}, and \code{childrenvp} slots for
gTrees) so only slots specific to a new class need to be addressed.
\end{Details}
%
\begin{Value}
The function MUST return the validated grob.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
 \code{\LinkA{grid.edit}{grid.edit}} 
\end{SeeAlso}
\HeaderA{vpPath}{ Concatenate Viewport Names }{vpPath}
\keyword{dplot}{vpPath}
%
\begin{Description}\relax
This function can be used to generate a viewport path for use
in \code{downViewport} or \code{seekViewport}.

A viewport path is a list of nested viewport names.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
vpPath(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}]  Character values which are viewport names. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Viewport names must only be unique amongst viewports which
share the same parent in the viewport tree.

This function can be used to generate a specification for
a viewport that includes the viewport's parent's name
(and the name of its parent and so on).

For interactive use, it is possible to directly specify
a path, but it is strongly recommended that this function
is used otherwise in case the path separator is changed
in future versions of grid.
\end{Details}
%
\begin{Value}
A \code{ vpPath } object.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{viewport}{viewport}},
\code{\LinkA{pushViewport}{pushViewport}},
\code{\LinkA{popViewport}{popViewport}},
\code{\LinkA{downViewport}{downViewport}},
\code{\LinkA{seekViewport}{seekViewport}},
\code{\LinkA{upViewport}{upViewport}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
vpPath("vp1", "vp2")
\end{ExampleCode}
\end{Examples}
\HeaderA{widthDetails}{ Width and Height of a grid grob }{widthDetails}
\aliasA{ascentDetails}{widthDetails}{ascentDetails}
\aliasA{descentDetails}{widthDetails}{descentDetails}
\aliasA{heightDetails}{widthDetails}{heightDetails}
\keyword{dplot}{widthDetails}
%
\begin{Description}\relax
These generic functions are used to determine the size of grid grobs.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
widthDetails(x)
heightDetails(x)
ascentDetails(x)
descentDetails(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}]  A grid grob. 
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
These functions are called in the calculation of
\code{"grobwidth"} and \code{"grobheight"} units.
Methods should be written for classes derived from grob or gTree
where the size of the grob can be determined (see, for example
\code{grid:::widthDetails.frame}).

The ascent of a grob is the height of the grob by default and
the descent of a grob is zero by default, except for text grobs
where the label is a single character value or expression.
\end{Details}
%
\begin{Value}
A unit object.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{absolute.size}{absolute.size}}.
\end{SeeAlso}
\HeaderA{Working with Viewports}{Maintaining and Navigating the Grid Viewport Tree}{Working with Viewports}
\aliasA{downViewport}{Working with Viewports}{downViewport}
\aliasA{popViewport}{Working with Viewports}{popViewport}
\aliasA{pushViewport}{Working with Viewports}{pushViewport}
\aliasA{seekViewport}{Working with Viewports}{seekViewport}
\aliasA{upViewport}{Working with Viewports}{upViewport}
\keyword{dplot}{Working with Viewports}
%
\begin{Description}\relax
Grid maintains a tree of viewports --- nested drawing
contexts. 

These functions provide ways to add or remove viewports
and to navigate amongst viewports in the tree.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
pushViewport(..., recording=TRUE)
popViewport(n, recording=TRUE)
downViewport(name, strict=FALSE, recording=TRUE)
seekViewport(name, recording=TRUE)
upViewport(n, recording=TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] One or more objects of class \code{"viewport"}.
\item[\code{n}] An integer value indicating how many viewports to
pop or navigate up.  The special value \code{0} indicates to
pop or navigate viewports right up to the root viewport.
\item[\code{name}] A character value to identify a viewport in the tree.
\item[\code{strict}]  A boolean indicating whether the vpPath must be
matched exactly. 
\item[\code{recording}] A logical value to indicate whether the viewport
operation should be recorded on the Grid display list.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Objects created by the \code{viewport()} function are only
descriptions
of a drawing context.  A viewport object must be pushed onto the
viewport tree before it has any effect on drawing.

The viewport tree always has a single root viewport (created by the
system) which corresponds to the entire device (and default
graphical parameter settings).  Viewports may be added to the tree
using \code{pushViewport()} and removed from the tree using
\code{popViewport()}.  

There is only ever one current viewport, which is the current
position within the viewport tree.  All drawing and
viewport operations are relative to the current viewport.
When a viewport is pushed it becomes the current viewport.
When a viewport is popped, the parent viewport becomes
the current viewport.  Use \code{upViewport} to navigate to the parent
of the current viewport, without removing the current viewport
from the viewport tree.  Use \code{downViewport} to navigate to
a viewport further down the viewport tree and \code{seekViewport}
to navigate to a viewport anywhere else in the tree.

If a viewport is pushed and it has the same \code{name} as a
viewport at the same level in the tree, then it replaces the
existing viewport in the tree.
\end{Details}
%
\begin{Value}
\code{downViewport} returns the number of viewports it went down.

This can be useful for returning to your starting point by doing
something like \code{depth <- downViewport()} then
\code{upViewport(depth)}.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{viewport}{viewport}} and \code{\LinkA{vpPath}{vpPath}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# push the same viewport several times
grid.newpage()
vp <- viewport(width=0.5, height=0.5)
pushViewport(vp)
grid.rect(gp=gpar(col="blue"))
grid.text("Quarter of the device",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="blue"))
pushViewport(vp)
grid.rect(gp=gpar(col="red"))
grid.text("Quarter of the parent viewport",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="red"))
popViewport(2)
# push several viewports then navigate amongst them
grid.newpage()
grid.rect(gp=gpar(col="grey"))
grid.text("Top-level viewport",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="grey"))
if (interactive()) Sys.sleep(1.0)
pushViewport(viewport(width=0.8, height=0.7, name="A"))
grid.rect(gp=gpar(col="blue"))
grid.text("1. Push Viewport A",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="blue"))
if (interactive()) Sys.sleep(1.0)
pushViewport(viewport(x=0.1, width=0.3, height=0.6,
  just="left", name="B"))
grid.rect(gp=gpar(col="red"))
grid.text("2. Push Viewport B (in A)",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="red"))
if (interactive()) Sys.sleep(1.0)
upViewport(1)
grid.text("3. Up from B to A",
  y=unit(1, "npc") - unit(2, "lines"), gp=gpar(col="blue"))
if (interactive()) Sys.sleep(1.0)
pushViewport(viewport(x=0.5, width=0.4, height=0.8,
  just="left", name="C"))
grid.rect(gp=gpar(col="green"))
grid.text("4. Push Viewport C (in A)",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="green"))
if (interactive()) Sys.sleep(1.0)
pushViewport(viewport(width=0.8, height=0.6, name="D"))
grid.rect()
grid.text("5. Push Viewport D (in C)",
  y=unit(1, "npc") - unit(1, "lines"))
if (interactive()) Sys.sleep(1.0)
upViewport(0)
grid.text("6. Up from D to top-level",
  y=unit(1, "npc") - unit(2, "lines"), gp=gpar(col="grey"))
if (interactive()) Sys.sleep(1.0)
downViewport("D")
grid.text("7. Down from top-level to D",
  y=unit(1, "npc") - unit(2, "lines"))
if (interactive()) Sys.sleep(1.0)
seekViewport("B")
grid.text("8. Seek from D to B",
  y=unit(1, "npc") - unit(2, "lines"), gp=gpar(col="red"))
pushViewport(viewport(width=0.9, height=0.5, name="A"))
grid.rect()
grid.text("9. Push Viewport A (in B)",
  y=unit(1, "npc") - unit(1, "lines"))
if (interactive()) Sys.sleep(1.0)
seekViewport("A")
grid.text("10. Seek from B to A (in ROOT)",
  y=unit(1, "npc") - unit(3, "lines"), gp=gpar(col="blue"))
if (interactive()) Sys.sleep(1.0)
seekViewport(vpPath("B", "A"))
grid.text("11. Seek from\nA (in ROOT)\nto A (in B)")
popViewport(0)
\end{ExampleCode}
\end{Examples}
\HeaderA{xDetails}{ Boundary of a grid grob }{xDetails}
\aliasA{yDetails}{xDetails}{yDetails}
\keyword{dplot}{xDetails}
%
\begin{Description}\relax
These generic functions are used to determine a location
on the boundary of a grid grob.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
xDetails(x, theta)
yDetails(x, theta)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}]  A grid grob. 
\item[\code{theta}]  A numeric angle, in degrees, measured
anti-clockwise from the 3 o'clock \emph{or} one of
the following character strings: \code{"north"},
\code{"east"}, \code{"west"}, \code{"south"}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The location on the grob boundary is determined by taking
a line from the centre of the grob at the angle \code{theta}
and intersecting it with the convex hull of the grob
(for the basic
grob primitives, the centre is
determined as half way between the minimum and maximum values
in x and y directions).

These functions are called in the calculation of
\code{"grobx"} and \code{"groby"} units as produced by
the \code{grobX} and \code{grobY} functions.
Methods should be written for classes derived from grob or gTree
where the boundary of the grob can be determined.
\end{Details}
%
\begin{Value}
A unit object.
\end{Value}
%
\begin{Author}\relax
 Paul Murrell 
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{grobX}{grobX}},
\code{\LinkA{grobY}{grobY}}.
\end{SeeAlso}
\HeaderA{xsplinePoints}{Return the points that would be used to draw an Xspline (or a Bezier curve).}{xsplinePoints}
\aliasA{bezierPoints}{xsplinePoints}{bezierPoints}
\keyword{dplot}{xsplinePoints}
%
\begin{Description}\relax
Rather than drawing an Xspline (or Bezier curve), this function returns
the points that would be used to draw the series of line
segments for the Xspline.  This may be useful to post-process
the Xspline curve, for example, to clip the curve.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
xsplinePoints(x)
bezierPoints(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] 
An Xspline grob, as produced by the \code{xsplineGrob()} function
(or a beziergrob, as produced by the \code{bezierGrob()} function).

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The points returned by this function will only be relevant
for the drawing context in force when this function was called.
\end{Details}
%
\begin{Value}
Depends on how many Xsplines would be drawn.  If only one, then
a list with two components, named x and y, both of which are
unit objects (in inches).  If several Xsplines would be drawn
then the result of this function is a list of lists.
\end{Value}
%
\begin{Author}\relax
Paul Murrell
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{xsplineGrob}{xsplineGrob}} and
\code{\LinkA{bezierGrob}{bezierGrob}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
grid.newpage()
xsg <- xsplineGrob(c(.1, .1, .9, .9), c(.1, .9, .9, .1), shape=1)
grid.draw(xsg)
trace <- xsplinePoints(xsg)
grid.circle(trace$x, trace$y, default.units="inches", r=unit(.5, "mm"))

grid.newpage()
vp <- viewport(width=.5)
xg <- xsplineGrob(x=c(0, .2, .4, .2, .5, .7, .9, .7),
                  y=c(.5, 1, .5, 0, .5, 1, .5, 0),
                  id=rep(1:2, each=4),
                  shape=1,
                  vp=vp)
grid.draw(xg)
trace <- xsplinePoints(xg)
pushViewport(vp)
lapply(trace, function(t) grid.lines(t$x, t$y, gp=gpar(col="red")))
popViewport()

grid.newpage()
bg <- bezierGrob(c(.2, .2, .8, .8), c(.2, .8, .8, .2))
grid.draw(bg)
trace <- bezierPoints(bg)
grid.circle(trace$x, trace$y, default.units="inches", r=unit(.5, "mm"))
\end{ExampleCode}
\end{Examples}
\clearpage
