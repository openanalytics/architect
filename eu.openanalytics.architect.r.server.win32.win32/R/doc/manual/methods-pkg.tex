
\chapter{The \texttt{methods} package}
\HeaderA{methods-package}{Formal Methods and Classes}{methods.Rdash.package}
\keyword{package}{methods-package}
\keyword{methods}{methods-package}
%
\begin{Description}\relax
Formally defined methods and classes for R objects, plus
other programming tools, as described in the references.
\end{Description}
%
\begin{Details}\relax
This package provides the `S4' or `S version 4' 
approach to methods and classes in a functional language.

See the documentation entries \code{\LinkA{Classes}{Classes}},
\code{\LinkA{Methods}{Methods}}, and \code{\LinkA{GenericFunctions}{GenericFunctions}} for general discussion of these topics, at a
fairly technical level.  Links from those pages, and the
documentation of \code{\LinkA{setClass}{setClass}} and \code{\LinkA{setMethod}{setMethod}}
cover the main programming tools needed.

For a complete
list of functions and classes, use \code{library(help="methods")}.
\end{Details}
%
\begin{Author}\relax
R Core Team

Maintainer: R Core Team \email{R-core@r-project.org}
\end{Author}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
\HeaderA{.BasicFunsList}{List of Builtin and Special Functions}{.BasicFunsList}
\keyword{programming}{.BasicFunsList}
\keyword{methods}{.BasicFunsList}
%
\begin{Description}\relax
A named list providing instructions for turning builtin and special
functions into generic functions.

Functions in R that are defined as \code{.Primitive(<name>)} are not
suitable for formal methods, because they lack the basic reflectance
property.  You can't find the argument list for these functions by
examining the function object itself.

Future versions of R may fix this by attaching a formal argument list
to the corresponding function.  While generally the names of arguments
are not checked by the internal code implementing the function, the
number of arguments frequently is.

In any case, some definition of a formal argument list is needed if
users are to define methods for these functions.  In particular, if
methods are to be merged from multiple packages, the different sets
of methods need to agree on the formal arguments.

In the absence of reflectance, this list provides the relevant
information  via a dummy function associated with each of the known
specials for which methods are allowed.

At the same, the list flags those specials for which methods are
meaningless (e.g., \code{for}) or just a very bad idea (e.g.,
\code{.Primitive}).

A generic function created via \code{\LinkA{setMethod}{setMethod}}, for
example, for one of these special functions will have the argument
list from \code{.BasicFunsList}.  If no entry exists, the argument
list \code{(x, ...)}  is assumed.
\end{Description}
\HeaderA{as}{Force an Object to Belong to a Class}{as}
\aliasA{as<\Rdash}{as}{as<.Rdash.}
\aliasA{coerce}{as}{coerce}
\aliasA{coerce,ANY,array-method}{as}{coerce,ANY,array.Rdash.method}
\aliasA{coerce,ANY,call-method}{as}{coerce,ANY,call.Rdash.method}
\aliasA{coerce,ANY,character-method}{as}{coerce,ANY,character.Rdash.method}
\aliasA{coerce,ANY,complex-method}{as}{coerce,ANY,complex.Rdash.method}
\aliasA{coerce,ANY,environment-method}{as}{coerce,ANY,environment.Rdash.method}
\aliasA{coerce,ANY,expression-method}{as}{coerce,ANY,expression.Rdash.method}
\aliasA{coerce,ANY,function-method}{as}{coerce,ANY,function.Rdash.method}
\aliasA{coerce,ANY,integer-method}{as}{coerce,ANY,integer.Rdash.method}
\aliasA{coerce,ANY,list-method}{as}{coerce,ANY,list.Rdash.method}
\aliasA{coerce,ANY,logical-method}{as}{coerce,ANY,logical.Rdash.method}
\aliasA{coerce,ANY,matrix-method}{as}{coerce,ANY,matrix.Rdash.method}
\aliasA{coerce,ANY,name-method}{as}{coerce,ANY,name.Rdash.method}
\aliasA{coerce,ANY,NULL-method}{as}{coerce,ANY,NULL.Rdash.method}
\aliasA{coerce,ANY,numeric-method}{as}{coerce,ANY,numeric.Rdash.method}
\aliasA{coerce,ANY,single-method}{as}{coerce,ANY,single.Rdash.method}
\aliasA{coerce,ANY,ts-method}{as}{coerce,ANY,ts.Rdash.method}
\aliasA{coerce,ANY,vector-method}{as}{coerce,ANY,vector.Rdash.method}
\aliasA{coerce-methods}{as}{coerce.Rdash.methods}
\aliasA{coerce<\Rdash}{as}{coerce<.Rdash.}
\aliasA{setAs}{as}{setAs}
\keyword{programming}{as}
\keyword{classes}{as}
\keyword{methods}{as}
%
\begin{Description}\relax
These functions manage the relations that allow coercing an object to
a given class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
as(object, Class, strict=TRUE, ext)

as(object, Class) <- value

setAs(from, to, def, replace, where = topenv(parent.frame()))

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] any \R{} object.
\item[\code{Class}] the name of the class to which \code{object} should be
coerced. 
\item[\code{strict}] logical flag.  If \code{TRUE}, the returned object
must be strictly from the target class (unless that class is a
virtual class, in which case the object will be from the closest
actual class, in particular the original object, if that class extends the
virtual class directly).

If \code{strict = FALSE}, any simple extension of the target class
will be returned, without further change.  A simple extension is,
roughly, one that just adds slots to an existing class.
\item[\code{value}] The value to use to modify \code{object} (see the
discussion below).  You should supply an object with class
\code{Class}; some coercion is done, but you're unwise to rely on
it.

\item[\code{from, to}] The classes between which the coerce methods
\code{def} and \code{replace} perform coercion.

\item[\code{def}] function of one argument.  It will get an object from
class \code{from} and had better return an object of class
\code{to}. The convention is that
the name of the argument is \code{from}; if another argument name
is used, \code{setAs} will attempt to substitute \code{from}. 
\item[\code{replace}] if supplied, the function to use as a replacement
method, when \code{as} is used on the left of an assignment.
Should be a function of two arguments, \code{from, value},
although \code{setAs} will attempt to substitute if the arguments differ.
\item[\code{where}] the position or environment in which to store the
resulting methods. For most applications, it is recommended to
omit this argument and to include the call to \code{setAs} in source code that is evaluated at the top level; that is, either in an R session by something equivalent to a call to \code{\LinkA{source}{source}}, or as part of the R source code for a package.
\item[\code{ext}] the optional object
defining how \code{Class} is extended by the class of the
object (as returned by \code{\LinkA{possibleExtends}{possibleExtends}}).
This argument is used internally (to provide essential
information for non-public classes), but you are unlikely to want
to use it directly.

\end{ldescription}
\end{Arguments}
%
\begin{Section}{Summary of Functions}
\begin{description}

\item[\code{as}:] 
Returns the version of this object coerced to be the given
\code{Class}.  When used in the replacement form on the left of
an assignment, the portion of the object corresponding to
\code{Class} is replaced by \code{value}.

The operation of \code{as()} in either form depends on the
definition of coerce methods.  Methods are defined automatically
when the two classes are related by inheritance; that is, when
one of the classes is a subclass of the other.  See the section
on inheritance  below for details.

Coerce methods are also predefined for basic classes (including all
the types of vectors, functions and a few others). See
\code{showMethods(coerce)} for a list of these.

Beyond these two sources of methods, further methods are defined
by calls to the \code{setAs} function.



\item[\code{setAs}:] 
Define methods for coercing an object of class \code{from} to be of class \code{to}; the \code{def} argument provides for direct coercing and the \code{replace} argument, if included, provides for replacement.  See the ``How'' section below for details.


\item[\code{coerce}, \code{coerce<-}:] 
Coerce \code{from} to be of the same class as \code{to}.

These functions should not be called explicitly.  The function
\code{\LinkA{setAs}{setAs}} creates methods for them for the
\code{as} function to use.



\end{description}

\end{Section}
%
\begin{Section}{Inheritance and Coercion}

Objects from one class can turn into objects from another class
either automatically or by an explicit call to the \code{as}
function.  Automatic conversion is special, and comes from the
designer of one class of objects asserting that this class extends
another class.  The most common case is that one or more class names
are supplied in the \code{contains=} argument to \code{setClass}, in
which case the new class extends each of the earlier classes (in the
usual terminology, the earlier classes are \emph{superclasses} of
the new class and it is a \emph{subclass} of each of them).

This form of inheritance is called \emph{simple} inheritance in \R{}.
See \code{\LinkA{setClass}{setClass}} for details.
Inheritance can also be defined explicitly by a call to
\code{\LinkA{setIs}{setIs}}.
The two versions have slightly different implications for coerce methods.
Simple inheritance implies that inherited slots behave identically in the subclass and the superclass.
Whenever two classes are related by simple inheritance, corresponding coerce methods
are defined for both direct and replacement use of \code{as}.
In the case of simple inheritance, these methods do the obvious
computation:  they extract or replace the slots in the object that
correspond to those in the superclass definition.

The implicitly defined coerce methods may be overridden by a call
to \code{setAs}; note, however, that the implicit methods are defined for each
subclass-superclass pair, so that you must override each of these
explicitly, not rely on inheritance.

When inheritance is defined by a call to \code{setIs}, the coerce methods are provided explicitly, not generated automatically.
Inheritance will apply (to the \code{from} argument, as described in  the section below).
You could also supply methods via \code{setAs} for non-inherited relationships, and now these also can be inherited.

For further on the distinction between simple and explicit inheritance, see \code{\LinkA{setIs}{setIs}}.

\end{Section}
%
\begin{Section}{How Functions 'as' and 'setAs' Work}
The function \code{as}  turns \code{object} into an object
of class \code{Class}.  In doing so, it applies a ``coerce
method'', using S4
classes and methods, but in a somewhat special way.
Coerce methods are methods for the function \code{coerce} or, in the
replacement case the function \code{`coerce<-`}.
These functions have two arguments in method signatures, \code{from}
and \code{to}, corresponding to the class of the object and the
desired coerce class.
These functions must not be called directly, but are used to store
tables of methods for the use of \code{as}, directly and for
replacements.
In this section we will describe the direct case, but except where
noted the replacement case works the same way, using \code{`coerce<-`}
and the \code{replace} argument to \code{setAs}, rather than
\code{coerce} and the \code{def} argument.

Assuming the \code{object} is not already of the desired class,
\code{as} first looks for a method in the table of methods
for the function
\code{coerce} for the signature \code{c(from = class(object), to =
    Class)}, in the same way method selection would do its initial lookup.
To be precise, this means the table of both direct and inherited
methods, but inheritance is used specially in this case (see below).

If no method is found, \code{as} looks for one.
First, if either \code{Class} or \code{class(object)} is a superclass
of the other, the class definition will contain the information needed
to construct a coerce method.
In the usual case that the subclass contains the superclass (i.e., has
all its slots), the method is constructed either by extracting or
replacing the inherited slots.
Non-simple extensions (the result of a call to \code{\LinkA{setIs}{setIs}})
will usually contain explicit methods, though possibly not for replacement. 

If no subclass/superclass relationship provides a method, \code{as}
looks for an inherited method, but applying, inheritance for the argument \code{from} only, not for
the argument \code{to} (if you think about it, you'll probably agree
that you wouldn't want the result to be from some class other than the
\code{Class} specified). Thus,
\code{selectMethod("coerce", sig, useInherited= c(from=TRUE, to= FALSE))}
replicates the method selection used by \code{as()}.

In nearly all cases the method found in this way will be cached in the
table of coerce methods (the exception being subclass relationships with a test, which
are legal but discouraged).
So the detailed calculations should be done only on the first
occurrence of a coerce from \code{class(object)} to \code{Class}.

Note that  \code{coerce} is not a standard generic function.  It is
not intended to be called directly.  To prevent accidentally caching
an invalid inherited method, calls are routed to an equivalent call to
\code{as}, and a warning is issued.  Also, calls to
\code{\LinkA{selectMethod}{selectMethod}} for this function may not represent the
method that \code{as} will choose.  You can only trust the result if
the corresponding call to \code{as} has occurred previously in this
session.

With this explanation as background, the function \code{setAs} does a
fairly obvious computation:  It constructs and sets a method for the function
\code{coerce} with signature \code{c(from, to)}, using the \code{def}
argument to define the body of the method.  The function supplied as
\code{def} can have one argument (interpreted as an object to be
coerced) or two arguments (the \code{from} object and the \code{to}
class).  Either way, \code{setAs} constructs a function of two
arguments, with the second defaulting to the name of the \code{to}
class.  The method will be called from \code{as} with the object
as the \code{from} argument and no \code{to} argument, with the default for this argument being the name of the intended
\code{to} class, so the method can use this information in messages.

The direct version of the \code{as} function also has a \code{strict=} argument that defaults to \code{TRUE}.
Calls during the evaluation of methods for other functions will set this argument to \code{FALSE}.
The distinction is relevant when the object being coerced is from a simple subclass of the \code{to} class; if \code{strict=FALSE} in this case, nothing need be done.
For most user-written coerce methods, when the two classes have no subclass/superclass, the \code{strict=} argument is irrelevant.

The \code{replace} argument to \code{setAs} provides a method for
\code{`coerce<-`}.
As with all replacement methods, the last argument of the method must
have the name \code{value} for the object on the right of the
assignment.
As with the \code{coerce} method, the first two arguments are
\code{from, to}; there is no \code{strict=} option for the replace case.

The function \code{coerce} exists as a repository for
such methods, to be selected as described above by the \code{as}
function.  Actually dispatching the methods using
\code{standardGeneric} could produce incorrect inherited methods, by using
inheritance on the
\code{to} argument; as mentioned, this is not the logic used for
\code{as}.
To prevent selecting and caching invalid methods, calls to
\code{coerce} are
currently mapped into calls to \code{as}, with a warning message.
\end{Section}
%
\begin{Section}{Basic Coercion Methods}
Methods are pre-defined for coercing any object to one of the basic
datatypes.  For example, \code{as(x, "numeric")} uses the existing
\code{as.numeric} function.  These built-in methods can be listed by
\code{showMethods("coerce")}.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
If you think of using \code{try(as(x, cl))}, consider
\code{\LinkA{canCoerce}{canCoerce}(x, cl)} instead.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## using the definition of class "track" from \link{setClass}



setAs("track", "numeric", function(from) from@y)

t1 <- new("track", x=1:20, y=(1:20)^2)

as(t1, "numeric")

## The next example shows:
##  1. A virtual class to define setAs for several classes at once.
##  2. as() using inherited information

setClass("ca", representation(a = "character", id = "numeric"))

setClass("cb", representation(b = "character", id = "numeric"))

setClass("id")
setIs("ca", "id")
setIs("cb", "id")


setAs("id", "numeric", function(from) from@id)

CA <- new("ca", a = "A", id = 1)
CB <- new("cb", b = "B", id = 2)

setAs("cb", "ca", function(from, to )new(to, a=from@b, id = from@id))

as(CB, "numeric")


\end{ExampleCode}
\end{Examples}
\HeaderA{BasicClasses}{Classes Corresponding to Basic Data Types }{BasicClasses}
\aliasA{ANY-class}{BasicClasses}{ANY.Rdash.class}
\aliasA{builtin-class}{BasicClasses}{builtin.Rdash.class}
\aliasA{character-class}{BasicClasses}{character.Rdash.class}
\aliasA{complex-class}{BasicClasses}{complex.Rdash.class}
\aliasA{double-class}{BasicClasses}{double.Rdash.class}
\aliasA{expression-class}{BasicClasses}{expression.Rdash.class}
\aliasA{externalptr-class}{BasicClasses}{externalptr.Rdash.class}
\aliasA{function-class}{BasicClasses}{function.Rdash.class}
\aliasA{integer-class}{BasicClasses}{integer.Rdash.class}
\aliasA{list-class}{BasicClasses}{list.Rdash.class}
\aliasA{logical-class}{BasicClasses}{logical.Rdash.class}
\aliasA{missing-class}{BasicClasses}{missing.Rdash.class}
\aliasA{namedList-class}{BasicClasses}{namedList.Rdash.class}
\aliasA{NULL-class}{BasicClasses}{NULL.Rdash.class}
\aliasA{numeric-class}{BasicClasses}{numeric.Rdash.class}
\aliasA{raw-class}{BasicClasses}{raw.Rdash.class}
\aliasA{S4-class}{BasicClasses}{S4.Rdash.class}
\aliasA{single-class}{BasicClasses}{single.Rdash.class}
\aliasA{special-class}{BasicClasses}{special.Rdash.class}
\aliasA{vector-class}{BasicClasses}{vector.Rdash.class}
\aliasA{VIRTUAL-class}{BasicClasses}{VIRTUAL.Rdash.class}
\keyword{classes}{BasicClasses}
%
\begin{Description}\relax
Formal classes exist corresponding to the basic R object types, allowing
these types to be used in method signatures, as slots in class
definitions, and to be extended by new classes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
### The following are all basic vector classes.
### They can appear as class names in method signatures,
### in calls to as(), is(), and new().
"character"
"complex"
"double"
"expression"
"integer"
"list"
"logical"
"numeric"
"single"
"raw"

### the class
"vector"
### is a virtual class, extended by all the above

### the class
"S4"
### is an object type for S4 objects that do not extend
### any of the basic vector classes.  It is a virtual class.

### The following are additional basic classes
"NULL"     #  NULL objects
"function" #  function objects, including primitives
"externalptr" # raw external pointers for use in C code

"ANY"  # virtual classes used by the methods package itself
"VIRTUAL"
"missing"

"namedList" # the alternative to "list" that preserves
            # the names attribute
\end{verbatim}
\end{Usage}
%
\begin{Section}{Objects from the Classes}
Objects can be created by calls of the form \code{new(Class, ...)},
where \code{Class} is the quoted class name, and the remaining
arguments if any are objects to be interpreted as vectors of this
class.  Multiple arguments will be concatenated.

The class \code{"expression"} is slightly odd, in that the \dots
arguments will \emph{not} be evaluated; therefore, don't enclose them
in a call to \code{quote()}.

Note that class \code{"list"} is a pure vector.  Although lists with
names go back to the earliest versions of S, they are an extension
of the vector concept in that they have an attribute (which can now
be a slot) and which is either \code{NULL} or a character vector of
the same length as the vector.  If you want to guarantee that list
names are preserved, use class \code{"namedList"}, rather than
\code{"list"}.  Objects from this class must have a names attribute,
corresponding to slot \code{"names"},
of type \code{"character"}.  Internally, R treats names for
lists  specially, which makes it impractical to have the corresponding slot in
class \code{"namedList"} be a union of character names and \code{NULL}.

\end{Section}
%
\begin{Section}{Classes and Types}
The basic classes include classes for the basic R types.  Note that
objects of these types will not usually be S4 objects
(\code{\LinkA{isS4}{isS4}} will return \code{FALSE}), although objects from
classes that contain the basic class will be S4 objects, still with
the same type.  The type as
returned by \code{\LinkA{typeof}{typeof}} will sometimes differ from the class,
either just from a choice of terminology (type \code{"symbol"} and
class \code{"name"}, for example) or because there is not a one-to-one
correspondence between class and type (most of the classes that
inherit from class \code{"language"} have type \code{"language"}, for example).
\end{Section}
%
\begin{Section}{Extends}
The vector classes extend \code{"vector"}, directly.
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[coerce] Methods are defined to coerce arbitrary objects to
the vector classes, by calling the corresponding basic function, for
example, \code{as(x, "numeric")} calls \code{as.numeric(x)}. 

\end{description}

\end{Section}
\HeaderA{callGeneric}{Call the Current Generic Function from a Method}{callGeneric}
\keyword{programming}{callGeneric}
\keyword{classes}{callGeneric}
\keyword{methods}{callGeneric}
%
\begin{Description}\relax
A call to \code{callGeneric} can only appear inside a method
definition.  It then results in a call to the current generic
function.  The value of that call is the value of \code{callGeneric}.
While it can be called from any method, it is useful and typically
used in methods for group generic functions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
callGeneric(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] 
Optionally, the arguments to the function in its next call.

If no arguments are included in the call to \code{callGeneric}, the
effect is to call the function with the current arguments.
See the detailed description for what this really means.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The name and package of the current generic function is stored in the
environment of the method definition object.  This name is looked up
and the corresponding function called.

The statement that passing no arguments to \code{callGeneric} causes
the generic  function to be called with the current arguments is
more precisely as follows.  Arguments that were missing in the current
call are still missing (remember that \code{"missing"} is a valid
class in a method signature).  For a formal argument, say \code{x}, that
appears in the original call, there is a corresponding argument in the
generated call equivalent to \code{x = x}.  In effect, this
means that the generic function sees the same actual arguments, but
arguments are evaluated only once.

Using \code{callGeneric} with no arguments is prone to creating
infinite recursion, unless one of the arguments in the signature has
been modified in the current method so that a different method is selected.
\end{Details}
%
\begin{Value}
The value returned by the new call.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{GroupGenericFunctions}{GroupGenericFunctions}} for other information
about group generic functions; \LinkA{Methods}{Methods} for the general behavior
of method dispatch
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## the method for group generic function Ops
## for signature( e1="structure", e2="vector")
function (e1, e2)
{
    value <- callGeneric(e1@.Data, e2)
    if (length(value) == length(e1)) {
        e1@.Data <- value
        e1
    }
    else value
}

## For more examples
## Not run: 
showMethods("Ops", includeDefs = TRUE)

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{callNextMethod}{Call an Inherited Method}{callNextMethod}
\keyword{programming}{callNextMethod}
\keyword{classes}{callNextMethod}
\keyword{methods}{callNextMethod}
%
\begin{Description}\relax
A call to \code{callNextMethod} can only appear inside a method
definition.  It then results in a call to the first inherited method
after the current method, with the arguments to the current method
passed down to the next method.  The value of that method call is the
value of \code{callNextMethod}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
callNextMethod(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] 
Optionally, the arguments to the function in its next call
(but note that the dispatch is as in the detailed description below;
the arguments have no effect on selecting the next method.)

If no arguments are included in the call to \code{callNextMethod}, the
effect is to call the method with the current arguments.
See the detailed description for what this really means.

Calling with no arguments is often the natural way to use
\code{callNextMethod}; see the examples.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The `next' method (i.e., the first inherited method) is defined
to be that method which \emph{would} have been called if the current
method did not exist. This is more-or-less literally what happens: The
current method (to be precise, the method with signature given by the
\code{defined} slot of the method from which \code{callNextMethod} is
called) is deleted from a copy of the methods for the current generic,
and \code{\LinkA{selectMethod}{selectMethod}} is called to find the next method (the
result is cached in a special object, so the search only typically
happens once per session per combination of argument classes).

Note that the preceding definition means that the next method is
defined uniquely when \code{setMethod} inserts the method containing
the \code{callNextMethod} call, given the definitions of the classes
in the signature. The choice does not depend on the path that gets us
to that method (for example, through inheritance or from another
\code{callNextMethod} call). This definition was not enforced in
versions of \R{} prior to 2.3.0, where the method was selected based on
the target signature, and so could vary depending on the actual
arguments.

It is also legal, and often useful, for the method called by
\code{callNextMethod} to itself have a call to
\code{callNextMethod}. This generally works as you would expect, but
for completeness be aware that it is possible to have ambiguous
inheritance in the S structure, in the sense that the same two
classes can appear as superclasses \emph{in the opposite order} in
two other class definitions.  In this case the effect of a nested
instance of \code{callNextMethod} is not well defined.  Such
inconsistent class hierarchies are both rare and nearly always the
result of bad design, but they are possible, and currently undetected.

The statement that the method is called with the current arguments is
more precisely as follows.  Arguments that were missing in the current
call are still missing (remember that \code{"missing"} is a valid
class in a method signature).  For a formal argument, say \code{x}, that
appears in the original call, there is a corresponding argument in the
next method call equivalent to \code{x = x}.  In effect, this
means that the next method sees the same actual arguments, but
arguments are evaluated only once.
\end{Details}
%
\begin{Value}
The value returned by the selected method.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{callGeneric}{callGeneric}} to call the generic function with the
current dispatch rules (typically for a group generic function);
\LinkA{Methods}{Methods} for the general behavior of method dispatch.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## some class definitions with simple inheritance
setClass("B0" , representation(b0 = "numeric"))

setClass("B1", representation(b1 = "character"), contains = "B0")

setClass("B2", representation(b2 = "logical"), contains = "B1")

## and a rather silly function to illustrate callNextMethod

f <- function(x) class(x)

setMethod("f", "B0", function(x) c(x@b0^2, callNextMethod()))
setMethod("f", "B1", function(x) c(paste(x@b1,":"), callNextMethod()))
setMethod("f", "B2", function(x) c(x@b2, callNextMethod()))

b1 <- new("B1", b0 = 2, b1 = "Testing")

b2 <- new("B2", b2 = FALSE, b1 = "More testing", b0 = 10)

f(b2)
stopifnot(identical(f(b2), c(b2@b2, paste(b2@b1,":"), b2@b0^2, "B2")))

f(b1)

## a sneakier method: the *changed* x is used:
setMethod("f", "B2",
          function(x) {x@b0 <- 111; c(x@b2, callNextMethod())})
f(b2)
stopifnot(identical(f(b2), c(b2@b2, paste(b2@b1,":"), 111^2, "B2")))



\end{ExampleCode}
\end{Examples}
\HeaderA{canCoerce}{Can an Object be Coerced to a Certain S4 Class?}{canCoerce}
\keyword{classes}{canCoerce}
\keyword{methods}{canCoerce}
%
\begin{Description}\relax
Test if an object can be coerced to a given S4 class.
Maybe useful inside \code{if()} to ensure that calling
\code{as(object, Class)} will find a method.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
canCoerce(object, Class)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] any \R{} object, typically of a formal S4 class.
\item[\code{Class}] an S4 class (see \code{\LinkA{isClass}{isClass}}).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a scalar logical, \code{TRUE} if there is a \code{coerce} method
(as defined by \code{\LinkA{setAs}{setAs}}, e.g.) for the signature
\code{(from = class(object), to = Class)}.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{as}{as}}, \code{\LinkA{setAs}{setAs}},
\code{\LinkA{selectMethod}{selectMethod}}, \code{\LinkA{setClass}{setClass}},
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
m <- matrix(pi, 2,3)
canCoerce(m, "numeric") # TRUE
canCoerce(m, "array")   # TRUE
\end{ExampleCode}
\end{Examples}
\HeaderA{cbind2}{Combine two Objects by Columns or Rows}{cbind2}
\aliasA{cbind2,ANY,ANY-method}{cbind2}{cbind2,ANY,ANY.Rdash.method}
\aliasA{cbind2,ANY,missing-method}{cbind2}{cbind2,ANY,missing.Rdash.method}
\aliasA{cbind2-methods}{cbind2}{cbind2.Rdash.methods}
\aliasA{rbind2}{cbind2}{rbind2}
\aliasA{rbind2,ANY,ANY-method}{cbind2}{rbind2,ANY,ANY.Rdash.method}
\aliasA{rbind2,ANY,missing-method}{cbind2}{rbind2,ANY,missing.Rdash.method}
\aliasA{rbind2-methods}{cbind2}{rbind2.Rdash.methods}
\keyword{array}{cbind2}
\keyword{manip}{cbind2}
%
\begin{Description}\relax
Combine two matrix-like \R{} objects by columns (\code{cbind2})
or rows (\code{rbind2}). These are (S4) generic functions with default
methods.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
cbind2(x, y, ...)
rbind2(x, y, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] any \R{} object, typically matrix-like.
\item[\code{y}] any \R{} object, typically similar to \code{x}, or missing
completely.
\item[\code{...}] optional arguments for methods.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The main use of \code{cbind2} (\code{rbind2}) is to be called by
\code{\LinkA{cbind}{cbind}()}  (\code{rbind()})
\bold{if} these are activated.  This allows \code{cbind}
(\code{rbind}) to work for formally classed (aka `S4')
objects by providing S4 methods for these objects.  Currently, a call\\{}
\code{methods:::bind\_activation(TRUE)}\\{}
is needed to install a
\code{cbind2}-calling version of \code{cbind} (into the
\pkg{base} namespace) and the same for \code{rbind}.\\{}
\code{methods:::bind\_activation(FALSE)} reverts to the
previous internal version of \code{cbind} which does not build on
\code{cbind2}, see the examples.
\end{Details}
%
\begin{Value}
A matrix (or matrix like object) combining the columns (or rows) of
\code{x} and \code{y}.
\end{Value}
%
\begin{Section}{Methods}
\begin{description}

\item[\code{signature(x = "ANY", y = "ANY")}] the default method
using \R{}'s internal code.
\item[\code{signature(x = "ANY", y = "missing")}] the default method
for one argument using \R{}'s internal code.

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
\code{\LinkA{cbind}{cbind}}, \code{\LinkA{rbind}{rbind}};
further, \code{\LinkA{cBind}{cBind}}, \code{\LinkA{rBind}{rBind}} in
the \Rhref{http://CRAN.R-project.org/package=Matrix}{\pkg{Matrix}} package.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
cbind2(1:3, 4)
m <- matrix(3:8, 2,3, dimnames=list(c("a","b"), LETTERS[1:3]))
cbind2(1:2, m) # keeps dimnames from m

### Note: Use the following activation if you want cbind() to work
### ----  on S4 objects -- be careful otherwise!

methods:::bind_activation(on = TRUE)
trace("cbind2")
cbind(a=1:3)# no call to cbind2()
cbind(a=1:3, four=4, 7:9)# calling cbind2() twice
untrace("cbind2")



cbind(m, a=1, b=3)

## turn off the `special cbind()' :
methods:::bind_activation(FALSE)
\end{ExampleCode}
\end{Examples}
\HeaderA{Classes}{Class Definitions}{Classes}
\aliasA{.environment-class}{Classes}{.environment.Rdash.class}
\aliasA{.externalptr-class}{Classes}{.externalptr.Rdash.class}
\aliasA{.name-class}{Classes}{.name.Rdash.class}
\aliasA{.NULL-class}{Classes}{.NULL.Rdash.class}
\aliasA{\_\_ClassMetaData}{Classes}{.Rul..Rul.ClassMetaData}
\keyword{programming}{Classes}
\keyword{classes}{Classes}
\keyword{methods}{Classes}
%
\begin{Description}\relax
Class definitions are objects that contain the formal definition of a
class of \R{} objects, usually referred to as an S4 class, to
distinguish them from the informal S3 classes.
This document gives an overview of S4 classes; for
details of the class representation objects, see help for the class
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}.
\end{Description}
%
\begin{Section}{Metadata Information}
When a class is defined, an object is stored that contains the
information about that class.  The object, known as the
\emph{metadata} defining the class, is not stored under the name of
the class (to allow programmers to write generating functions of
that name), but under a specially constructed name.
To examine the class definition, call \code{\LinkA{getClass}{getClass}}.  The
information in the metadata object includes:

\begin{description}

\item[Slots:] 

The data contained in an object from an S4 class is defined by
the \emph{slots} in the class definition.

Each slot in an object is a component of the object;
like components (that is, elements) of a
list, these may be extracted and set, using the
function \code{\LinkA{slot}{slot}()} or more often the operator
\code{"\LinkA{@}{@}"}.  However, they
differ from list components in important ways.
First, slots can only be referred to by name, not by position,
and there is no partial matching of names as with list elements.

All the objects from a particular class have the same set of slot
names; specifically, the slot names that are contained in the
class definition.  Each slot in each object always is an object
of  the
class specified for this slot in the definition of the current class.
The word ``is'' corresponds to the \R{} function of the same
name (\code{\LinkA{is}{is}}), meaning that the class of the object in
the slot must be the same as the class specified in the
definition, or some class that extends the one in the
definition (a \emph{subclass}).

A special slot name, \code{.Data}, stands for the
`data part' of the object.  An object from a class with a
data part is defined by specifying that the class contains one
of the \R{} object types or one of the special pseudo-classes,
\code{matrix} or \code{array}, usually because the definition of
the class, or of one of its superclasses, has included the type
or pseudo-class in its \code{contains} argument.  A second
special slot name, \code{.xData}, is used to enable inheritance
from abnormal types such as \code{"environment"}
See the section on inheriting from non-S4 classes
for details on the representation and
for the behavior of S3 methods with objects from these classes.

Some slot names correspond to attributes used in old-style S3
objects and in \R{} objects without an explicit class, for
example, the \code{names} attribute.  If you define a class for
which that attribute will be set, such as a subclass of named
vectors, you should include \code{"names"} as a slot.  See the
definition of class \code{"namedList"} for an example.  Using the
\code{names()} assignment to set such names will generate a
warning if there is no names slot and an error if the object in
question is not a vector type.  A slot called \code{"names"} can
be used anywhere, but only if it is assigned as a slot, not via
the default \code{names()} assignment.


\item[Superclasses:] 

The definition of a class includes the \emph{superclasses} ---the
classes that this class extends.  A
class \code{Fancy}, say, extends a class \code{Simple} if an
object from the \code{Fancy} class has all the capabilities of
the \code{Simple} class (and probably some more as well).  In
particular, and very usefully, any method defined to work for a
\code{Simple} object can be applied to a \code{Fancy} object as
well.

This relationship is expressed equivalently by saying that
\code{Simple} is a superclass of \code{Fancy}, or that
\code{Fancy} is a subclass of \code{Simple}.

The direct superclasses of a class are those superclasses
explicitly defined.   Direct superclasses can be defined in
three ways.  Most commonly, the superclasses are listed in the
\code{contains=} argument in the call to \code{\LinkA{setClass}{setClass}}
that creates the subclass.   In this case the subclass will
contain all the slots of the superclass, and the relation
between the class is called \emph{simple}, as it in fact is.
Superclasses can also be defined
explicitly by a call to \code{\LinkA{setIs}{setIs}}; in this case, the
relation requires methods to be specified to go from subclass to
superclass.   Thirdly, a class union is a superclass of all the
members of the union.  In this case too the relation is simple,
but notice that the relation is defined when the superclass is
created, not when the subclass is created as with the
\code{contains=} mechanism.

The definition of a superclass will also potentially contain
its own direct superclasses.  These are considered (and shown) as
superclasses at distance 2 from the original class; their direct
superclasses are at distance 3, and so on.  All these are
legitimate superclasses for purposes such as method selection.

When superclasses are defined  by including the names of
superclasses in the \code{contains=} argument to
\code{\LinkA{setClass}{setClass}}, an object from the class will have all the
slots defined for its own class \emph{and} all the slots defined
for all its superclasses as well.

The information about the relation between a class and a
particular superclass is encoded as an object of class
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}}.  A list of such objects for
the superclasses (and sometimes for the subclasses) is included in
the metadata object defining the class.  If you need to compute
with these objects (for example, to compare the distances), call
the function \code{\LinkA{extends}{extends}} with argument \code{fullInfo=TRUE}.


\item[Prototype:] 

The objects from a class created by a call to
\code{\LinkA{new}{new}}
are defined by the \emph{prototype} object for the class and by
additional arguments in the call to \code{\LinkA{new}{new}}, which are
passed to a method for that class for the function
\code{\LinkA{initialize}{initialize}}.

Each class representation object contains a prototype object
for the class (although for a virtual class the prototype may be
\code{NULL}). The prototype object must have values for all the
slots of the class.
By default, these are the prototypes of the corresponding slot
classes.  However, the definition of the class can specify any
valid object for any of the slots.


\end{description}

\end{Section}
%
\begin{Section}{Virtual classes; Basic classes}

Classes exist for which no actual objects can be created by a
call to \code{\LinkA{new}{new}}, the
\emph{virtual} classes, in fact a
very important programming tool.  They are used to group together
ordinary classes that want to share some programming behavior,
without necessarily restricting how the behavior is implemented.
Virtual class definitions may if you want include
slots (to provide some common behavior without fully defining
the object---see the class \code{\LinkA{traceable}{traceable.Rdash.class}} for an example).

A simple and useful form of virtual class is the \emph{class
union}, a virtual class that is defined in a call to
\code{\LinkA{setClassUnion}{setClassUnion}} by listing one or
more of subclasses (classes that extend the class union).  Class
unions can include as subclasses basic object types (whose
definition is otherwise sealed).

There are a number of `basic' classes, corresponding to the
ordinary kinds of data occurring in R.  For example,
\code{"numeric"} is a class corresponding to numeric vectors.
The other vector basic classes are \code{"logical"}, \code{"integer"},
\code{"complex"}, \code{"character"},  \code{"raw"}, \code{"list"}
and \code{"expression"}.
The prototypes for
the vector classes are vectors of length 0 of the corresponding
type.  Notice that basic classes are unusual in that the
prototype object is from the class itself.

In addition to the vector classes there are also basic classes
corresponding to objects in the
language, such as \code{"function"} and \code{"call"}.
These classes are subclasses of the virtual class \code{"language"}.
Finally, there are object types and corresponding basic classes for
``abnormal'' objects, such as \code{"environment"} and
\code{"externalptr"}.
These objects do not follow the
functional behavior of the language; in particular, they are not
copied and so cannot have attributes or slots defined locally.

All these classes can be used as slots or as
superclasses for any other class definitions, although they do
not themselves come with an explicit class.  For the abnormal
object types, a special mechanism is used to enable inheritance
as described below.


\end{Section}
%
\begin{Section}{Inheriting from non-S4 Classes}
A class definition can extend classes other than
regular S4 classes, usually by specifying them in the
\code{contains=} argument to \code{\LinkA{setClass}{setClass}}.  Three groups
of such classes behave distinctly:
\begin{enumerate}

\item 
S3 classes, which must have been registered by a previous call to
\code{\LinkA{setOldClass}{setOldClass}} (you can check that this has been done
by calling \code{\LinkA{getClass}{getClass}}, which should return a class that
extends \LinkA{oldClass}{oldClass.Rdash.class});

\item 
One of the \R{} object types, typically a vector type, which then
defines the type of the S4 objects, but also a type such as
\code{\LinkA{environment}{environment}} that can not be used directly as a type
for an S4 object.  See
below.

\item 
One of the pseudo-classes \code{\LinkA{matrix}{matrix.Rdash.class}}
and \code{\LinkA{array}{array.Rdash.class}}, implying objects with
arbitrary vector types plus the \code{dim} and \code{dimnames}
attributes.

\end{enumerate}


This section describes the approach to combining S4 computations
with older S3 computations by using such classes as superclasses. The
design goal is to allow the S4 class to inherit S3 methods and
default computations in as consistent a form as possible.

As part of a general effort to make the S4 and S3 code in R more
consistent, when objects from an S4 class are used as the first
argument to a non-default S3 method, either for an S3 generic function
(one that calls \code{\LinkA{UseMethod}{UseMethod}}) or for one of the primitive
functions that dispatches S3 methods, an effort is made to provide a
valid object for that method.  In particular, if the S4 class extends
an S3 class or \code{matrix} or \code{array}, and there is an S3
method matching one of these classes, the S4 object will be coerced to
a valid S3 object, to the extent that is possible given that there is
no formal definition of an S3 class.

For example, suppose \code{"myFrame"} is an S4 class that includes the
S3 class \code{"data.frame"} in the \code{contains=} argument to
\code{\LinkA{setClass}{setClass}}.  If an object from this S4 class is passed to
a function, say \code{\LinkA{as.matrix}{as.matrix}}, that has an S3 method for
\code{"data.frame"}, the internal code for \code{\LinkA{UseMethod}{UseMethod}}
will convert the object to a data frame; in particular, to an S3
object whose class attribute will be the vector corresponding to the
S3 class (possibly containing multiple class names). Similarly for an
S4 object inheriting from \code{"matrix"} or \code{"array"}, the S4
object will be converted to a valid S3 matrix or array.

Note that the conversion is \emph{not} applied when an S4 object is
passed to the default S3 method.  Some S3 generics attempt to deal
with general objects, including S4 objects.  Also, no transformation
is applied to S4 objects that do not correspond to a selected S3
method; in particular, to objects from a class that does not contain
either an S3 class or one of the basic types.  See \code{\LinkA{asS4}{asS4}}
for the transformation details.

In addition to explicit S3 generic functions, S3 methods are
defined for a variety of operators and functions implemented as
primitives.  These methods are dispatched by some internal C
code that operates partly through the same code as real S3
generic functions and partly via special considerations (for
example, both arguments to a binary operator are examined when
looking for methods).  The same mechanism for adapting S4
objects to S3 methods has been applied to these computations as
well, with a few exceptions such as generating an error if an S4
object that does not extend an appropriate S3 class or type is
passed to a binary operator.

The remainder of this section discusses the mechanisms for
inheriting from  basic object types. See \code{\LinkA{matrix}{matrix.Rdash.class}}
or \code{\LinkA{array}{array.Rdash.class}}
for inhering from the matrix and array
pseudo-classes, or from time-series.  For the
corresponding details for inheritance
from S3 classes, see \code{\LinkA{setOldClass}{setOldClass}}.

An object from a class that directly and simply contains one
of the basic object types in \R{}, has implicitly a corresponding
\code{.Data} slot of that type, allowing computations to extract
or replace the data part while leaving other slots
unchanged. If the type is one that can accept attributes and is
duplicated normally, the inheritance also determines the type of the
object; if the class definition has a \code{.Data} slot
corresponding to a normal type, the class of the
slot determines the type of the object (that is, the value of
\code{\LinkA{typeof}{typeof}(x)}).
For such classes,  \code{.Data} is a pseudo-slot; that
is, extracting or setting it modifies the non-slot data in the
object.  The functions \code{\LinkA{getDataPart}{getDataPart}} and
\code{\LinkA{setDataPart}{setDataPart}} are a cleaner, but essentially
equivalent way to deal with the data part.

Extending a basic type this way allows objects to
use old-style code for the corresponding type as well as S4
methods.  Any basic type can be used for \code{.Data}, but
a few types are treated differently because they do not behave like ordinary objects;
for example, \code{"NULL"}, environments, and external pointers.
Classes extend these types by having a slot, \code{.xData},
itself inherited from an internally defined S4 class.  This
slot actually contains an object of the inherited type, to
protect computations from the reference semantics of the type.
Coercing to the nonstandard object type then requires an
actual computation, rather than the \code{"simple"} inclusion
for other types and classes.  The intent is that programmers
will not need to take account of the mechanism, but one
implication is that you should \emph{not} explicitly use the
type of an S4 object to detect inheritance from an arbitrary
object type.  Use
\code{\LinkA{is}{is}} and similar functions instead.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)

Chambers, John M.  and Hastie, Trevor  J. eds (1992)
\emph{Statistical Models in S.}
Wadsworth \& Brooks/Cole (Appendix A for S3 classes.)

Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
\emph{The New S Language}.
Wadsworth \& Brooks/Cole. (Out of print.) (The description of
vectors, matrix, array and time-series objects.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{Methods}{Methods}} for analogous discussion of methods,
\code{\LinkA{setClass}{setClass}} for details of specifying class definitions,
\code{\LinkA{is}{is}},
\code{\LinkA{as}{as}},
\code{\LinkA{new}{new}},
\code{\LinkA{slot}{slot}}
\end{SeeAlso}
\HeaderA{classesToAM}{Compute an Adjacency Matrix for Superclasses of Class Definitions}{classesToAM}
\keyword{classes}{classesToAM}
\keyword{programming}{classesToAM}
%
\begin{Description}\relax
Given a vector of class names or a list of class definitions, the
function returns an adjacency matrix of the superclasses of these
classes; that is, a matrix with class names as the row and column
names and with element [i, j] being 1 if the class in column j is a
direct superclass of the class in row i, and 0 otherwise.

The matrix has the information implied by the \code{contains} slot of
the class definitions, but in a form that is often more convenient for
further analysis; for example, an adjacency matrix is used in packages
and other software to construct graph representations of relationships.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
classesToAM(classes, includeSubclasses = FALSE,
       abbreviate = 2)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{classes}] 
Either a character vector of class names or a list, whose
elements can be either class names or class definitions.  The
list is convenient, for example, to include the package slot for
the class name. See the examples.

\item[\code{includeSubclasses}] 
A logical flag; if \code{TRUE}, then the matrix will include all
the known subclasses of the specified classes as well as the
superclasses.  The argument can also be a logical vector of the
same length as \code{classes}, to include subclasses for some
but not all the classes.

\item[\code{abbreviate}] 
Control of the abbreviation of the row and/or  column labels of
the matrix returned: values 0, 1, 2, or 3 abbreviate neither,
rows, columns or both.  The default, 2, is useful for printing
the matrix, since class names tend to be more than one
character long, making for spread-out printing.  Values of 0
or 3 would be appropriate for making a graph (3 avoids the
tendency of some graph plotting software to produce labels in
minuscule font size).

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
For each of the classes, the calculation gets all the superclass
names from the class definition, and finds the edges in those classes'
definitions; that is, all the superclasses at distance 1.  The
corresponding elements of the adjacency matrix are set to 1.

The adjacency matrices for the individual class definitions are
merged.  Note two possible kinds of inconsistency, neither of which
should cause problems except possibly with identically named classes from
different packages.  Edges are computed from each superclass
definition, so that information overrides a possible inference from
extension elements with distance > 1 (and it should).  When
matrices from successive classes in the argument are merged, the
computations do not currently check for inconsistencies---this is
the area where possible multiple classes with the same name could
cause confusion.  A later revision may include consistency checks.
\end{Details}
%
\begin{Value}
As described, a matrix with entries 0 or 1, non-zero values
indicating that the class corresponding to the column is a direct
superclass of the class corresponding to the row.  The row and
column names are the class names (without package slot).
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{extends}{extends}} and \LinkA{classRepresentation}{classRepresentation.Rdash.class} for the underlying information from the class
definition.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## the super- and subclasses of "standardGeneric"
## and "derivedDefaultMethod"
am <- classesToAM(list(class(show), class(getMethod(show))), TRUE)
am

## Not run: 
## the following function depends on the Bioconductor package Rgraphviz
plotInheritance <- function(classes, subclasses = FALSE, ...) {
    if(!require("Rgraphviz", quietly=TRUE))
      stop("Only implemented if Rgraphviz is available")
    mm <- classesToAM(classes, subclasses)
    classes <- rownames(mm); rownames(mm) <- colnames(mm)
    graph <-  new("graphAM", mm, "directed", ...)
    plot(graph)
    cat("Key:\n", paste(abbreviate(classes), " = ", classes, ", ",
        sep = ""),  sep = "", fill = TRUE)
    invisible(graph)
}

## The plot of the class inheritance of the package "graph"
require(graph)
plotInheritance(getClasses("package:graph"))


## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{className}{Class names including the corresponding package}{className}
\aliasA{className-class}{className}{className.Rdash.class}
\aliasA{multipleClasses}{className}{multipleClasses}
\keyword{classes}{className}
\keyword{programming}{className}
%
\begin{Description}\relax
The function \code{className()} generates a
valid references to a class, including the name of the package
containing the class definition.  The object returned, from class \code{"className"}, is the
unambiguous way to refer to a class, for example when calling
\code{\LinkA{setMethod}{setMethod}}, just in case multiple definitions of the
class exist.

Function
\code{"multipleClasses"} returns information about multiple
definitions of classes with the
same name from different packages.
\end{Description}
%
\begin{Usage}
\begin{verbatim}

className(class, package)

multipleClasses(details = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}

\item[\code{class, package}] 
The character string name of a class and, optionally, of the package
to which it belongs.  If argument \code{package} is missing and the
\code{class} argument has a package slot, that is used  (in
particular, passing in an object from class \code{"className"} returns
itself in this case, but changes the package slot if the second
argument is supplied).

If there is no package argument or slot, a
definition for the class must exist and will be used to define the
package.  If there are multiple definitions, one will be chosen and a
warning printed giving the other possibilities.


\item[\code{details}] 
If \code{FALSE}, the default, \code{multipleClasses()} returns a
character vector of those classes currently known with multiple
definitions.

If \code{TRUE}, a named list of those class definitions is returned.
Each element of the list is itself a list of the corresponding class
definitions, with the package names as the names of the list.  Note
that identical class definitions will not be considered
``multiple'' definitions (see the discussion of the details below).

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The table of class definitions used internally can maintain multiple
definitions for classes with the same name but coming from different
packages.
If identical class definitions are encountered, only one class
definition is kept; this occurs most often with S3 classes that have
been specified in calls to \code{\LinkA{setOldClass}{setOldClass}}.  For true
classes, multiple class definitions are unavoidable in general if two
packages happen to have used the same name, independently.

Overriding a class definition in another package with the same name deliberately is usually a bad
idea.
Although \R{} attempts to keep and use the two definitions (as of
version 2.14.0), ambiguities are always possible.  It is more
sensible to define a new class that extends an existing class but has
a different name.
\end{Details}
%
\begin{Value}
A call to \code{className()} returns an object from class
\code{"className"}.

A call to \code{multipleClasses()} returns either a character
vector or a named list of class definitions.  In either case, testing
the length of the returned value for being greater than \code{0} is a
check for the existence of multiply defined classes.
\end{Value}
%
\begin{Section}{Objects from the Class}
The class \code{"className"} extends \code{"character"} and has a slot
\code{"package"}, also of class \code{"character"}.
\end{Section}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
className("vector") # will be found, from package "methods"
className("vector", "magic") # OK, even though the class doesn't exist


className("An unknown class") # Will cause an error

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{classRepresentation-class}{Class Objects }{classRepresentation.Rdash.class}
\keyword{classes}{classRepresentation-class}
%
\begin{Description}\relax
  These are the objects that hold the definition of
classes of objects.  They are constructed and stored as meta-data by
calls to the function \code{\LinkA{setClass}{setClass}}.  Don't manipulate them
directly, except perhaps to look at individual slots. 
\end{Description}
%
\begin{Details}\relax
Class definitions are stored as metadata in various packages.
Additional metadata supplies information on inheritance (the result of
calls to \code{\LinkA{setIs}{setIs}}).  Inheritance information implied by the
class definition itself (because the class contains one or more other
classes) is also constructed automatically.

When a class is to be used in an R session, this information is
assembled to complete the class definition.  The completion is a
second object of class \code{"classRepresentation"}, cached for the
session or until something happens to change the information.  A call
to \code{\LinkA{getClass}{getClass}} returns the completed definition of a class;
a call to \code{\LinkA{getClassDef}{getClassDef}} returns the stored definition
(uncompleted).

In particular, completion fills in the upward- and downward-pointing
inheritance information for the class, in slots \code{contains} and
\code{subclasses} respectively.  It's in principle important to note
that this information can depend on which packages are installed,
since these may define additional subclasses or superclasses.
\end{Details}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{slots}:] A named list of the slots in this class; the
elements of the list are the classes to which the slots must
belong (or extend), and the names of the list gives the
corresponding slot names.
\item[\code{contains}:] A named list of the classes this class
`contains'; the elements of the list are objects of
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}}. The list may be only the
direct extensions or all the currently known extensions (see the
details).
\item[\code{virtual}:] Logical flag, set to \code{TRUE} if this is
a virtual class.
\item[\code{prototype}:] The object that represents the standard
prototype for this class; i.e., the data and slots returned by a
call to \code{\LinkA{new}{new}} for this class with no special
arguments.  Don't mess with the prototype object directly.
\item[\code{validity}:] Optionally, a function to be used to test
the validity of objects from this class.
See \code{\LinkA{validObject}{validObject}}.
\item[\code{access}:] Access control information.  Not currently used.
\item[\code{className}:] The character string name of the class.
\item[\code{package}:] The character string name of the package to
which the class belongs.  Nearly always the package on which the
metadata for the class is stored, but in operations such as
constructing inheritance information, the internal package name
rules.
\item[\code{subclasses}:] A named list of the classes known to
extend this class'; the elements of the list are objects of class
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}}.  The list is currently only
filled in when completing the class definition (see the details).
\item[\code{versionKey}:] Object of class \code{"externalptr"};
eventually will perhaps hold some versioning information, but not
currently used. 
\item[\code{sealed}:] Object of class \code{"logical"}; is this
class sealed?  If so, no modifications are allowed. 

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
See function \code{\LinkA{setClass}{setClass}} to supply the information in the
class definition.
See \LinkA{Classes}{Classes} for a more basic discussion of class information.
\end{SeeAlso}
\HeaderA{Documentation}{Using and Creating On-line Documentation for Classes and Methods}{Documentation}
\aliasA{Documentation-class}{Documentation}{Documentation.Rdash.class}
\aliasA{Documentation-methods}{Documentation}{Documentation.Rdash.methods}
\keyword{programming}{Documentation}
\keyword{methods}{Documentation}
\keyword{classes}{Documentation}
\keyword{documentation}{Documentation}
%
\begin{Description}\relax
Special documentation can be supplied to describe the
classes and methods that are created by the software in the methods
package.  Techniques to access this documentation and to create it
in R help files are described here.
\end{Description}
%
\begin{Section}{Getting documentation on classes and methods}
You can ask for on-line help for class definitions, for specific
methods for a generic function, and for general discussion of
methods for a generic function.  These requests use the \code{?}
operator (see \code{\LinkA{help}{help}} for a general description of
the operator).  Of course, you are at the mercy of the implementer
as to whether there \emph{is} any documentation on the corresponding
topics.

Documentation on a class uses the argument \code{class} on the left
of the \code{?}, and the name of the class on the right; for
example,

\code{class ? genericFunction}

to ask for documentation on the class \code{"genericFunction"}.

When you want documentation for the methods defined for a particular
function, you can ask either for a general discussion of the methods
or for documentation of a particular method (that is, the method that
would be selected for a particular set of actual arguments).

Overall methods documentation is requested by
calling the \code{?} operator with \code{methods} as the left-side
argument and the name of the function as the right-side argument. For
example,

\code{methods ? initialize}

asks for documentation on the methods for the \code{\LinkA{initialize}{initialize}}
function.

Asking for documentation on a particular method is done by giving a
function call expression as the right-hand argument to the \code{"?"}
operator.  There are two forms, depending on whether you prefer to
give the class names for the arguments or expressions that you intend
to use in the actual call.

If you planned to evaluate a function call, say \code{myFun(x, sqrt(wt))}
and wanted to find out something about the method that would be used
for this call, put the call on the right of the \code{"?"} operator:

\code{?myFun(x, sqrt(wt))}

A method will be selected, as it would be for the call itself, and
documentation for that method will be requested.  If \code{myFun} is
not a generic function, ordinary documentation for the function will
be requested.

If you know the actual classes for which you would like method
documentation, you can supply these explicitly in place of the
argument expressions.  In the example above, if you want method
documentation for the first argument having class \code{"maybeNumber"}
and the second \code{"logical"}, call the \code{"?"} operator, this
time with a left-side argument \code{method}, and with a function call
on the right using the class names as arguments:

\code{method ? myFun("maybeNumber", "logical")}

Once again, a method will be selected, this time corresponding to the
specified classes, and method documentation will be requested.  This
version only works with generic functions.

The two forms each have advantages.  The version with actual arguments
doesn't require you to figure out (or guess at) the classes of the
arguments.
On the other hand, evaluating the arguments may take some time,
depending on the example.
The version with class names does require you to pick classes, but
it's otherwise unambiguous.  It has a subtler advantage, in that the
classes supplied may be virtual classes, in which case no actual
argument will have specifically this class.  The class
\code{"maybeNumber"}, for example, might be a class union (see the
example for \code{\LinkA{setClassUnion}{setClassUnion}}).

In either form, methods will be selected as they would be in actual
computation, including use of inheritance and group generic
functions.  See \code{\LinkA{selectMethod}{selectMethod}} for the details, since it is
the function used to find the appropriate method.

\end{Section}
%
\begin{Section}{Writing Documentation for Methods}
The on-line documentation for methods and classes uses some extensions
to the R documentation format to implement the requests for class and
method documentation described above.  See the document \emph{Writing
R Extensions} for the available markup commands (you should
have consulted this document already if you are at the stage of
documenting your software).

In addition to the specific markup commands to be described, you can
create an initial, overall file with a skeleton of documentation for
the methods defined for a particular generic function:

\code{promptMethods("myFun")}

will create a file, \file{myFun-methods.Rd} with a skeleton of
documentation for the methods defined for function \code{myFun}.
The output from \code{promptMethods} is suitable if you want to
describe all or most of the methods for the function in one file,
separate from the documentation of the generic function itself.
Once the file has been filled in and moved to the \file{man}
subdirectory of your source package, requests for methods
documentation will use that file, both for specific methods
documentation as described above, and for overall documentation
requested by

\code{methods ? myFun}

You are not required to use \code{promptMethods}, and if you do, you
may not want to use the entire file created:
\begin{itemize}

\item If you want to document the methods in the file containing the
documentation for the generic function itself, you can
cut-and-paste to move the \AsIs{\bsl{}alias} lines and the
\code{Methods} section from the file created by
\code{promptMethods} to the existing file.

\item On the other hand, if these are auxiliary methods, and you only
want to document the added or modified software, you should strip
out all but the relevant \AsIs{\bsl{}alias} lines for the methods of
interest, and remove all but the corresponding \AsIs{\bsl{}item}
entries in the \code{Methods} section. Note that in this case you
will usually remove the first  \AsIs{\bsl{}alias} line as well, since
that is the marker for general methods documentation on this
function (in the example, \samp{\bsl{}alias\{myfun-methods\}}).

\end{itemize}


If you simply want to direct documentation for one or more methods to
a particular R documentation file, insert the appropriate alias.
\end{Section}
\HeaderA{dotsMethods}{The Use of \code{...} in Method Signatures}{dotsMethods}
\keyword{programming}{dotsMethods}
\keyword{classes}{dotsMethods}
\keyword{methods}{dotsMethods}
%
\begin{Description}\relax
The ``\dots'' argument in \R{} functions is treated specially, in that it
matches zero, one or more actual arguments (and so, objects).  A
mechanism has been added to \R{} to allow ``\dots'' as the signature of a
generic function.  Methods defined for such functions will be
selected and called when \emph{all}  the arguments matching ``\dots''
are from the specified class or from some subclass of that class.
\end{Description}
%
\begin{Section}{Using "..." in a Signature}
Beginning with version 2.8.0 of \R{}, S4 methods can be dispatched
(selected and called) corresponding to the special argument ``\dots''.
Currently, ``\dots'' cannot be mixed with other formal arguments:
either the signature of the generic function is ``\dots'' only, or it
does not contain ``\dots''.  (This restriction may be lifted in a future
version.)

Given a suitable generic function, methods are specified in the
usual way by a call to \code{\LinkA{setMethod}{setMethod}}.  The method
definition must be written expecting all the arguments corresponding
to ``\dots'' to be from the class specified in the method's signature,
or from a class that extends that class (i.e., a subclass of that
class).

Typically the methods will pass ``\dots'' down to another function or
will create a list of the arguments and iterate over that.  See the
examples below.

When you have a computation that is suitable for more than one existing
class, a convenient approach may be to define a union of these
classes by a call to \code{\LinkA{setClassUnion}{setClassUnion}}. See the example
below.

\end{Section}
%
\begin{Section}{Method Selection and Dispatch for "..."}
See \LinkA{Methods}{Methods} for a general discussion.  The following assumes
you have read the ``Method Selection and Dispatch'' section of
that documentation.

A method selecting on ``\dots'' is specified by a single class in the
call to \code{\LinkA{setMethod}{setMethod}}.  If all the actual arguments
corresponding to ``\dots'' have this class, the corresponding method is
selected directly.

Otherwise, the class of each argument and that class' superclasses are
computed, beginning with the first ``\dots'' argument.  For the first
argument, eligible methods are those for any of the classes.   For
each succeeding argument that introduces a class not considered previously, the eligible methods are further
restricted to those matching the argument's class or
superclasses. If no further eligible classes exist, the iteration
breaks out and the default method, if any, is selected.

At the end of the iteration, one or more methods may be eligible.
If more than one, the selection looks for the method with the least
distance to the actual arguments.  For each argument, any inherited
method corresponds to a distance, available from the \code{contains}
slot of the class definition.  Since the same class can arise for
more than one argument, there may be several distances associated
with it.  Combining them is inevitably arbitrary:  the current
computation uses the minimum distance.  Thus, for example, if a
method matched one argument directly, one as  first generation
superclass and another as a second generation superclass, the
distances are 0, 1 and 2.  The current selection computation would
use distance 0 for this
method.  In particular, this selection criterion tends to use a method that
matches exactly one or more of the arguments' class.

As with ordinary method selection, there may be multiple methods
with the same distance.  A warning  message is issued and one of the
methods is chosen (the first encountered, which in this case is
rather arbitrary).

Notice that, while the computation examines all arguments, the
essential cost of dispatch goes up with the number of
\emph{distinct} classes among the arguments, likely to be much
smaller than the number of arguments when the latter is large.

\end{Section}
%
\begin{Section}{Implementation Details}
Methods dispatching on ``\dots'' were introduced in version 2.8.0 of
\R{}.  The initial implementation of the corresponding selection and
dispatch is in an R function, for flexibility while the new
mechanism is being studied.  In this implementation, a local version
of \code{setGeneric} is inserted in the generic function's
environment.  The local version selects a method according to the
criteria above and calls that method, from the environment of the
generic function.  This is slightly different from the action taken
by the C implementation when ``\dots'' is not involved.  Aside from the
extra computing time required, the method is evaluated in a true
function call, as opposed to the special context constructed by the
C version (which cannot be exactly replicated in R code.)  However,
situations in which different computational results would
be obtained have not been encountered so far, and seem very
unlikely.

Methods dispatching on arguments other than ``\dots'' are \emph{cached} by storing
the inherited method in the table of all methods, where it will be
found on the next selection with the same combination of classes
in the actual arguments (but not used for inheritance searches).
Methods based on ``\dots'' are also cached, but not found quite
as immediately.  As noted, the selected method depends only on the
set of classes that occur in the ``\dots'' arguments.  Each of
these classes can appear one or more times, so many combinations of
actual argument classes will give rise to the same effective
signature.  The selection computation first computes and sorts the
distinct classes encountered.  This gives a label that will be
cached in the table of all methods, avoiding any further search for
inherited classes after the first occurrence.  A call to
\code{\LinkA{showMethods}{showMethods}} will expose such inherited methods.

The intention is that the ``\dots'' features will be added to the
standard C code when enough experience with them has been obtained.
It is possible that at the same time, combinations of ``\dots'' with
other arguments in signatures may be supported.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
For the general discussion of methods, see  \LinkA{Methods}{Methods} and links
from there.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
cc <- function(...)c(...)

setGeneric("cc")

setMethod("cc", "character", function(...)paste(...))

setClassUnion("Number", c("numeric", "complex"))

setMethod("cc", "Number", function(...) sum(...))

setClass("cdate", contains = "character", representation(date = "Date"))

setClass("vdate", contains = "vector", representation(date = "Date"))

cd1 <- new("cdate", "abcdef", date = Sys.Date())

cd2 <- new("vdate", "abcdef", date = Sys.Date())

stopifnot(identical(cc(letters, character(), cd1),
           paste(letters, character(), cd1))) # the "character" method

stopifnot(identical(cc(letters, character(), cd2),
                    c(letters, character(), cd2)))
# the default, because "vdate" doesn't extend "character"

stopifnot(identical(cc(1:10, 1+1i), sum(1:10, 1+1i))) # the "Number" method

stopifnot(identical(cc(1:10, 1+1i, TRUE), c(1:10, 1+1i, TRUE))) # the default

stopifnot(identical(cc(), c())) # no arguments implies the default method

setGeneric("numMax", function(...)standardGeneric("numMax"))

setMethod("numMax", "numeric", function(...)max(...))
# won't work for complex data
setMethod("numMax", "Number", function(...) paste(...))
# should not be selected w/o complex args

stopifnot(identical(numMax(1:10, pi, 1+1i), paste(1:10, pi, 1+1i)))
stopifnot(identical(numMax(1:10, pi, 1), max(1:10, pi, 1)))

try(numMax(1:10, pi, TRUE)) # should be an error:  no default method

## A generic version of paste(), dispatching on the "..." argument:
setGeneric("paste", signature = "...")

setMethod("paste", "Number", function(..., sep, collapse) c(...))

stopifnot(identical(paste(1:10, pi, 1), c(1:10, pi, 1)))


\end{ExampleCode}
\end{Examples}
\HeaderA{environment-class}{Class \code{"environment"}}{environment.Rdash.class}
\keyword{classes}{environment-class}
%
\begin{Description}\relax
 A formal class for R environments.
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects can be created by calls of the form \code{new("environment", ...)}.
The arguments in \dots, if any, should be named and will be assigned to
the newly created environment.
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[coerce] \code{signature(from = "ANY", to = "environment")}:
calls \code{\LinkA{as.environment}{as.environment}}. 
\item[initialize] \code{signature(object = "environment")}:
Implements the assignments in the new environment.  Note that the
\code{object} argument is ignored; a new environment is
\emph{always} created, since environments are not protected by copying. 

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
 \code{\LinkA{new.env}{new.env}} 
\end{SeeAlso}
\HeaderA{envRefClass-class}{Class \code{"envRefClass"}}{envRefClass.Rdash.class}
\aliasA{\$,envRefClass-method}{envRefClass-class}{.Rdol.,envRefClass.Rdash.method}
\aliasA{\$<\Rdash,envRefClass-method}{envRefClass-class}{.Rdol.<.Rdash.,envRefClass.Rdash.method}
\aliasA{initialize,envRefClass-method}{envRefClass-class}{initialize,envRefClass.Rdash.method}
\keyword{classes}{envRefClass-class}
%
\begin{Description}\relax
Support Class to Implement R Objects using Reference Semantics
\end{Description}
%
\begin{Section}{NOTE:}
The software described here is an initial version.  The eventual goal
is to support reference-style classes with software in \R{} itself
or using inter-system interfaces.  The current implementation (\R{}
version 2.12.0) is preliminary and subject to change, and currently
includes only the \R{}-only implementation.  Developers are encouraged
to experiment with the software, but the description here is more than
usually subject to change.
\end{Section}
%
\begin{Section}{Purpose of the Class}
This class implements basic reference-style semantics for \R{}
objects.  Objects normally do not come directly from this class, but
from subclasses defined by a call to \code{\LinkA{setRefClass}{setRefClass}}.
The documentation below is technical background describing the implementation, but applications
should use the interface documented under \code{\LinkA{setRefClass}{setRefClass}},
in particular the \code{\$} operator and field accessor functions as
described there.
\end{Section}
%
\begin{Section}{A Basic Reference Class}
The design of reference classes for \R{} divides those classes up
according to the mechanism used for implementing references, fields,
and class methods.
Each version of this mechanism is defined by a \emph{basic reference
class}, which must implement a set of methods and provide some
further information used by \code{\LinkA{setRefClass}{setRefClass}}.

The required methods are for operators \code{\$} and \code{\$<-} to
get and set a field in an object, and for \code{\LinkA{initialize}{initialize}} to
initialize objects.

To support these methods, the basic reference class needs to have some
implementation mechanism to store and retrieve data from fields in the
object.
The mechanism needs to be consistent with reference semantics; that
is, changes made to the contents of an object are global, seen by any
code accessing that object, rather than only local to the function
call where the change takes place.
As described below, class \code{envRefClass} implements reference
semantics through specialized use of \LinkA{environment}{environment.Rdash.class}
objects.
Other basic reference classes may use an interface to a language such
as Java or C++ using reference semantics for classes.

Usually, the \R{}  user will be able to invoke class methods on the
class, using the \code{\$} operator.  The basic reference class
method for \code{\$} needs to make this possible.  Essentially, the
operator must return an \R{} function corresponding to the object and
the class method name.

Class methods may include an implementation of data abstraction, in
the sense that fields are accessed by ``get'' and ``set''
methods.  The basic reference class provides this facility by setting
the \code{"fieldAccessorGenerator"} slot in its definition to a
function of one variable.
This function will be called by \code{\LinkA{setRefClass}{setRefClass}} with the
vector of field names as arguments.
The generator function must return a list of defined accessor
functions.
An element corresponding to a get operation is invoked with no
arguments and should extract the corresponding field; an element for a
set operation will be invoked with a single argument, the value to be
assigned to the field.
The implementation needs to supply the object, since that is not an
argument in the method invocation.
The mechanism used currently by \code{envRefClass} is described below.
\end{Section}
%
\begin{Section}{Support Classes}
Two virtual classes are supplied to test for reference objects:
\code{is(x, "refClass")} tests whether \code{x} comes from a class
defined using the reference class mechanism described here;
\code{is(x, "refObject")} tests whether the object has reference
semantics generally, including the previous classes and also classes
inheriting from the \R{} types with reference semantics, such as
\code{"environment"}.

Installed class methods are \code{"classMethodDefinition"} objects,
with slots that identify the name of the function as a class method
and the other class methods called from this method.
The latter information is determined heuristically when the class is
defined by using the \code{codetools} recommended package.  This
package must be installed when reference classes are defined, but is
not needed in order to use existing reference classes.
\end{Section}
%
\begin{Author}\relax
John Chambers
\end{Author}
\HeaderA{evalSource}{Use Function Definitions from a Source File without Reinstalling a Package}{evalSource}
\aliasA{insertSource}{evalSource}{insertSource}
\aliasA{sourceEnvironment-class}{evalSource}{sourceEnvironment.Rdash.class}
\keyword{programming}{evalSource}
\keyword{methods}{evalSource}
%
\begin{Description}\relax
Definitions of functions and/or methods from a source file are
inserted into a package, using the \code{\LinkA{trace}{trace}} mechanism.
Typically, this allows testing or debugging modified versions of a few
functions without reinstalling a large package.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
evalSource(source, package = "", lock = TRUE, cache = FALSE)

insertSource(source, package = "", functions = , methods = ,
           force = )

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{source}] 
A file to be parsed and evaluated by \code{evalSource} to find the new
function and method definitions.

The argument to \code{insertSource} can be an object of class \code{"sourceEnvironment"}
returned from a previous call
to \code{evalSource}   If a file name is passed to \code{insertSource}
it calls \code{evalSource} to obtain the corresponding object.  See
the section on the class for details.


\item[\code{package}] 
Optionally, the name of the package to which the new code corresponds
and into which it will be
inserted.  Although the computations will attempt to infer the package
if it is omitted, the safe approach is to supply it.  In the case of a
package that is not attached to the search list, the package name must
be supplied.

\item[\code{functions, methods}] 
Optionally, the character-string names of the functions to be
used in the insertion.  Names supplied in the \code{functions}
argument are expected to be defined as functions in the source.
For names supplied in the \code{methods} argument, a table of methods
is expected (as generated by calls to \code{\LinkA{setMethod}{setMethod}}, see the
details section); methods from this table will be inserted by
\code{insertSource}.  In both cases, the revised function or method is
inserted only if it differs from the version in the corresponding
package as loaded.

If \code{what} is omitted, the results of evaluating the source file
will be compared to the contents of the package (see the details section).

\item[\code{lock, cache}] 
Optional arguments to control the actions taken by \code{evalSource}.
If \code{lock} is \code{TRUE}, the environment in the object returned
will be locked, and so will all its bindings.
If \code{cache} is \code{FALSE}, the normal caching of method and
class definitions will be suppressed during evaluation of the
\code{source} file.

The default settings are generally recommended, the \code{lock} to
support the credibility of the object returned as a snapshot of the
source file, and the second so that method definitions can be inserted
later by \code{insertSource} using the trace mechanism.

\item[\code{force}] 
If \code{FALSE}, only functions currently in the environment will be
redefined, using \code{\LinkA{trace}{trace}}.  If \code{TRUE}, other
objects/functions will be simply assigned.  By default, \code{TRUE} if
neither the \code{functions} nor the \code{methods} argument is supplied.


\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The \code{source} file is parsed and evaluated, suppressing by default
the actual caching of method and class definitions contained in it, so
that functions and methods can be tested out in a reversible way.
The result, if all goes well, is an environment containing the
assigned objects and metadata corresponding to method and class definitions
in the source file.

From this environment, the objects are inserted into the package, into
its namespace if it has one, for use during the current session or
until reverting to the original version by a call to
\code{\LinkA{untrace}{untrace}}.
The insertion is done by calls to the internal version of
\code{\LinkA{trace}{trace}}, to make reversion possible.

Because the trace mechanism is used, only function-type objects will
be inserted, functions themselves or S4 methods.

When the \code{functions} and \code{methods} arguments are both
omitted, \code{insertSource} selects all suitable objects from the
result of evaluating the \code{source} file.

In all cases,
only objects in the source file that differ from
the corresponding objects in the package are inserted.
The definition of ``differ'' is that either the argument list
(including default expressions) or the body of the function is not
identical.
Note that in the case of a method, there need be no specific method
for the corresponding signature in the package: the comparison is made
to the method that would be selected for that signature.

Nothing in the computation requires that the source file supplied be
the same file as in the original package source, although that case is
both likely and sensible if one is revising the package.  Nothing in
the computations compares source files:  the objects generated by
evaluating \code{source} are compared as objects to the content of the package.
\end{Details}
%
\begin{Value}
An object from class \code{"sourceEnvironment"}, a subclass of
\code{"environment"} (see the section on the class)
The environment contains the versions
of \emph{all}  object resulting from evaluation of the source file.
The class also has slots for the time of creation, the source file
and the package name.
Future extensions may use these objects for versioning or other code tools.


The object returned can be used in debugging (see the section on that
topic) or as the \code{source}
argument in a future call to \code{insertSource}.  If only some of the
revised functions were inserted in the first call, others can be
inserted in a later call without re-evaluating the source file, by
supplying the environment and optionally suitable \code{functions}
and/or \code{methods} argument.
\end{Value}
%
\begin{Section}{Debugging}
Once a function or method has been inserted into a package by
\code{insertSource}, it can be studied by the standard debugging tools;
for example, \code{\LinkA{debug}{debug}} or the various versions of
\code{\LinkA{trace}{trace}}.

Calls to \code{\LinkA{trace}{trace}} should take the extra argument \code{edit
= env}, where \code{env} is the value returned by the call to
\code{evalSource}.
The trace mechanism has been used to install the revised version from
the source file, and supplying the argument ensures that it is this
version, not the original, that will be traced.  See the example
below.

To turn tracing off, but retain the source version, use \code{trace(x,
edit = env)} as in the example.  To return to the original version
from the package, use \code{untrace(x)}.
\end{Section}
%
\begin{Section}{Class "sourceEnvironment"}

Objects from this class can be treated as environments, to extract the
version of functions and methods generated by \code{evalSource}.
The objects also have the following slots:
\begin{description}

\item[\code{packageName}:]  The character-string name of the package
to which the source code corresponds.

\item[\code{dateCreated}:]  The date and time that the source file was
evaluated (usually from a call to \code{\LinkA{Sys.time}{Sys.time}}).

\item[\code{sourceFile}:]  The character-string name of the source file
used.

Note that using the environment does not change the \code{dateCreated}.

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
\code{\LinkA{trace}{trace}} for the underlying mechanism, and also for the
\code{edit=} argument that can be used for somewhat similar purposes;
that function and also \code{\LinkA{debug}{debug}} and
\code{\LinkA{setBreakpoint}{setBreakpoint}}, for techniques more oriented to
traditional debugging styles.
The present function is directly intended for the case that one is
modifying some of the source for an existing package, although it can
be used as well by inserting debugging code in the source (more useful
if the debugging involved is non-trivial).  As noted in the details
section, the source
file need not be the same one in the original package source.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## Suppose package P0 has a source file "all.R"
## First, evaluate the source, and from it
## insert the revised version of methods for summary()
  env <- insertSource("./P0/R/all.R", package = "P0",
     methods = "summary")
## now test one of the methods, tracing  the version from the source
  trace("summary", signature = "myMat", browser, edit = env)
## After testing, remove the browser() call but keep the source
  trace("summary", signature = "myMat", edit = env)
## Now insert all the (other) revised functions and methods
## without re-evaluating the source file.
## The package name is included in the object env.
  insertSource(env)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{findClass}{Computations with Classes}{findClass}
\aliasA{getClasses}{findClass}{getClasses}
\aliasA{isClass}{findClass}{isClass}
\aliasA{removeClass}{findClass}{removeClass}
\aliasA{resetClass}{findClass}{resetClass}
\aliasA{sealClass}{findClass}{sealClass}
\keyword{programming}{findClass}
\keyword{classes}{findClass}
\keyword{methods}{findClass}
%
\begin{Description}\relax
Functions to find and manipulate class definitions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
removeClass(Class, where)

isClass(Class, formal=TRUE, where)

getClasses(where, inherits = missing(where))

findClass(Class, where, unique = "")

resetClass(Class, classDef, where)

sealClass(Class, where)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] character string name for the class.  The functions will
usually take a class definition instead of the string.  To restrict
the class to those defined in a particular package, set the
\code{\LinkA{packageSlot}{packageSlot}} of the character string.
\item[\code{where}] the \code{\LinkA{environment}{environment}} in which to modify or
remove the definition.  Defaults to the top-level environment of the
calling function (the global environment for ordinary computations,
but the environment or namespace of a package in the source for a
package).

When searching for class definitions, \code{where} defines where to
do the search, and the default is to search from the top-level
environment or namespace of the caller to this function.

\item[\code{unique}] if \code{findClass} expects a unique location for the
class, \code{unique} is a character string explaining the purpose
of the search (and is used in warning and error messages).  By
default, multiple locations are possible and the function always
returns a list.

\item[\code{inherits}] in a call to \code{getClasses}, should the value
returned include all parent environments of \code{where}, or that
environment only?  Defaults to \code{TRUE} if \code{where} is
omitted, and to \code{FALSE} otherwise.

\item[\code{formal}]  Should a formal definition be required? 
\item[\code{classDef}]  For \code{removeClass}, the optional class
definition (but usually it's better for \code{Class} to be the
class definition, and to omit \code{classDef}).

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
These are the functions that test and manipulate formal class
definitions.  Brief documentation is provided below.  See the
references for an introduction and for more details.

\begin{description}

\item[\code{removeClass}:] 
Remove the definition of this class, from the environment
\code{where} if this argument is supplied; if not,
\code{removeClass} will search for a definition, starting in the
top-level environment of the call to \code{removeClass}, and
remove the (first) definition found.

\item[\code{isClass}:] 
Is this the name of a formally defined class? (Argument
\code{formal} is for compatibility and is ignored.)

\item[\code{getClasses}:] 
The names of all the classes formally defined on \code{where}.  If
called with no argument, all the classes visible from the
calling function (if called from the top-level, all the classes
in any of the environments on the search list).  The
\code{inherits} argument can be used to search a particular
environment and all its parents, but usually the default setting
is what you want.

\item[\code{findClass}:] 
The list of environments or positions on the search list in
which a class definition of \code{Class} is found.  If
\code{where} is supplied, this is an environment (or namespace)
from which the search takes place; otherwise the top-level
environment of the caller is used.  If \code{unique} is supplied
as a character string, \code{findClass} returns a single
environment or position.  By default, it always returns a list.
The calling function should select, say, the first element as a
position or environment for functions such as \code{\LinkA{get}{get}}.

If \code{unique} is supplied as a character string,
\code{findClass} will warn if there is more than one definition
visible (using the string to identify the purpose of the call),
and will generate an error if no definition can be found.

\item[\code{resetClass}:] 
Reset the internal definition of a class.  Causes the complete
definition of the class to be re-computed, from the
representation and superclasses specified in the original
call to \code{setClass}.

This function is called when aspects of the class definition are
changed.  You would need to call it explicitly if you changed the
definition of a class that this class extends (but doing that in
the  middle of a session is living dangerously, since it may
invalidate existing objects).

\item[\code{sealClass}:]  Seal the current definition of the specified
class, to prevent further changes.  It is possible to seal a class
in the call to \code{setClass}, but sometimes further changes have
to be made (e.g., by calls to \code{setIs}).  If so, call
\code{sealClass} after all the relevant changes have been made.


\end{description}

\end{Details}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setClassUnion}{setClassUnion}},
\code{\LinkA{Methods}{Methods}},
\code{\LinkA{makeClassRepresentation}{makeClassRepresentation}}
\end{SeeAlso}
\HeaderA{findMethods}{Description of the Methods Defined for a Generic Function}{findMethods}
\aliasA{findMethodSignatures}{findMethods}{findMethodSignatures}
\aliasA{getMethods}{findMethods}{getMethods}
\aliasA{hasMethods}{findMethods}{hasMethods}
\aliasA{listOfMethods-class}{findMethods}{listOfMethods.Rdash.class}
\keyword{programming}{findMethods}
\keyword{classes}{findMethods}
\keyword{methods}{findMethods}
%
\begin{Description}\relax
The function \code{findMethods} converts the methods defined in a table for a generic
function (as used for selection of methods) into a list, for study or
display.  The list is actually from the class \code{listOfMethods}
(see the section describing the class, below).  


The list will be limited
to the methods defined in environment \code{where} if that argument is
supplied and limited to those including one or more of the
specified \code{classes} in the method signature if that argument is
supplied.

To see the actual table (an environment) used
for methods dispatch, call \code{\LinkA{getMethodsForDispatch}{getMethodsForDispatch}}.
The names of the list returned by \code{findMethods} are the names of
the objects in the table.

The function \code{findMethodSignatures} returns a character matrix
whose rows are the class names from the signature of the corresponding
methods; it operates either from a list returned by
\code{findMethods}, or by computing such a list itself, given the same
arguments as \code{findMethods} .  

The function \code{hasMethods} returns \code{TRUE} or \code{FALSE}
according to whether there is a non-empty table of methods for
function \code{f} in the environment or search position \code{where}
(or for the generic function generally if \code{where} is missing).

The deprecated function \code{getMethods} is an older alternative to
\code{findMethods} , returning information in the form of an object of
class \code{MethodsList}, previously used for method dispatch.  It is
not recommended, since this class of objects is deprecated generally
and will disappear in a future version of R.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findMethods(f, where, classes = character(), inherited = FALSE,
      package = "")

findMethodSignatures(..., target = TRUE, methods = )

hasMethods(f, where, package)

### DEPRECATED
getMethods(f, where, table = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] A generic function or the character-string name of one.
\item[\code{where}] Optionally, an environment or position on the search list
to look for methods metadata.

If \code{where} is missing,  \code{findMethods} uses the current
table of methods in the generic function itself, and
\code{hasMethods} looks for metadata anywhere in the search list.

\item[\code{table}]  If \code{TRUE} in a call to \code{getMethods} the
returned value is the table used for dispatch, including
inherited methods discovered to date.  Used internally, but
since the default result is the now unused \code{mlist} object,
the default will likely be changed at some point.

\item[\code{classes}] If supplied, only methods whose signatures contain at
least one of the supplied classes will be included in the value
returned.
\item[\code{inherited}] Logical flag; if \code{TRUE}, the table of all
methods, inherited or defined directly, will be used; otherwise,
only the methods explicitly defined.  Option \code{TRUE} is
meaningful only if \code{where} is missing.

\item[\code{...}] In the call to \code{findMethodSignatures}, any arguments
that might be given to \code{findMethods}.
\item[\code{target}] Optional flag to \code{findMethodSignatures}; if
\code{TRUE}, the signatures used are the target signatures (the
classes for which the method will be selected); if \code{FALSE},
they will be the signatures are defined.  The difference is only
meaningful if \code{inherited} is \code{TRUE}.
\item[\code{methods}] In the call to \code{findMethodSignatures}, an optional
list of methods, presumably returned by a previous call to
\code{findMethods}.  If missing, that function will be call with the
\dots arguments.

\item[\code{package}] In a call to \code{hasMethods}, the package name for
the generic function (e.g., \code{"base"} for primitives).  If
missing this will be inferred either from the \code{"package"}
attribute of the function name, if any, or from the package slot of
the generic function.  See `Details'.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax

The functions obtain a table of the defined methods, either from the
generic function or from the stored metadata object in the environment
specified by \code{where}.  In a call to \code{getMethods}, the information in the table is converted
as described above to produce the returned value, except with the
\code{table} argument.


Note that \code{hasMethods}, but not the other functions, can be used
even if no generic function of this name is currently found.  In this
case \code{package} must either be supplied as an argument or included
as an attribute of \code{f}, since the package name is part of the
identification of the methods tables.


\end{Details}
%
\begin{Section}{The Class for lists of methods}
The class \code{"listOfMethods"} returns the methods as a named list
of method definitions (or a primitive function, see the slot
documentation below).  The names
are the strings used to store the corresponding objects in the
environment from which method dispatch is computed.
The current implementation uses the names of the corresponding classes
in the method signature, separated by \code{"\#"} if more than one
argument is involved in the signature.
\end{Section}
%
\begin{Section}{Slots}

\begin{description}

\item[\code{.Data}:] Object of class \code{"list"} The method
definitions.

Note that these may include the primitive function
itself as  default method,
when the generic corresponds to a primitive. (Basically, because
primitive functions are abnormal R objects, which cannot currently be
extended as method definitions.) Computations that use the returned
list to derive other information need to take account of this
possibility. See the implementation of \code{findMethodSignatures}
for an example.

\item[\code{arguments}:] Object of class \code{"character"}.  The
names of the formal arguments in the signature of the generic function. 
\item[\code{signatures}:] Object of class \code{"list"}. A list of
the signatures of the individual methods.  This is currently the
result of splitting the \code{names} according to the \code{"\#"}
separator.

If the object has been constructed from a table, as when returned by
\code{findMethods}, the signatures will all have the same length.
However, a list rather than a character matrix is used for
generality.  Calling \code{findMethodSignatures} as in the example
below will always convert to the matrix form.
\item[\code{generic}:] Object of class \code{"genericFunction"}.
The generic function corresponding to these methods.  There
are plans to generalize this slot to allow reference to the function.
\item[\code{names}:] Object of class \code{"character"}.  The
names as noted are the class names separated by \code{"\#"} .

\end{description}

\end{Section}
%
\begin{Section}{Extends}

Class \code{"\LinkA{namedList}{namedList.Rdash.class}"}, directly.

Class \code{"\LinkA{list}{list.Rdash.class}"}, by class \code{"namedList"}, distance 2.

Class \code{"\LinkA{vector}{vector.Rdash.class}"}, by class \code{"namedList"}, distance 3.
\end{Section}
%
\begin{SeeAlso}\relax
 \code{\LinkA{showMethods}{showMethods}}, \code{\LinkA{selectMethod}{selectMethod}}, \LinkA{Methods}{Methods} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
mm <-  findMethods("Ops")
findMethodSignatures(methods = mm)
\end{ExampleCode}
\end{Examples}
\HeaderA{fixPre1.8}{Fix Objects Saved from R Versions Previous to 1.8}{fixPre1.8}
\keyword{classes}{fixPre1.8}
\keyword{programming}{fixPre1.8}
%
\begin{Description}\relax
Beginning with R version 1.8.0, the class of an object contains the
identification of the package in which the class is defined.  The
function \code{fixPre1.8} fixes and re-assigns objects missing that information
(typically because they were loaded from a file saved with a previous
version of R.)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fixPre1.8(names, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{names}]  Character vector of the names of all the objects to be
fixed and re-assigned.
\item[\code{where}] The environment from which to look for the objects, and
for class definitions.  Defaults to the top environment of the
call to \code{fixPre1.8}, the global environment if the function
is used interactively.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The named object will be saved where it was found.  Its class
attribute will be changed to the full form required by R 1.8;
otherwise, the contents of the object should be unchanged.

Objects will be fixed and re-assigned only if all the following
conditions hold:
\begin{enumerate}

\item The named object exists.
\item It is from a defined class (not a basic datatype which
has no actual class attribute).
\item The object appears to be from an earlier version of R.
\item The class is currently defined.
\item The object is consistent with the current class definition.

\end{enumerate}

If any condition except the second fails, a warning message is
generated.

Note that \code{fixPre1.8} currently fixes \emph{only} the change in
class attributes.  In particular, it will not fix binary versions of
packages installed with earlier versions of R if these use
incompatible features.  Such packages must be re-installed from
source, which is the wise approach always when major version changes
occur in R.

\end{Details}
%
\begin{Value}
The names of all the objects that were in fact re-assigned.
\end{Value}
\HeaderA{genericFunction-class}{Generic Function Objects }{genericFunction.Rdash.class}
\aliasA{groupGenericFunction-class}{genericFunction-class}{groupGenericFunction.Rdash.class}
\keyword{classes}{genericFunction-class}
%
\begin{Description}\relax
Generic functions (objects from or extending class
\code{genericFunction}) are extended function objects,
containing information used in creating and dispatching methods for
this function.  They also identify the package associated with the
function and its methods.
\end{Description}
%
\begin{Section}{Objects from the Class}
Generic functions are created and assigned by
\code{\LinkA{setGeneric}{setGeneric}} or \code{\LinkA{setGroupGeneric}{setGroupGeneric}} and, indirectly, by
\code{\LinkA{setMethod}{setMethod}}.

As you might expect \code{\LinkA{setGeneric}{setGeneric}} and
\code{\LinkA{setGroupGeneric}{setGroupGeneric}} create objects of class
\code{"genericFunction"} and \code{"groupGenericFunction"} respectively.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"function"}, the
function definition of the generic, usually created
automatically as a call to \code{\LinkA{standardGeneric}{standardGeneric}}. 
\item[\code{generic}:] Object of class \code{"character"}, the
name of the generic function. 
\item[\code{package}:] Object of class \code{"character"}, the
name of the package to which the function definition belongs
(and \emph{not} necessarily where the generic function is
stored). If the package is not specified explicitly in the
call to \code{setGeneric}, it is usually the package on which
the corresponding non-generic function exists. 
\item[\code{group}:] Object of class \code{"list"}, the group or
groups to which this generic function belongs.  Empty by default. 
\item[\code{valueClass}:] Object of class \code{"character"}; if
not an empty character vector, identifies one or more classes.  It is
asserted that all methods for this function return objects
from these class (or from classes that extend them). 
\item[\code{signature}:] Object of class \code{"character"}, the
vector of formal argument names that can appear in the
signature of methods for this generic function.  By default,
it is all the formal arguments, except for \dots.  Order
matters for efficiency:  the most commonly used arguments in
specifying methods should come first. 
\item[\code{default}:] Object of class \code{"optionalMethod"}
(a union of classes \code{"function"} and \code{"NULL"}), containing
the default method for this function if any.  Generated
automatically and used to initialize method dispatch. 
\item[\code{skeleton}:] Object of class \code{"call"}, a slot used
internally in method dispatch.  Don't expect to use it
directly.

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"function"}, from data part.\\{}
Class \code{"OptionalMethods"}, by class \code{"function"}.\\{}
Class \code{"PossibleMethod"}, by class \code{"function"}.
\end{Section}
%
\begin{Section}{Methods}
Generic function objects are used in the creation and dispatch of
formal methods; information from the object is used to create methods
list objects and to merge or update the existing methods for this
generic.
\end{Section}
\HeaderA{GenericFunctions}{Tools for Managing Generic Functions}{GenericFunctions}
\aliasA{dumpMethod}{GenericFunctions}{dumpMethod}
\aliasA{dumpMethods}{GenericFunctions}{dumpMethods}
\aliasA{findFunction}{GenericFunctions}{findFunction}
\aliasA{getGenerics}{GenericFunctions}{getGenerics}
\aliasA{isGeneric}{GenericFunctions}{isGeneric}
\aliasA{isGroup}{GenericFunctions}{isGroup}
\aliasA{removeGeneric}{GenericFunctions}{removeGeneric}
\aliasA{removeMethods}{GenericFunctions}{removeMethods}
\aliasA{setReplaceMethod}{GenericFunctions}{setReplaceMethod}
\aliasA{signature}{GenericFunctions}{signature}
\keyword{programming}{GenericFunctions}
\keyword{classes}{GenericFunctions}
\keyword{methods}{GenericFunctions}
%
\begin{Description}\relax
The functions documented here manage collections of methods associated
with a generic function, as well as providing information about the
generic functions themselves.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
isGeneric(f, where, fdef, getName = FALSE)
isGroup(f, where, fdef)
removeGeneric(f, where)

dumpMethod(f, signature, file, where, def)
findFunction(f, generic = TRUE, where = topenv(parent.frame()))
dumpMethods(f, file, signature, methods, where)
signature(...)

removeMethods(f, where = topenv(parent.frame()), all = missing(where))

setReplaceMethod(f, ..., where = topenv(parent.frame()))

getGenerics(where, searchForm = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}]  The character string naming the function. 
\item[\code{where}]  The environment, namespace, or search-list position
from which to search for objects.  By default, start at the
top-level environment of the calling function, typically the global
environment (i.e., use the search list), or the namespace of a
package from which the call came.  It is important to supply this
argument when calling any of these functions indirectly.  With
package namespaces, the default is likely to be wrong in such calls.

\item[\code{signature}]  The class signature of the relevant method.  A
signature is a named or unnamed vector of character strings.  If
named, the names must be formal argument names for the generic
function.  Signatures are matched to the arguments specified in
the signature slot of the generic function (see the Details
section of the \code{\LinkA{setMethod}{setMethod}} documentation). 

The \code{signature} argument to \code{dumpMethods} is ignored (it
was used internally in previous implementations).

\item[\code{file}]  The file or connection on which to dump method definitions. 

\item[\code{def}]  The function object defining the method; if omitted, the
current method definition corresponding to the signature. 

\item[\code{...}] Named or unnamed arguments to form a signature.

\item[\code{generic}] In testing or finding functions, should generic
functions be included.  Supply as \code{FALSE} to get only
non-generic functions.

\item[\code{fdef}] Optional, the generic function definition.

Usually omitted in calls to \code{isGeneric}

\item[\code{getName}] If \code{TRUE}, \code{isGeneric} returns the name of
the generic.  By default, it returns \code{TRUE}. 
\item[\code{methods}] 
The methods object containing the methods to be dumped.  By default,
the methods defined for this generic (optionally on the specified
\code{where} location).

\item[\code{all}] in \code{removeMethods}, logical indicating if all
(default) or only the first method found should be removed.
\item[\code{searchForm}] In \code{getGenerics}, if \code{TRUE}, the
\code{package} slot of the returned result is in the form used
by \code{search()}, otherwise as the simple package name (e.g,
\code{"package:base"} vs \code{"base"}).

\end{ldescription}
\end{Arguments}
%
\begin{Section}{Summary of Functions}
\begin{description}

\item[\code{isGeneric}:] 
Is there a function named \code{f}, and if so, is it a generic?

The \code{getName} argument allows a function to find the name
from a function definition.  If it is \code{TRUE} then the name of
the generic is returned, or \code{FALSE} if this is not a generic
function definition.

The behavior of \code{isGeneric} and \code{\LinkA{getGeneric}{getGeneric}} for
primitive functions is slightly different.  These functions don't
exist as formal function objects (for efficiency and historical
reasons), regardless of whether methods have been defined for
them.  A call to \code{isGeneric} tells you whether methods have
been defined for this primitive function, anywhere in the current
search list, or in the specified position \code{where}.  In
contrast, a call to \code{\LinkA{getGeneric}{getGeneric}} will return what the
generic for that function would be, even if no methods have been
currently defined for it.


\item[\code{removeGeneric}, \code{removeMethods}:] 
Remove all the methods for the generic function of this
name.  In addition, \code{removeGeneric} removes the function
itself; \code{removeMethods} restores the non-generic function
which was the default method.   If there was no default method,
\code{removeMethods} leaves a generic function with no methods.

\item[\code{standardGeneric}:] 
Dispatches a method from the current function call for the generic
function \code{f}.  It is an error to call
\code{standardGeneric} anywhere except in the body of the
corresponding generic function.

Note that \code{\LinkA{standardGeneric}{standardGeneric}} is a primitive function in
the \pkg{base} package
for efficiency 
reasons, but rather documented here where it belongs naturally.

\item[\code{dumpMethod}:] 
Dump the method for this generic function and signature.

\item[\code{findFunction}:] 
return a list of either the positions on the search list, or the
current top-level environment, on which a function object
for \code{name} exists.  The returned value is \emph{always} a
list, use the first element to access the first visible version
of the function.  See the example.

\emph{NOTE:} Use this rather than \code{\LinkA{find}{find}} with
\code{mode="function"}, which is not as meaningful, and has a few
subtle bugs from its use of regular expressions.  Also,
\code{findFunction} works correctly in the code for a package
when attaching the package via a call to \code{\LinkA{library}{library}}.

\item[\code{dumpMethods}:] 
Dump all the methods for this generic.

\item[\code{signature}:] 
Returns a named list of classes to be matched to arguments of a
generic function.

\item[\code{getGenerics}:] returns the names of the generic
functions that have methods defined on \code{where}; this
argument can be an environment or an index into the search
list.  By default, the whole search list is used.

The methods definitions are stored with
package qualifiers; for example, methods for function
\code{"initialize"} might refer to two different functions
of that name, on different packages.  The package names
corresponding to the method list object are contained in the
slot \code{package} of the returned object.  The form of
the returned name can be plain (e.g., \code{"base"}), or in
the form used in the search list (\code{"package:base"})
according to the value of \code{searchForm}


\end{description}

\end{Section}
%
\begin{Section}{Details}
\begin{description}

\item[\code{setGeneric}:] 
If there is already a non-generic function of this name, it will
be used to define the generic unless \code{def} is supplied, and
the current function will become the default method for the
generic.

If \code{def} is supplied, this defines the generic function, and
no default method will exist (often a good feature, if the
function should only be available for a meaningful subset of all
objects).

Arguments \code{group} and \code{valueClass} are retained for
consistency with S-Plus, but are currently not used.

\item[\code{isGeneric}:] 
If the \code{fdef} argument is supplied, take this as the
definition of the generic, and test whether it is really a
generic, with \code{f} as the name of the generic.  (This argument
is not available in S-Plus.)

\item[\code{removeGeneric}:] 
If \code{where} supplied, just remove the version on this element
of the search list; otherwise, removes the first version
encountered.

\item[\code{standardGeneric}:] 
Generic functions should usually have a call to
\code{standardGeneric} as their entire body.  They can, however,
do any other computations as well.

The usual \code{setGeneric} (directly or through calling
\code{setMethod}) creates a function with a call to
\code{standardGeneric}.

\item[\code{dumpMethod}:] 
The resulting source file will recreate the method.

\item[\code{findFunction}:] 
If \code{generic} is \code{FALSE}, ignore generic functions.

\item[\code{dumpMethods}:] 
If \code{signature} is supplied only the methods matching this
initial signature are dumped.  (This feature is not found in
S-Plus:  don't use it if you want compatibility.)

\item[\code{signature}:] 
The advantage of using \code{signature} is to provide a check on
which arguments you meant, as well as clearer documentation in
your method specification.  In addition, \code{signature} checks
that each of the elements is a single character string.

\item[\code{removeMethods}:] 
Returns \code{TRUE} if \code{f} was a generic function,
\code{FALSE} (silently) otherwise.

If there is a default method, the function will be re-assigned as
a simple function with this definition.
Otherwise, the generic function remains but with no methods (so
any call to it will generate an error).  In either case, a
following call to \code{setMethod} will consistently
re-establish the same generic function as before.


\end{description}

\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{getMethod}{getMethod}} (also for \code{selectMethod}),
\code{\LinkA{setGeneric}{setGeneric}},
\code{\LinkA{setClass}{setClass}},
\code{\LinkA{showMethods}{showMethods}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
require(stats) # for lm

## get the function "myFun" -- throw an error if 0 or > 1 versions visible:
findFuncStrict <- function(fName) {
  allF <- findFunction(fName)
  if(length(allF) == 0)
    stop("No versions of ",fName," visible")
  else if(length(allF) > 1)
    stop(fName," is ambiguous: ", length(allF), " versions")
  else
    get(fName, allF[[1]])
}

try(findFuncStrict("myFun"))# Error: no version
lm <- function(x) x+1
try(findFuncStrict("lm"))#    Error: 2 versions
findFuncStrict("findFuncStrict")# just 1 version
rm(lm)



## method dumping ------------------------------------

setClass("A", representation(a="numeric"))
setMethod("plot", "A", function(x,y,...){ cat("A meth\n") })
dumpMethod("plot","A", file="")
## Not run: 
setMethod("plot", "A",
function (x, y, ...)
{
    cat("AAAAA\n")
}
)

## End(Not run)
tmp <- tempfile()
dumpMethod("plot","A", file=tmp)
## now remove, and see if we can parse the dump
stopifnot(removeMethod("plot", "A"))
source(tmp)
stopifnot(is(getMethod("plot", "A"), "MethodDefinition"))

## same with dumpMethods() :
setClass("B", contains="A")
setMethod("plot", "B", function(x,y,...){ cat("B ...\n") })
dumpMethods("plot", file=tmp)
stopifnot(removeMethod("plot", "A"),
          removeMethod("plot", "B"))
source(tmp)
stopifnot(is(getMethod("plot", "A"), "MethodDefinition"),
          is(getMethod("plot", "B"), "MethodDefinition"))
\end{ExampleCode}
\end{Examples}
\HeaderA{getClass}{Get Class Definition }{getClass}
\aliasA{getClassDef}{getClass}{getClassDef}
\keyword{programming}{getClass}
\keyword{classes}{getClass}
%
\begin{Description}\relax
Get the definition of a class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getClass(Class, .Force = FALSE, where)
getClassDef(Class, where, package, inherits = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}]  the character-string name of the class, often with a
\code{"package"} attribute as noted below under \code{package}.
\item[\code{.Force}]  if \code{TRUE}, return \code{NULL} if the class is
undefined; otherwise, an undefined class results in an error.
\item[\code{where}]  environment from which to begin the search for the definition; by default,
start at the top-level (global) environment and proceed through
the search list.
\item[\code{package}]  the name of the package asserted to hold the
definition.  If it is a non-empty string it is used instead of
\code{where}, as the first place to look for the class.
Note that the package must be loaded but need not be attached.  By
default, the package attribute of the \code{Class} argument is
used, if any.  There will usually be a package attribute if
\code{Class} comes from \code{class(x)} for some object.

\item[\code{inherits}]  Should the class definition be retrieved from any
enclosing environment and also from the cache?  If \code{FALSE}
only a definition in the environment \code{where} will be returned.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Class definitions are stored in metadata objects in a package
namespace or other environment where they are defined.  When
packages are loaded, the class definitions in the package are cached in an internal
table.  Therefore, most calls to \code{getClassDef} will find the
class in the cache or fail to find it at all, unless \code{inherits}
is \code{FALSE}, in which case only the environment(s) defined by
\code{package} or \code{where} are searched.

The class cache allows for multiple definitions of the
same class name in separate environments, with of course the
limitation that the package attribute or package name must be
provided in the call to 

\end{Details}
%
\begin{Value}
The object defining the class. If the class definition is not found,
\code{getClassDef} returns \code{NULL}, while \code{getClass}, which
calls \code{getClassDef}, either generates an error or, if
\code{.Force} is \code{TRUE}, returns a simple definition for the
class.  The latter case is used internally, but is not typically
sensible in user code.

The non-null returned value is an object of class
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}.  For all reasonable
purposes, use this object only to extract information, rather than trying
to modify it: Use functions such as \code{\LinkA{setClass}{setClass}} and
\code{\LinkA{setIs}{setIs}} to create or modify class definitions.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\LinkA{Classes}{Classes},
\code{\LinkA{setClass}{setClass}},
\code{\LinkA{isClass}{isClass}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
getClass("numeric") ## a built in class

cld <- getClass("thisIsAnUndefinedClass", .Force = TRUE)
cld ## a NULL prototype
## If you are really curious:
utils::str(cld)
## Whereas these generate errors:
try(getClass("thisIsAnUndefinedClass"))
try(getClassDef("thisIsAnUndefinedClass"))
\end{ExampleCode}
\end{Examples}
\HeaderA{getMethod}{ Get or Test for the Definition of a Method }{getMethod}
\aliasA{existsMethod}{getMethod}{existsMethod}
\aliasA{findMethod}{getMethod}{findMethod}
\aliasA{hasMethod}{getMethod}{hasMethod}
\aliasA{selectMethod}{getMethod}{selectMethod}
\keyword{programming}{getMethod}
\keyword{classes}{getMethod}
\keyword{methods}{getMethod}
%
\begin{Description}\relax
Functions to look for a method corresponding to a given generic function and signature.
The functions \code{getMethod} and \code{selectMethod} return the method; the functions \code{existsMethod}
and \code{hasMethod} test for its existence.  In both
cases the first function only gets direct definitions and the second
uses inheritance.  In all cases, the search is in the generic function itself or in the package/environment specified by argument \code{where}.

The function \code{findMethod} returns the package(s) in the search
list (or in the packages specified by the \code{where} argument) that
contain a method for this function and signature.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getMethod(f, signature=character(), where, optional = FALSE,
          mlist, fdef)

existsMethod(f, signature = character(), where)

findMethod(f, signature, where)

selectMethod(f, signature, optional = FALSE, useInherited =,
             mlist = , fdef = , verbose = , doCache = , returnAll =)

hasMethod(f, signature=character(), where)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] A  generic function or the character-string name of one.
\item[\code{signature}] the signature of classes to match to the arguments
of \code{f}.  See the details below.


\item[\code{where}] The position or environment in which to look for the
method(s):  by default, the table of methods defined in the generic function itself is used.

\item[\code{optional}] If the selection in \code{selectMethod} does not find a valid method
an error is generated, unless this argument is \code{TRUE}.  In that
case, the value returned is \code{NULL} if no method matches.
\item[\code{mlist, fdef, useInherited, verbose, doCache, returnAll}] Optional
arguments  to  \code{getMethod} and \code{selectMethod} for
internal use.  Avoid
these: some will work as expected and others will not, and none of them is required for normal use of the functions.


\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The \code{signature} argument specifies classes, corresponding to formal arguments of the generic function; to be precise, to the \code{signature} slot of the generic function object.
The argument may be a vector of strings identifying
classes, and may be named or not.  Names, if supplied, match the
names of those formal arguments included in the signature of the
generic.  That signature is normally all the arguments except
\dots.  However, generic functions can be specified with only a
subset of the arguments permitted, or with the signature taking
the arguments in a different order.

It's a good idea to name the arguments in the signature to avoid
confusion, if you're dealing with a generic that does something
special with its signature.   In any case, the elements of the
signature are matched to the formal signature by the same rules
used in matching arguments in function calls (see
\code{\LinkA{match.call}{match.call}}).

The strings in the signature may be class names, \code{"missing"}
or \code{"ANY"}.  See \LinkA{Methods}{Methods} for the meaning of these in
method selection.  Arguments not supplied in the signature
implicitly correspond to class \code{"ANY"}; in particular, giving
an empty signature means to look for the default method.

A call to \code{getMethod} returns the method for a particular
function and signature.  As with other \code{get} functions,
argument \code{where} controls where the function looks (by default
anywhere in the search list) and argument \code{optional} controls
whether the function returns \code{NULL} or generates an error if
the method is not found.  The search for the method makes no use of
inheritance.

The function \code{selectMethod} also looks for a method given the
function and signature, but makes full use of the method dispatch
mechanism; i.e., inherited methods and group generics are taken into
account just as they would be in dispatching a method for the
corresponding signature, with the one exception that conditional
inheritance is not used.  Like \code{getMethod}, \code{selectMethod}
returns \code{NULL} or generates an error if
the method is not found, depending on the argument \code{optional}.

The functions \code{existsMethod} and \code{hasMethod} return
\code{TRUE} or \code{FALSE} according to whether a method is found,
the first corresponding to \code{getMethod} (no inheritance) and the
second to \code{selectMethod}.

\end{Details}
%
\begin{Value}
The call to \code{selectMethod} or \code{getMethod} returns  the selected method, if
one is found.
(This class extends \code{function}, so you can use the result
directly as a function if that is what you want.)
Otherwise an error is thrown if \code{optional} is \code{FALSE}  and  \code{NULL} is returned if
\code{optional} is \code{TRUE}.

The returned method object is a
\code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} object, \emph{except} that the default method for a primitive function is required to be the primitive itself.
Note therefore that the only reliable test that the search failed is \code{is.null()}.

\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{Methods}{Methods}} for the details of method
selection; \code{\LinkA{GenericFunctions}{GenericFunctions}} for other functions
manipulating methods and generic function objects;
\code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} for the class that represents
method definitions.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setGeneric("testFun", function(x)standardGeneric("testFun"))
setMethod("testFun", "numeric", function(x)x+1)
hasMethod("testFun", "numeric")
## Not run: [1] TRUE
hasMethod("testFun", "integer") #inherited
## Not run: [1] TRUE
existsMethod("testFun", "integer")
## Not run: [1] FALSE
hasMethod("testFun") # default method
## Not run: [1] FALSE
hasMethod("testFun", "ANY")
## Not run: [1] FALSE

\end{ExampleCode}
\end{Examples}
\HeaderA{getPackageName}{The Name associated with a Given Package}{getPackageName}
\aliasA{packageSlot}{getPackageName}{packageSlot}
\aliasA{packageSlot<\Rdash}{getPackageName}{packageSlot<.Rdash.}
\aliasA{setPackageName}{getPackageName}{setPackageName}
\keyword{programming}{getPackageName}
%
\begin{Description}\relax
The functions below produce the package associated with a particular
environment or position on the search list, or of the package
containing a particular function.  They are primarily used to support
computations that need to differentiate objects on multiple packages.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
getPackageName(where, create = TRUE)
setPackageName(pkg, env)

packageSlot(object)
packageSlot(object) <- value
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{where}] the environment or position on the search list
associated with the desired package.
\item[\code{object}] object providing a character string name, plus the
package in which this object is to be found.
\item[\code{value}] the name of the package.
\item[\code{create}] flag, should a package name be created if none can be
inferred?  If \code{TRUE} and no non-empty package name is found,
the current date and time are used as a package name, and a
warning is issued. The created name is stored in the environment
if that environment is not locked.
\item[\code{pkg, env}] make the string in \code{pkg} the internal
package name for all computations that set class and method
definitions in environment \code{env}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Package names are normally installed during loading of the package,
by the \LinkA{INSTALL}{INSTALL} script or by the \code{\LinkA{library}{library}}
function.  (Currently, the name is stored as the object
\code{.packageName} but don't trust this for the future.)
\end{Details}
%
\begin{Value}
\code{packageName} returns the character-string name of the package
(without the extraneous \code{"package:"} found in the search list).

\code{packageSlot} returns or sets the package name slot (currently
an attribute, not a formal slot, but this may change someday).

\code{setPackageName} can be used to establish a package name in an
environment that would otherwise not have one.  This
allows you to create classes and/or methods in an arbitrary
environment, but it is usually preferable to create packages by the
standard \R{} programming tools (\code{\LinkA{package.skeleton}{package.skeleton}}, etc.)
\end{Value}
%
\begin{SeeAlso}\relax
 \code{\LinkA{search}{search}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## all the following usually return "base"
getPackageName(length(search()))
getPackageName(baseenv())
getPackageName(asNamespace("base"))
getPackageName("package:base")

\end{ExampleCode}
\end{Examples}
\HeaderA{hasArg}{Look for an Argument in the Call}{hasArg}
\keyword{programming}{hasArg}
%
\begin{Description}\relax
Returns \code{TRUE} if \code{name} corresponds to an argument in the
call, either a formal argument to the function, or a component of
\code{...}, and \code{FALSE} otherwise.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
hasArg(name)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] The unquoted name of a potential argument.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The expression \code{hasArg(x)}, for example, is similar to
\code{!missing(x)}, with two exceptions.  First,  \code{hasArg} will look for
an argument named \code{x} in the call if \code{x} is not a formal
argument to the calling function, but \code{...} is.  Second,
\code{hasArg} never generates an error if given a name as an argument,
whereas \code{missing(x)} generates an error if \code{x} is not a
formal argument.
\end{Details}
%
\begin{Value}
Always \code{TRUE} or \code{FALSE} as described above.
\end{Value}
%
\begin{SeeAlso}\relax
 \code{\LinkA{missing}{missing}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
ftest <- function(x1, ...) c(hasArg(x1), hasArg(y2))

ftest(1) ## c(TRUE, FALSE)
ftest(1, 2)  ## c(TRUE, FALSE)
ftest(y2=2)   ## c(FALSE, TRUE)
ftest(y=2)    ## c(FALSE, FALSE) (no partial matching)
ftest(y2 = 2, x=1)  ## c(TRUE, TRUE) partial match x1


\end{ExampleCode}
\end{Examples}
\HeaderA{implicitGeneric}{Manage Implicit Versions of Generic Functions}{implicitGeneric}
\aliasA{implicit generic}{implicitGeneric}{implicit generic}
\aliasA{prohibitGeneric}{implicitGeneric}{prohibitGeneric}
\aliasA{registerImplicitGenerics}{implicitGeneric}{registerImplicitGenerics}
\aliasA{setGenericImplicit}{implicitGeneric}{setGenericImplicit}
\keyword{programming}{implicitGeneric}
\keyword{methods}{implicitGeneric}
%
\begin{Description}\relax
Create or access implicit generic functions, used to enforce
consistent generic versions of functions that are not currently
generic.  Function \code{implicitGeneric()} returns the implicit
generic version, \code{setGenericImplicit()} turns a generic implicit,
\code{prohibitGeneric()} prevents your function from being made
generic, and \code{registerImplicitGenerics()} saves a set of implicit
generic definitions in the cached table of the current session.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
implicitGeneric(name, where, generic)
setGenericImplicit(name, where, restore = TRUE)
prohibitGeneric(name, where)
registerImplicitGenerics(what, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}]  Character string name of the function.
\item[\code{where}]  Package or environment in which to register the implicit
generics.  When using the functions from the top level of your own
package source, this argument can usually be omitted (and should
be).
\item[\code{generic}]  Optionally, the generic function definition to be
cached, but usually omitted.   See Details section.
\item[\code{restore}] Should the non-generic version of the function be
restored after the current.
\item[\code{what}] For \code{registerImplicitGenerics()}, Optional table of
the implicit generics to register, but nearly always omitted.   See
Details section.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Multiple packages may define methods for the same function, using the
version of a function stored in one package.  All these methods should
be marshaled and dispatched consistently when a user calls the
function.  For consistency, the generic version of the function must
have a unique definition (the same arguments allowed in methods
signatures, the same values for optional slots such as the value
class, and the same standard or non-standard definition of the
function itself).

If the original function is already an S4 generic, there is no
problem.  The implicit generic mechanism enforces consistency when the
version in the package owning the function is \emph{not} generic.  If
a call to \code{\LinkA{setGeneric}{setGeneric}()} attempts to turn a function in
another package into a generic, the mechanism compares the proposed
new generic function to the implicit generic version of that
function. If the two agree, all is well. If not, and if the function
belongs to another package, then the new generic will not be
associated with that package.  Instead, a warning is issued and a
separate generic function is created, with its package slot set to the
current package, not the one that owns the non-generic version of the
function. The effect is that the new package can still define methods
for this function, but it will not share the methods in other
packages, since it is forcing a different definition of the generic
function.

The right way to proceed in nearly all cases is to call
\code{\LinkA{setGeneric}{setGeneric}("foo")}, giving \emph{only} the name of the
function; this will automatically use the implicit generic version.
If you don't like that version, the best solution is to convince the
owner of the other package to agree with you and to insert code to
define the non-default properties of the function (even if the owner
does not want \code{foo()} to be a generic by default).

For any function, the implicit generic form is a standard generic in
which all formal arguments, except for \code{...}, are allowed in
the signature of methods. If that is the suitable generic for a
function, no action is needed. If not, the best mechanism is to set up
the generic in the code of the package owning the function, and to
then call \code{setGenericImplicit()} to record the implicit generic
and restore the non-generic version.  See the example.

Note that the package can define methods for the implicit generic as
well; when the implicit generic is made a real generic, those methods
will be included.

Other than predefining  methods, the usual reason for having a
non-default implicit generic is to provide a non-default signature,
and the usual reason for \emph{that} is to allow lazy evaluation of
some arguments.  See the example.  All arguments in the signature of a
generic function must be evaluated at the time the function needs to
select a method.  (But those arguments can be missing, with or without
a default expression being defined; you can always examine
\code{missing(x)} even for arguments in the signature.)

If you want to completely prohibit anyone from turning your function
into a generic, call \code{prohibitGeneric()}.
\end{Details}
%
\begin{Value}
Function \code{implicitGeneric()} returns the implicit generic
definition (and caches that definition the first time if it has to
construct it).

The other functions exist for their side effect and return nothing
useful.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{setGeneric}{setGeneric}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

### How we would make the function \link{with}() into a generic:

## Since the second argument, 'expr' is used literally, we want
## with() to only have "data" in the signature.

## Note that 'methods'-internal code now has already extended  with()
## to do the equivalent of the following
## Not run: 
setGeneric("with", signature = "data")
## Now we could predefine methods for "with" if we wanted to.

## When ready, we store the generic as implicit, and restore the original
setGenericImplicit("with")

## (This example would only work if we "owned" function with(),
##  but it is in base.)
## End(Not run)

implicitGeneric("with")
\end{ExampleCode}
\end{Examples}
\HeaderA{inheritedSlotNames}{Names of Slots Inherited From a Super Class}{inheritedSlotNames}
\keyword{classes}{inheritedSlotNames}
\keyword{methods}{inheritedSlotNames}
%
\begin{Description}\relax
For a class (or class definition, see \code{\LinkA{getClass}{getClass}} and
the description of class \code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}),
give the names which are inherited from ``above'', i.e., super
classes, rather than by this class' definition itself.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
inheritedSlotNames(Class, where = topenv(parent.frame()))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] character string or
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}, i.e., resulting from
\code{\LinkA{getClass}{getClass}}.
\item[\code{where}] environment, to be passed further to
\code{\LinkA{isClass}{isClass}} and \code{\LinkA{getClass}{getClass}}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
character vector of slot names, or \code{\LinkA{NULL}{NULL}}.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{slotNames}{slotNames}}, \code{\LinkA{slot}{slot}}, \code{\LinkA{setClass}{setClass}}, etc.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
.srch <- search()
library(stats4)
inheritedSlotNames("mle")


## Not run: 
if(require("Matrix")) {
  print( inheritedSlotNames("Matrix") ) # NULL
  ## whereas
  print( inheritedSlotNames("sparseMatrix") ) # --> Dim & Dimnames
  ##  i.e. inherited from "Matrix" class

  print( cl <- getClass("dgCMatrix") ) # six slots, etc

  print( inheritedSlotNames(cl) ) # *all* six slots are inherited
}


## detach package we've attached above:
for(n in rev(which(is.na(match(search(), .srch)))))
    detach(pos = n)

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{initialize-methods}{Methods to Initialize New Objects from a Class}{initialize.Rdash.methods}
\aliasA{initialize,.environment-method}{initialize-methods}{initialize,.environment.Rdash.method}
\aliasA{initialize,ANY-method}{initialize-methods}{initialize,ANY.Rdash.method}
\aliasA{initialize,environment-method}{initialize-methods}{initialize,environment.Rdash.method}
\aliasA{initialize,signature-method}{initialize-methods}{initialize,signature.Rdash.method}
\aliasA{initialize,traceable-method}{initialize-methods}{initialize,traceable.Rdash.method}
\keyword{methods}{initialize-methods}
\keyword{programming}{initialize-methods}
%
\begin{Description}\relax
The arguments to function \code{\LinkA{new}{new}} to create an object from a
particular class can be interpreted specially for that class, by the
definition of a method for function \code{initialize} for the class.
This documentation describes some existing methods, and also outlines
how to write new ones.
\end{Description}
%
\begin{Section}{Methods}
\begin{description}

\item[\code{signature(.Object = "ANY")}] 
The default method for \code{initialize} takes either named or
unnamed arguments.  Argument names must be the names of slots in
this class definition, and the corresponding arguments must be
valid objects for the slot (that is, have the same class as
specified for the slot, or some superclass of that class).  If the
object comes from a superclass, it is not coerced strictly, so
normally it will retain its current class (specifically,
\code{\LinkA{as}{as}(object, Class, strict = FALSE)}).

Unnamed arguments must be objects of this class, of one of its
superclasses, or one of its subclasses (from the class, from a
class this class extends, or from a class that extends this
class). If the object is from a superclass, this normally defines
some of the slots in the object.  If the object is from a
subclass, the new object is that argument, coerced to the current
class.

Unnamed arguments are processed first, in the order they appear.
Then named arguments are processed.  Therefore, explicit values
for slots always override any values inferred from superclass or
subclass arguments.


\item[\code{signature(.Object = "traceable")}] 
Objects of a class that extends \code{traceable} are used to
implement debug tracing (see class \LinkA{traceable}{traceable.Rdash.class} and
\code{\LinkA{trace}{trace}}).

The \code{initialize} method for these classes takes special
arguments \code{def, tracer, exit, at, print}.  The first of these
is the object to use as the original definition (e.g., a
function).  The others correspond to the arguments to
\code{\LinkA{trace}{trace}}.


\item[\code{signature(.Object = "environment")}, \code{signature(.Object = ".environment")}] 
The \code{initialize} method for environments takes a named list
of objects to be used to initialize the environment.  Subclasses
of \code{"environment"} inherit an initialize method through
\code{".environment"}, which has the additional effect of
allocating a new environment.  If you define your own method for
such a subclass, be sure either to call the existing method via
\code{\LinkA{callNextMethod}{callNextMethod}} or allocate an environment in your
method, since environments are references and are not duplicated
automatically.


\item[\code{signature(.Object = "signature")}] 
This is a method for internal use only.
It takes an optional \code{functionDef} argument to provide a
generic function with a \code{signature} slot to define the
argument names.  See \LinkA{Methods}{Methods} for details.


\end{description}

\end{Section}
%
\begin{Section}{Writing Initialization Methods}
Initialization methods provide a general mechanism corresponding to
generator functions in other languages.

The arguments to \code{\LinkA{initialize}{initialize}} are \code{.Object} and
\dots. Nearly always, \code{initialize} is called from \code{new},
not directly.  The \code{.Object} argument is then the
prototype object from the class.

Two techniques are often appropriate for \code{initialize} methods:
special argument names and \code{callNextMethod}.

You may want argument names that are more natural to your users than
the (default) slot names.  These will be the formal arguments to
your method definition, in addition to \code{.Object} (always) and
\dots (optionally).  For example, the method for class
\code{"traceable"} documented above would be created by a call to
\code{\LinkA{setMethod}{setMethod}} of the form:

\begin{alltt}    setMethod("initialize", "traceable",
      function(.Object, def, tracer, exit, at, print) ...
    )
\end{alltt}


In this example, no other arguments are meaningful, and the resulting
method will throw an error if other names are supplied.

When your new class extends another class, you may want to call the
initialize method for this superclass (either a special method or the
default).  For example, suppose you want to define a method for your
class, with special argument \code{x}, but you also want users to be
able to set slots specifically.  If you want \code{x} to override the
slot information, the beginning of your method definition might look
something like this:

\begin{alltt}    function(.Object, x, ...) \{
      Object <- callNextMethod(.Object, ...)
      if(!missing(x)) \{ # do something with x
\end{alltt}


You could also choose to have the inherited method override, by first
interpreting \code{x}, and then calling the next method.

\end{Section}
\HeaderA{is}{Is an Object from a Class?}{is}
\aliasA{extends}{is}{extends}
\aliasA{setIs}{is}{setIs}
\keyword{programming}{is}
\keyword{classes}{is}
\keyword{methods}{is}
%
\begin{Description}\relax
Functions to test inheritance relationships between an object and a
class (\code{is}) or between two classes (\code{extends}), and to
establish such relationships (\code{setIs}, an explicit alternative
to the \code{contains=} argument to \code{\LinkA{setClass}{setClass}}).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
is(object, class2)

extends(class1, class2, maybe = TRUE, fullInfo = FALSE)

setIs(class1, class2, test=NULL, coerce=NULL, replace=NULL,
      by = character(), where = topenv(parent.frame()), classDef =,
      extensionObject = NULL, doComplete = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] any \R{} object.
\item[\code{class1, class2}] 
the names of the classes between which \code{is} relations are to be
examined defined, or (more efficiently) the class definition
objects for the classes.

\item[\code{maybe, fullInfo}] 
In a call to \code{extends}, \code{maybe} is the value returned if
a relation is conditional. In a call with \code{class2} missing,
\code{fullInfo} is a flag, which if \code{TRUE} causes a list of
objects of class \code{classExtension} to be returned, rather than
just the names of the classes.

\item[\code{coerce, replace}] 
In a call to \code{setIs}, functions optionally supplied to coerce the object to
\code{class2}, and to alter the object so that \code{is(object, class2)}
is identical to \code{value}.  See the details section below.

\item[\code{test}] 
In a call to \code{setIs}, a \emph{conditional} relationship is
defined by supplying this function.  Conditional relations are
discouraged and are not included in selecting methods.  See the details section below.

The remaining arguments are for internal use and/or usually omitted.

\item[\code{extensionObject}]  alternative to the \code{test, coerce,
    replace, by} arguments; an object from class
\code{SClassExtension} describing the relation.  (Used in internal calls.)

\item[\code{doComplete}] when \code{TRUE}, the class definitions will be
augmented with indirect relations as well.  (Used in internal calls.)
\item[\code{by}] 
In a call to \code{setIs}, the name of an intermediary class.
Coercion will proceed by first coercing to this class and from there
to the target class.  (The intermediate coercions have to be valid.)
\item[\code{where}] 
In a call to \code{setIs}, where to store the metadata defining the
relationship.  Default is the global environment for calls from the
top level of the session or a source file evaluated there.  When the
call occurs in the top level of a file in the source of a package,
the default will be the namespace or environment of the package.
Other uses are tricky and not usually a good idea, unless you really
know what you are doing.
\item[\code{classDef}] 
Optional class definition for \code{class} , required internally
when \code{setIs} is called during the initial definition of the
class by a call to \code{\LinkA{setClass}{setClass}}. \emph{Don't} use this
argument, unless you really know why you're doing so.
\end{ldescription}
\end{Arguments}
%
\begin{Section}{Summary of Functions}
\begin{description}

\item[\code{is}:] 
With two arguments, tests whether \code{object} can be treated as from
\code{class2}.

With one argument, returns all the super-classes of this object's class.

\item[\code{extends}:] 
Does the first class extend the second class?
The call returns \code{maybe} if the extension includes a test.

When called with one argument, the value is a vector of the
superclasses of \code{class1}.  If argument \code{fullInfo}  is
\code{TRUE}, the call returns a named list of objects of class
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}}; otherwise, just the names of
the superclasses.

\item[\code{setIs}:] 
Defines \code{class1} to be an extension (subclass) of
\code{class2}.
If \code{class2} is an existing virtual class, such as a class
union, then only the two classes need to be supplied in the
call, if the implied inherited methods work for \code{class1}.
See the details section below.

Alternatively, arguments \code{coerce} and \code{replace} should
be supplied, defining methods to coerce to the superclass and to
replace the part corresponding to the superclass. As discussed in
the details and other sections below, this form is often less
recommended than the corresponding call to \code{\LinkA{setAs}{setAs}}, to
which it is an alternative.

Argument \code{test} allows conditional inheritance, in which
the \code{is()} result is tested for each object rather than
being determined by the class definition.  This form is
discouraged when it can be avoided; in particular, note that
conditional inheritance is \emph{not} used to select methods for
dispatch.


\end{description}

\end{Section}
%
\begin{Section}{Details}
Arranging for a class to inherit from another class is a key tool in
programming.  In \R{}, there are three basic techniques, the first two
providing what is called  ``simple'' inheritance, the preferred form:

\begin{enumerate}

\item 
By the \code{contains=} argument in a call to \code{\LinkA{setClass}{setClass}}.  This
is and should be the most common mechanism.  It arranges that the new
class contains all the structure of the existing class, and in
particular all the slots with the same class specified.  The
resulting class extension is defined to be \code{simple}, with
important implications for method definition (see the section on
this topic below).

\item 
Making \code{class1} a subclass of a virtual class
either by a call to \code{\LinkA{setClassUnion}{setClassUnion}} to make the
subclass a member of a new class union, or by a call to
\code{setIs} to add a class to an existing class union or as a new
subclass of an existing virtual class.  In either case, the
implication should be that methods defined for the class union or
other superclass all work correctly for the subclass.  This may
depend on some similarity in the structure of the subclasses or
simply indicate that the superclass methods are defined in terms
of generic functions that apply to all the subclasses.  These
relationships are also generally simple.


\item 
Supplying \code{coerce}  and \code{replace} arguments to \code{setAs}.
\R{} allows arbitrary inheritance relationships, using the same
mechanism for defining coerce methods by a call to
\code{\LinkA{setAs}{setAs}}.  The difference between the  two is simply
that \code{\LinkA{setAs}{setAs}} will require a call to \code{\LinkA{as}{as}}
for a conversion to take place, whereas after the call to
\code{\LinkA{setIs}{setIs}}, objects will be automatically converted to
the superclass.

The automatic feature is the dangerous part, mainly because it
results in the subclass potentially inheriting methods that do
not work.  See the section on inheritance below.  If the two
classes involved do not actually inherit a large collection of
methods, as in the first example below, the danger may be
relatively slight.

If the superclass inherits methods where the subclass has only a
default or remotely inherited method, problems are more likely.
In this case, a general
recommendation is to use the \code{\LinkA{setAs}{setAs}} mechanism
instead, unless there is a strong counter reason. Otherwise, be prepared to
override some of  the methods inherited.

\end{enumerate}


With this caution given, the rest of this section describes what
happens when \code{coerce=} and \code{replace=} arguments are supplied
to \code{setIs}.

The \code{coerce} and \code{replace} arguments are functions that
define how to coerce a \code{class1} object to \code{class2}, and
how to replace the part of the subclass object that corresponds to
\code{class2}.  The first of these is a function of one argument
which should be \code{from}, and the second of two arguments
(\code{from}, \code{value}).  For details, see the section on coerce
functions below .

When \code{by} is specified, the coerce process first coerces to
this class and then to \code{class2}.  It's unlikely you
would use the \code{by} argument directly, but it is used in defining
cached information about classes.

The value returned (invisibly) by
\code{setIs} is the revised class definition of \code{class1}.
\end{Section}
%
\begin{Section}{Coerce, replace, and test functions}

The  \code{coerce} argument is a function that turns a
\code{class1} object into a \code{class2} object.  The
\code{replace} argument is a function of two arguments that modifies a \code{class1}
object (the first argument) to replace the part of it that
corresponds to \code{class2} (supplied as \code{value}, the second
argument).  It then returns the modified object as the value of the
call.  In other words, it acts as a replacement method to
implement the expression \code{as(object, class2) <- value}.

The easiest way to think of the  \code{coerce} and \code{replace}
functions is by thinking of the case that  \code{class1}
contains \code{class2} in the usual sense, by including the slots of
the second class.  (To repeat, in this situation you would not call
\code{setIs}, but the analogy shows what happens when you do.)

The \code{coerce} function in this case would just make a
\code{class2} object by extracting the corresponding slots from the
\code{class1} object. The \code{replace} function would replace in
the \code{class1} object the slots corresponding to \code{class2},
and return the modified object as its value.

For additional discussion of these functions, see
the documentation of the
\code{\LinkA{setAs}{setAs}} function.  (Unfortunately, argument
\code{def} to that function corresponds to argument \code{coerce} here.)

The inheritance relationship can also be conditional, if a function is supplied as the
\code{test} argument.  This should be a function of one argument
that returns \code{TRUE} or \code{FALSE} according to whether the
object supplied satisfies the relation \code{is(object, class2)}.
Conditional relations between
classes are discouraged in general because they require a per-object
calculation to determine their validity. They cannot be applied
as efficiently as ordinary relations and tend to make the code that
uses them harder to interpret.  \emph{NOTE:  conditional inheritance
is not used to dispatch methods.}  Methods for conditional
superclasses will not be inherited.  Instead, a method for the
subclass should be defined that tests the conditional relationship.
\end{Section}
%
\begin{Section}{Inherited methods}
A method written for a particular signature (classes matched to one
or more formal arguments to the function) naturally assumes that the
objects corresponding to the arguments can be treated as coming from
the corresponding classes.  The objects will have all the slots and
available methods for the classes.

The code that selects and dispatches the methods ensures that this
assumption is correct.  If the inheritance was ``simple'', that
is, defined by one or more uses of the \code{contains=} argument in
a call to \code{\LinkA{setClass}{setClass}}, no extra work is generally
needed.  Classes are inherited from the superclass, with the same
definition.

When inheritance is defined by a general call to
\code{setIs}, extra computations are required.  This form of
inheritance implies that the subclass does \emph{not} just contain
the slots of the superclass, but instead requires the explicit call
to the coerce and/or replace method.  To ensure correct computation,
the inherited method is supplemented by calls to \code{\LinkA{as}{as}}
before the body of the method is evaluated.

The calls to \code{\LinkA{as}{as}} generated in this case have the
argument \code{strict = FALSE}, meaning that extra information can
be left in the converted object, so long as it has all the
appropriate slots.  (It's this option that allows simple subclass
objects to be used without any change.)  When you are writing your
coerce method, you may want to take advantage of that option.

Methods inherited through non-simple extensions can result in ambiguities
or unexpected selections.  If \code{class2} is a specialized class
with just a few applicable methods, creating the inheritance
relation may have little effect on the behavior of \code{class1}.
But if \code{class2} is a class with many methods, you may
find that you now inherit some undesirable methods for
\code{class1}, in some cases, fail to inherit expected methods.
In the second example below, the non-simple inheritance from class
\code{"factor"} might be assumed to inherit S3 methods via that
class.  But the S3 class is ambiguous, and in fact is
\code{"character"} rather than \code{"factor"}.

For some generic functions, methods inherited by non-simple
extensions are either known to be invalid or sufficiently likely to
be so that the generic function has been defined to exclude such
inheritance.  For example \code{\LinkA{initialize}{initialize}} methods must
return an object of the target class; this is straightforward if the
extension is simple, because no change is made to the argument
object, but is essentially impossible.  For this reason, the generic
function insists on only simple extensions for inheritance.  See the
\code{simpleInheritanceOnly} argument to \code{\LinkA{setGeneric}{setGeneric}}
for the mechanism.  You can use this mechanism when defining new
generic functions.

If you get into problems with functions that do allow non-simple
inheritance, there are two basic choices.  Either
back off from the \code{setIs} call and settle for explicit coercing
defined by a call to \code{\LinkA{setAs}{setAs}}; or, define explicit
methods involving \code{class1} to override the bad inherited
methods.  The first choice is the safer, when there are serious
problems.

\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{inherits}{inherits}} is nearly always equivalent to
\code{is}, both for S4 and non-S4 objects, and is somewhat faster.
The non-equivalence applies to classes that have conditional
superclasses, with a non-trivial \code{test=} in the relation (not
common and discouraged):  for these, \code{is} tests for the
relation but \code{inherits} by definition ignores conditional
inheritance for S4 objects.


\code{\LinkA{selectSuperClasses}{selectSuperClasses}(cl)} has similar semantics as
\code{extends(cl)}, typically returning subsets of the latter.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## Two examples of setIs() with coerce= and replace= arguments
## The first one works fairly well, because neither class has many
## inherited methods do be disturbed by the new inheritance

## The second example does NOT work well, because the new superclass,
## "factor", causes methods to be inherited that should not be.

## First example:
## a class definition (see \link{setClass} for class "track")
setClass("trackCurve", contains = "track",
         representation( smooth = "numeric"))
## A class similar to "trackCurve", but with different structure
## allowing matrices for the "y" and "smooth" slots
setClass("trackMultiCurve",
         representation(x="numeric", y="matrix", smooth="matrix"),
         prototype = structure(list(), x=numeric(), y=matrix(0,0,0),

                               smooth= matrix(0,0,0)))
## Automatically convert an object from class "trackCurve" into
## "trackMultiCurve", by making the y, smooth slots into 1-column matrices
setIs("trackCurve",
      "trackMultiCurve",
      coerce = function(obj) {
        new("trackMultiCurve",
            x = obj@x,
            y = as.matrix(obj@y),
            smooth = as.matrix(obj@smooth))
      },
      replace = function(obj, value) {
        obj@y <- as.matrix(value@y)
        obj@x <- value@x
        obj@smooth <- as.matrix(value@smooth)
        obj})




## Second Example:
## A class that adds a slot to "character"
setClass("stringsDated", contains = "character",
         representation(stamp="POSIXt"))

## Convert automatically to a factor by explicit coerce
setIs("stringsDated", "factor",
      coerce = function(from) factor(from@.Data),
      replace= function(from, value) {
                  from@.Data <- as.character(value); from })

ll <- sample(letters, 10, replace = TRUE)
ld <- new("stringsDated", ll, stamp = Sys.time())

levels(as(ld, "factor"))
levels(ld) # will be NULL--see comment in section on inheritance above.

## In contrast, a class that simply extends "factor"
## has no such ambiguities
setClass("factorDated", contains = "factor",
         representation(stamp="POSIXt"))
fd <- new("factorDated", factor(ll), stamp = Sys.time())
identical(levels(fd), levels(as(fd, "factor")))
\end{ExampleCode}
\end{Examples}
\HeaderA{isSealedMethod}{ Check for a Sealed Method or Class }{isSealedMethod}
\aliasA{isSealedClass}{isSealedMethod}{isSealedClass}
\keyword{programming}{isSealedMethod}
\keyword{classes}{isSealedMethod}
\keyword{classes}{isSealedMethod}
\keyword{methods}{isSealedMethod}
%
\begin{Description}\relax
These functions check for either a method or a class that has been
\emph{sealed} when it was defined, and which therefore cannot be
re-defined.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
isSealedMethod(f, signature, fdef, where)
isSealedClass(Class, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}]  The quoted name of the generic function. 
\item[\code{signature}]  The class names in the method's signature, as
they would be supplied to \code{\LinkA{setMethod}{setMethod}}. 
\item[\code{fdef}]  Optional, and usually omitted:  the generic function
definition for \code{f}. 
\item[\code{Class}] The quoted name of the class.

\item[\code{where}] where to search for the method or class definition.  By
default, searches from the top environment of the call to
\code{isSealedMethod} or \code{isSealedClass}, typically the
global environment or the namespace of a package containing a call
to one of the functions.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
In the \R{} implementation of classes and methods, it is possible to
seal the definition of either a class or a method.  The basic
classes (numeric and other types of vectors, matrix and array data)
are sealed.  So also are the methods for the primitive functions on
those data types.  The effect is that programmers cannot re-define
the meaning of these basic data types and computations.  More
precisely, for primitive functions that depend on only one data
argument, methods cannot be specified for basic classes.  For
functions (such as the arithmetic operators) that depend on two
arguments, methods can be specified if \emph{one} of those arguments
is a basic class, but not if both are.

Programmers can seal other class and method definitions by using the
\code{sealed} argument to \code{\LinkA{setClass}{setClass}} or \code{\LinkA{setMethod}{setMethod}}.
\end{Details}
%
\begin{Value}
The functions return \code{FALSE} if the method or class is not
sealed (including the case that it is not defined); \code{TRUE} if
it is.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
## these are both TRUE
isSealedMethod("+", c("numeric", "character"))
isSealedClass("matrix")

setClass("track",
            representation(x="numeric", y="numeric"))
## but this is FALSE
isSealedClass("track")
## and so is this
isSealedClass("A Name for an undefined Class")
## and so are these, because only one of the two arguments is basic
isSealedMethod("+", c("track", "numeric"))
isSealedMethod("+", c("numeric", "track"))


\end{ExampleCode}
\end{Examples}
\HeaderA{language-class}{Classes to Represent Unevaluated Language Objects }{language.Rdash.class}
\aliasB{(-class}{language-class}{(.Rdash.class}
\aliasA{<\Rdash-class}{language-class}{<.Rdash..Rdash.class}
\aliasA{call-class}{language-class}{call.Rdash.class}
\aliasA{for-class}{language-class}{for.Rdash.class}
\aliasA{if-class}{language-class}{if.Rdash.class}
\aliasA{name-class}{language-class}{name.Rdash.class}
\aliasA{repeat-class}{language-class}{repeat.Rdash.class}
\aliasA{while-class}{language-class}{while.Rdash.class}
\aliasB{\{-class}{language-class}{.Rlbrace..Rdash.class}
\keyword{classes}{language-class}
%
\begin{Description}\relax
  The virtual class \code{"language"} and the specific
classes that extend it represent unevaluated objects, as produced for
example by the parser or by functions such as \code{\LinkA{quote}{quote}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
### each of these classes corresponds to an unevaluated object
### in the S language.
### The class name can appear in method signatures,
### and in a few other contexts (such as some calls to as()).

"("
"<-"
"call"
"for"
"if"
"repeat"
"while"
"name"
"{"

### Each of the classes above extends the virtual class
"language"
\end{verbatim}
\end{Usage}
%
\begin{Section}{Objects from the Class}
\code{"language"} is a virtual class; no objects may be created from
it.

Objects from the other classes can be generated by a call to
\code{new(Class, ...)}, where \code{Class} is the quoted class name, and
the \dots arguments are either empty or a \emph{single} object that is
from this class (or an extension).
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[coerce] \code{signature(from = "ANY", to = "call")}.  A method
exists for \code{as(object, "call")}, calling \code{as.call()}. 

\end{description}


\end{Section}
\HeaderA{LinearMethodsList-class}{Class "LinearMethodsList"}{LinearMethodsList.Rdash.class}
\keyword{classes}{LinearMethodsList-class}
%
\begin{Description}\relax
A version of methods lists that has been `linearized'
for producing summary information.  The actual objects from class
\code{"MethodsList"} used for method dispatch are defined recursively
over the arguments involved.
\end{Description}
%
\begin{Section}{Objects from the Class}
The function \code{\LinkA{linearizeMlist}{linearizeMlist}} converts an ordinary methods
list object into the linearized form.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{methods}:] Object of class \code{"list"}, the method
definitions.
\item[\code{arguments}:] Object of class \code{"list"}, the
corresponding formal arguments, namely as many of the arguments
in the signature of the generic function as are active in the
relevant method table. 
\item[\code{classes}:] Object of class \code{"list"}, the
corresponding classes in the signatures. 
\item[\code{generic}:] Object of class \code{"genericFunction"};
the generic function to which the methods correspond. 

\end{description}

\end{Section}
%
\begin{Section}{Future Note}
The current version of \code{linearizeMlist} does not take advantage of
the \code{MethodDefinition} class, and therefore does more work for less
effect than it could.  In particular, we may move to redefine both the
function and the class to take advantage of the stored signatures.
Don't write code depending precisely on the present form, although all
the current information will be obtainable in the future.
\end{Section}
%
\begin{SeeAlso}\relax
 Function \code{\LinkA{linearizeMlist}{linearizeMlist}} for the computation,
and class \code{\LinkA{MethodsList}{MethodsList.Rdash.class}} for the original, recursive
form.
\end{SeeAlso}
\HeaderA{makeClassRepresentation}{Create a Class Definition}{makeClassRepresentation}
\keyword{programming}{makeClassRepresentation}
\keyword{classes}{makeClassRepresentation}
%
\begin{Description}\relax
Constructs an object of class \code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}
to describe a particular class.  Mostly a utility function, but you can
call it to create a class definition without assigning it, as
\code{\LinkA{setClass}{setClass}} would do.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
makeClassRepresentation(name, slots=list(), superClasses=character(),
                        prototype=NULL, package, validity, access,
                        version, sealed, virtual=NA, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}] character string name for the class
\item[\code{slots}] named list of slot classes as would be supplied to
\code{setClass}, but \emph{without} the unnamed arguments for
superClasses if any.
\item[\code{superClasses}] what classes does this class extend
\item[\code{prototype}] an object providing the default data for the class,
e.g, the result of a call to \code{\LinkA{prototype}{prototype}}.
\item[\code{package}] The character string name for the package in which
the class will be stored; see \code{\LinkA{getPackageName}{getPackageName}}.
\item[\code{validity}] Optional validity method.  See
\code{\LinkA{validObject}{validObject}}, and the discussion of validity methods in
the reference.
\item[\code{access}] Access information.  Not currently used.
\item[\code{version}] Optional version key for version control.  Currently
generated, but not used.
\item[\code{sealed}] Is the class sealed? See \code{\LinkA{setClass}{setClass}}.
\item[\code{virtual}] Is this known to be a virtual class?

\item[\code{where}] The environment from which to look for class
definitions needed (e.g., for slots or superclasses). See the
discussion of this argument under \LinkA{GenericFunctions}{GenericFunctions}.
\end{ldescription}
\end{Arguments}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setClass}{setClass}}
\end{SeeAlso}
\HeaderA{method.skeleton}{Create a Skeleton File for a New Method}{method.skeleton}
\keyword{programming}{method.skeleton}
\keyword{methods}{method.skeleton}
%
\begin{Description}\relax
This function writes a source file containing a call to
\code{\LinkA{setMethod}{setMethod}} to define a method for the generic function
and signature supplied.  By default the method definition is in line
in the call, but can be made an external (previously assigned) function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
method.skeleton(generic, signature, file, external = FALSE, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{generic}] the character string name of the generic function, or
the generic function itself.  In the first case, the function
need not currently be a generic, as it would not for the
resulting call to \code{\LinkA{setMethod}{setMethod}}.
\item[\code{signature}] the method signature, as it would be given to \code{\LinkA{setMethod}{setMethod}}
\item[\code{file}] a character string name for the output file, or a
writable connection.  By default the generic function name and
the classes in the signature are concatenated, with separating
underscore characters.  The file name should normally end in \code{".R"}. 

To write multiple method skeletons to one file, open the file
connection first and then pass it to \code{method.skeleton()} in
multiple calls.
\item[\code{external}] flag to control whether the function definition for
the method should be a separate external object assigned in the
source file, or included in line in the call to
\code{\LinkA{setMethod}{setMethod}}.
If supplied as a character string, this will be used as the name
for the external function; by default the name concatenates the
generic and signature names, with separating underscores.
\item[\code{where}] The environment in which to look for the function; by default,
the top-level environment of the call to \code{method.skeleton}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The \code{file} argument, invisibly, but the function is used for its side effect.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{setMethod}{setMethod}}, \code{\LinkA{package.skeleton}{package.skeleton}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

setClass("track", representation(x ="numeric", y="numeric"))
method.skeleton("show", "track")            ## writes show_track.R
method.skeleton("Ops", c("track", "track")) ## writes "Ops_track_track.R"

## write multiple method skeletons to one file
con <- file("./Math_track.R", "w")
method.skeleton("Math", "track", con)
method.skeleton("exp", "track", con)
method.skeleton("log", "track", con)
close(con)

\end{ExampleCode}
\end{Examples}
\HeaderA{MethodDefinition-class}{Classes to Represent Method Definitions}{MethodDefinition.Rdash.class}
\aliasA{SealedMethodDefinition-class}{MethodDefinition-class}{SealedMethodDefinition.Rdash.class}
\keyword{classes}{MethodDefinition-class}
%
\begin{Description}\relax
These classes extend the basic class \code{"function"} when
functions are to be stored and used as method definitions.
\end{Description}
%
\begin{Details}\relax
Method definition objects are functions with additional information
defining how the function is being used as a method.  The
\code{target} slot is the class signature for which the method will
be dispatched, and the \code{defined} slot the signature for which
the method was originally specified (that is, the one that appeared
in some call to \code{\LinkA{setMethod}{setMethod}}).
\end{Details}
%
\begin{Section}{Objects from the Class}
The action of setting a method by a call to \code{\LinkA{setMethod}{setMethod}} creates an object of this class.  It's
unwise to create them directly.

The class \code{"SealedMethodDefinition"} is created by a call to
\code{\LinkA{setMethod}{setMethod}} with argument \code{sealed = TRUE}.  It has
the same representation as \code{"MethodDefinition"}.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"function"}; the data
part of the definition. 
\item[\code{target}:] Object of class \code{"signature"}; the
signature for which the method was wanted. 
\item[\code{defined}:] Object of class \code{"signature"}; the
signature for which a method was found.  If the method was
inherited, this will not be identical to \code{target}. 
\item[\code{generic}:] Object of class \code{"character"}; the function
for which the method was created. 

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"function"}, from data part.\\{}
Class \code{"PossibleMethod"}, directly.\\{}
Class \code{"OptionalMethods"}, by class \code{"function"}.
\end{Section}
%
\begin{SeeAlso}\relax
class \code{\LinkA{MethodsList}{MethodsList.Rdash.class}} for the objects
defining sets of methods associated with a particular generic
function.  The individual method definitions stored in these objects
are from class \code{MethodDefinition}, or an extension.
Class \code{\LinkA{MethodWithNext}{MethodWithNext.Rdash.class}} for an extension used by
\code{\LinkA{callNextMethod}{callNextMethod}}.
\end{SeeAlso}
\HeaderA{Methods}{General Information on Methods}{Methods}
\keyword{programming}{Methods}
\keyword{classes}{Methods}
\keyword{methods}{Methods}
%
\begin{Description}\relax
This documentation section covers some general topics on how methods
work and how the \pkg{methods} package interacts with the rest of \R{}.  The
information is usually not needed to get started with methods and
classes, but may be helpful for moderately ambitious projects, or when
something doesn't work as expected.

The section ``How Methods Work'' describes the underlying
mechanism; ``S3 Methods and Generic Functions'' gives the rules applied when S4
classes and methods interact with older S3 methods; ``Method Selection and Dispatch'' provides more
details on how class definitions determine which methods are used;
``Generic Functions'' discusses generic functions as objects.
For additional information specifically about class definitions, see \code{\LinkA{Classes}{Classes}}.
\end{Description}
%
\begin{Section}{How Methods Work}
A generic function  has associated with it a
collection of other functions (the methods), all of which have the same
formal arguments as the generic.  See the ``Generic
Functions'' section below for more on generic functions themselves.

Each \R{} package will include  methods metadata objects
corresponding to each generic function  for which methods have been
defined in that package.
When the package is loaded into an \R{} session, the methods for each
generic function are \emph{cached}, that is, stored in the
environment of the generic function along with the methods from
previously loaded packages.  This merged table of methods is used to
dispatch or select methods from the generic, using class inheritance
and possibly group generic functions (see
\code{\LinkA{GroupGenericFunctions}{GroupGenericFunctions}}) to find an applicable method.
See the ``Method Selection and Dispatch'' section below.
The caching computations ensure that only one version of each
generic function is visible globally; although different attached
packages may contain a copy of the generic function, these behave
identically with respect to method selection.
In contrast, it is possible for the same function name to refer to
more than one generic function, when these have different
\code{package} slots.  In the latter case, \R{} considers the
functions unrelated:  A generic function is defined by the
combination of name and package.  See the ``Generic Functions''
section below.

The methods for a generic are stored according to the
corresponding \code{signature} in the call to \code{\LinkA{setMethod}{setMethod}}
that defined  the method.  The signature associates one
class name with each of a subset of the formal arguments to the
generic function.  Which formal arguments are available, and the
order in which they appear, are determined by the \code{"signature"}
slot of the generic function itself.  By default, the signature of the
generic consists of all the formal arguments except \dots, in the
order they appear in the function definition.

Trailing arguments in the signature of the generic will be \emph{inactive}  if no
method has yet been specified that included those arguments in its signature.
Inactive arguments are not needed or used in labeling the cached
methods.  (The distinction does not change which methods are
dispatched, but ignoring inactive arguments improves the
efficiency of dispatch.)

All arguments in the signature of the generic function will be evaluated when the
function is called, rather than using the traditional lazy
evaluation rules of S.  Therefore, it's important to \emph{exclude}
from the signature any arguments that need to be dealt with
symbolically (such as the first argument to function
\code{\LinkA{substitute}{substitute}}).  Note that only actual arguments are
evaluated, not default expressions.
A missing argument enters into the method selection as class
\code{"missing"}.

The cached methods are stored in an
environment object.  The names used for assignment are a
concatenation of the class names for the active arguments in the method signature.

\end{Section}
%
\begin{Section}{Methods for S3 Generic Functions}

S4 methods may be wanted for functions that also have S3 methods, corresponding to classes for the first
formal argument of an S3 generic function--either a regular R function in which there is a
call to the S3 dispatch function, \code{\LinkA{UseMethod}{UseMethod}},
or one of a fixed set of primitive
functions, which are not true functions but go directly to C code.
In either case S3 method dispatch looks at the class of the first
argument or the class of either
argument in a call to one of the primitive binary operators.
S3 methods are ordinary functions with the same arguments as the
generic function (for primitives the formal arguments are not actually
part of the object, but are simulated when the object is printed or
viewed by \code{\LinkA{args}{args}()}).
The ``signature'' of an S3 method is identified  by the name to
which the method is assigned, composed of the name of the
generic function, followed by \code{"."}, followed by the name of the class.
For details, see \LinkA{S3Methods}{S3Methods}.

To implement a method for one of these functions corresponding to S4
classes, there are two possibilities: either an S4 method or an S3 method with the
S4 class name.
The S3 method is only possible if the intended signature has the
first argument and nothing else.
In this case,
the recommended approach is to define the S3 method and also supply the
identical function as the definition of the S4 method.
If the S3 generic function was \code{f3(x, ...)} and the S4 class for
the new method was 
\code{"myClass"}:

\code{f3.myClass <- function(x, ...) \{ ..... \}}

\code{setMethod("f3", "myClass", f3.myClass)}

The reasons for defining both S3 and S4 methods are as follows:
\begin{enumerate}

\item An S4 method alone will not be seen if the S3 generic function
is called directly.  However, primitive functions and operators
are exceptions:  The internal C code will look for S4 methods
if and only if the object is an S4 object.  In the examples, the method
for \code{`[`} for class \code{"myFrame"} will always be called
for objects of this class.

For the same reason, an S4 method defined for an S3 class will not be called from
internal code for a non-S4 object. (See the example for function
\code{Math} and
class \code{"data.frame"} in the examples.)
\item An S3 method alone will not be called if there is \emph{any}
eligible non-default S4 method. (See the example for function
\code{f3} and class \code{"classA"} in the examples.)

\end{enumerate}

Details of the selection computations are given below.

When an S4 method is defined for an existing function that is not an
S4 generic function (whether or not the existing function is an S3 generic),
an S4 generic function will be created corresponding to the existing
function and the package in which it is found (more precisely,
according to the implicit generic function either specified or
inferred from the ordinary function; see \code{\LinkA{implicitGeneric}{implicitGeneric}}).
A message is printed after the initial call to
\code{\LinkA{setMethod}{setMethod}}; this is not an error, just a reminder that
you have created the generic.
Creating the generic explicitly by the call

\code{setGeneric("f3")}

avoids the message, but has the same effect.
The existing function becomes the default method for
the S4 generic function.
Primitive functions work the same way, but
the S4 generic function is not explicitly created (as discussed below).


S4 and S3 method selection are designed to follow compatible rules of
inheritance, as far as possible.
S3 classes can be used for any S4 method selection, provided that the
S3 classes have been registered by a call to
\code{\LinkA{setOldClass}{setOldClass}}, with that call specifying the correct S3
inheritance pattern.
S4 classes can be used for any S3 method selection; when an S4 object
is detected, S3 method selection uses the contents of
\code{\LinkA{extends}{extends}(class(x))} as the equivalent of the S3
inheritance (the inheritance is cached after the first call).

An existing S3 method may not behave as desired for an S4 subclass, in
which case utilities such as \code{\LinkA{asS3}{asS3}} and
\code{\LinkA{S3Part}{S3Part}} may be useful.  If the S3 method fails on the S4
object, \code{asS3(x)} may be passed instead; if the object returned
by the S3 method needs to be incorporated in the S4 object, the
replacement function for \code{S3Part} may be useful, as in the method
for class \code{"myFrame"} in the examples.

Here are details explaining the reasons for defining both S3 and S4 methods.
Calls still accessing the S3 generic function
directly will not see S4 methods, except in the case of primitive
functions.
This means that calls to the generic function from namespaces that
import the S3 generic but not the S4 version will only see S3
methods.
On the other hand, S3 methods will only be selected from the
S4 generic function as part of its default (\code{"ANY"}) method.
If there are inherited S4 non-default methods, these will be chosen in
preference to \emph{any} S3 method.

S3 generic functions implemented as primitive functions (including
binary operators) are an exception to recognizing only
S3 methods.
These functions dispatch both S4 and S3 methods from
the internal C code.
There is no explicit generic function, either S3 or S4.
The internal code looks for S4 methods if the first
argument, or either of the arguments in the case of a binary operator,
is an S4 object.
If no S4 method is found, a search is made for an S3 method.

S4 methods can be defined for an S3 generic function and an S3 class,
but if the function is a primitive, such methods will not be selected
if the object in question is not an S4 object.
In the examples below, for instance,  an S4 method for signature
\code{"data.frame"} for function \code{f3()} would be called for the
S3 object \code{df1}.
A similar S4 method for primitive function
\code{`[`} would be ignored for that object, but would be called for
the S4 object \code{mydf1} that inherits from \code{"data.frame"}.
Defining both an S3 and S4 method removes this inconsistency.


\end{Section}
%
\begin{Section}{Method Selection and Dispatch: Details}

When a call to a generic function is evaluated, a method is selected corresponding
to the classes of the actual arguments in the signature.
First, the cached methods table is searched for an  exact match;
that is, a method stored under the signature defined by
the string value of \code{class(x)} for each non-missing
argument, and \code{"missing"} for each missing argument.
If no method is found directly for the actual arguments in a call to a
generic function, an attempt is made to match the available methods to
the arguments by using the superclass information about the actual classes.

Each class definition may include a list of  one or more
\emph{superclasses} of the new class.
The simplest and most common specification is by the \code{contains=} argument in
the  call to \code{\LinkA{setClass}{setClass}}.
Each class named in this argument is a superclass of the new class.
Two additional mechanisms for defining
superclasses exist.
A call to \code{\LinkA{setClassUnion}{setClassUnion}} creates a union class that
is a
superclass of each of the members of the union.
A call to 
\code{\LinkA{setIs}{setIs}} can create an inheritance relationship that is not the simple one of
containing the superclass representation in the new class.
Arguments \code{coerce} and \code{replace} supply methods to convert
to the superclass and to replace the part corresponding to the superclass.
(In addition, a \code{test=} argument allows conditional inheritance;  conditional inheritance is not
recommended and is not used in method selection.)
All three mechanisms are treated equivalently for purposes of
method selection:  they define the \emph{direct} superclasses of a
particular class.
For more details on the mechanisms, see \code{\LinkA{Classes}{Classes}}.

The direct superclasses themselves may
have superclasses, defined by any of the same mechanisms, and
similarly through further generations.  Putting all this information together produces
the full list of superclasses for this class.
The superclass list is included in the definition of the class that is
cached during the \R{} session.
Each element of the list describes the nature of the relationship (see
\code{\LinkA{SClassExtension}{SClassExtension.Rdash.class}} for details).
Included in the element is a \code{distance} slot containing
the path length for the relationship:
\code{1} for direct superclasses (regardless of which mechanism
defined them), then \code{2} for the direct superclasses of those
classes, and so on.
In addition, any class implicitly has class \code{"ANY"} as a superclass.  The
distance to \code{"ANY"} is treated as larger than the distance to any
actual class.
The special class \code{"missing"} corresponding to missing arguments
has only \code{"ANY"} as a superclass, while \code{"ANY"} has no
superclasses.

When a class definition is created or modified, the superclasses
are ordered, first by a stable sort of the all superclasses by
distance.
If the set of superclasses has duplicates (that is, if some class is
inherited through more than one relationship), these are removed, if
possible, so that the list of superclasses is consistent with the
superclasses of all direct superclasses.
See the reference on inheritance for details.

The information about superclasses is summarized when a class
definition is printed.

When a method is to be selected by inheritance, a search is made in
the table for all methods directly corresponding to a combination of
either the direct class or one of its superclasses, for each argument
in the active signature.
For an example, suppose there is only one argument in the signature and that the class of
the corresponding object was \code{"dgeMatrix"} (from the recommended package
\code{Matrix}).
This class has two direct superclasses and through these 4 additional superclasses.
Method selection finds all the methods in the table of directly
specified methods labeled by one of these classes, or by
\code{"ANY"}.

When there are multiple arguments in the signature, each argument will
generate a similar  list of inherited classes.
The possible matches are now all the combinations of classes from each
argument (think of the function \code{outer} generating an array of
all possible combinations).
The search now finds all the methods matching any of this combination
of classes.
For each argument, the position in the list of superclasses of that
argument's class defines which method or methods (if the same class
appears more than once) match best.
When there is only one argument, the best match is unambiguous.
With more than one argument, there may be zero or one match that is
among the best matches for \emph{all} arguments.

If there is no best match, the selection is ambiguous and a message is
printed noting which method was selected (the first method
lexicographically in the ordering) and what other methods could have
been selected.
Since the ambiguity is usually nothing the end user could control,
this is not a warning.
Package authors should examine their package for possible ambiguous
inheritance by calling \code{\LinkA{testInheritedMethods}{testInheritedMethods}}.

When the inherited method has been selected, the selection is cached
in the generic function so that future calls with the same class will
not require repeating the search.  Cached inherited selections are
not themselves used in future inheritance searches, since that could result
in invalid selections.
If you want inheritance computations to be done again (for example,
because a newly loaded package has a more direct method than one
that has already been used in this session), call
\code{\LinkA{resetGeneric}{resetGeneric}}.  Because classes and methods involving
them tend to come from the same package, the current implementation
does not reset all generics every time a new package is loaded.

Besides being initiated through calls to the generic function, method
selection can be done explicitly by calling the function
\code{\LinkA{selectMethod}{selectMethod}}.

Once a method has been selected, the evaluator creates a new context
in which a call to the method is evaluated.
The context is initialized with the arguments from the call to the
generic function.
These arguments are not rematched.  All the arguments in the signature
of the generic will have been evaluated (including any that are
currently inactive); arguments that are not in the signature will obey
the usual lazy evaluation rules of the language.
If an argument was missing in the call, its default expression if any
will \emph{not} have been evaluated, since method dispatch always uses
class \code{missing} for such arguments.

A call to a generic function therefore has two contexts:  one for the
function and a second for the method.
The argument objects will be copied to the second context, but not any
local objects created in a nonstandard generic function.
The other important distinction is that the parent 
(``enclosing'') environment of the second context is the environment
of the method as a function, so that all \R{} programming techniques
using such environments apply to method definitions as ordinary functions.


For further discussion of method selection and dispatch,  see the
first reference.

\end{Section}
%
\begin{Section}{Generic Functions}
In principle, a generic function could be any function that evaluates
a call to \code{standardGeneric()}, the internal function that selects
a method and evaluates a call to  the selected method.  In practice,
generic functions are special objects that in addition to being from a
subclass of class \code{"function"} also extend the class
\code{\LinkA{genericFunction}{genericFunction.Rdash.class}}.  Such objects have slots to define
information needed to deal with their methods.  They also have
specialized environments, containing the tables used in method
selection.

The slots \code{"generic"} and  \code{"package"} in the object are the
character string names of the generic function itself and of the
package from which the  function is defined.
As with classes, generic functions are uniquely defined in \R{} by the
combination of the two names.
There can be generic functions of the same name associated with
different packages (although inevitably keeping such functions cleanly
distinguished is not always easy).
On the other hand, \R{} will enforce that only one definition of a
generic function can be associated with a particular combination of
function and package name, in the current session or other active
version of \R{}.

Tables of methods for a particular generic function, in this sense,
will often be spread over several other packages.
The total set of methods for a given generic function may change
during a session, as additional packages are loaded.
Each table must be consistent in the signature assumed for the generic
function.

\R{} distinguishes \emph{standard} and \emph{nonstandard} generic
functions, with the former having a function body that does nothing
but dispatch a method.
For the most part, the distinction is just one of simplicity:  knowing
that a generic function only dispatches a method call allows some
efficiencies and also removes some uncertainties.

In most cases, the generic function is the visible function
corresponding to that name, in the corresponding package.
There are two exceptions, \emph{implicit} generic
functions and the special computations required to deal with \R{}'s
\emph{primitive} functions.
Packages can contain a table of implicit generic versions of functions
in the package, if the package wishes to leave a function non-generic
but to constrain what the function would be like if it were generic.
Such implicit generic functions are created during the installation of
the package, essentially by defining the generic function and
possibly methods for it, and then reverting the function to its
non-generic form. (See \LinkA{implicitGeneric}{implicitGeneric} for how this is done.)
The mechanism is mainly used for functions in the older packages in
\R{}, which may prefer to ignore S4 methods.
Even in this case, the actual mechanism is only needed if something
special has to be specified.
All functions have a corresponding implicit generic version defined
automatically (an implicit, implicit generic function one might say).
This function is a standard generic with the same arguments as the
non-generic function, with the non-generic version as the default (and only)
method, and with the generic signature being all the formal arguments
except \dots.

The implicit generic mechanism is needed only to override some aspect
of the default definition.
One reason to do so would be to remove some arguments from the
signature.
Arguments that may need to be interpreted literally, or for which the
lazy evaluation mechanism of the language is needed, must \emph{not}
be included in the signature of the generic function, since all
arguments in the signature will be evaluated in order to select a
method.
For example, the argument \code{expr} to the function
\code{\LinkA{with}{with}} is treated literally and must therefore be excluded
from the signature.

One would also need to define an implicit generic if the existing
non-generic function were not suitable as the default method.
Perhaps the function only applies to some classes of objects, and the
package designer prefers to have no general default method.
In the other direction, the package designer might have some ideas
about suitable methods for some classes, if the function were generic.
With reasonably modern packages, the simple approach in all these
cases is just to define the function as a generic.
The implicit generic mechanism is mainly attractive for older packages
that do not want to require the methods package to be available.

Generic functions will also be defined but not obviously visible for
functions implemented as \emph{primitive} functions in the base
package.
Primitive functions look like ordinary functions when printed but are
in fact not function objects but objects of two types interpreted by
the \R{} evaluator to call underlying C code directly.
Since their entire justification is efficiency, \R{} refuses to hide
primitives behind a generic function object.
Methods may be defined for most primitives, and corresponding metadata
objects will be created to store them.
Calls to the primitive still go directly to the C code, which will
sometimes check for applicable methods.
The definition of ``sometimes'' is that methods must have been
detected for the function in some package loaded in the session and
\code{isS4(x)} is \code{TRUE} for  the first argument (or for the
second argument, in the case of binary operators).
You can test whether methods have been detected by calling
\code{\LinkA{isGeneric}{isGeneric}} for the relevant function and you can examine
the generic function by calling \code{\LinkA{getGeneric}{getGeneric}}, whether or
not methods have been detected.
For more on generic functions, see the first reference and also section 2 of \emph{R Internals}.

\end{Section}
%
\begin{Section}{Method Definitions}
All method definitions are stored as objects from the
\code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} class.
Like the class of generic functions, this class extends ordinary \R{}
functions with some additional slots: \code{"generic"}, containing the
name and package of the generic function, and two signature slots,
\code{"defined"} and \code{"target"}, the first being the signature supplied when
the method was defined by a call to \code{\LinkA{setMethod}{setMethod}}.
The  \code{"target"} slot starts off equal to the \code{"defined"}
slot.  When an inherited method is cached after being selected, as
described above, a copy is made with the  appropriate \code{"target"}  signature.
Output from \code{\LinkA{showMethods}{showMethods}}, for example, includes both
signatures.

Method definitions are required to have the same formal arguments as
the generic function, since the method dispatch mechanism does not
rematch arguments, for reasons of both efficiency and consistency.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version: see section 10.6 for method
selection and section 10.5 for generic functions).

Chambers, John M.(2009)
\emph{Developments in Class Inheritance and Method Selection}
\url{http://stat.stanford.edu/~jmc4/classInheritance.pdf}.

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
For more specific information, see
\code{\LinkA{setGeneric}{setGeneric}}, \code{\LinkA{setMethod}{setMethod}}, and
\code{\LinkA{setClass}{setClass}}.

For the use of \dots in methods, see  \LinkA{dotsMethods}{dotsMethods}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## A class that extends a registered S3 class inherits that class' S3
## methods.

setClass("myFrame", contains = "data.frame",
    representation(timestamps = "POSIXt"))

df1 <- data.frame(x = 1:10, y = rnorm(10), z = sample(letters,10))

mydf1 <- new("myFrame", df1, timestamps = Sys.time())

## "myFrame" objects inherit "data.frame" S3 methods; e.g., for `[`

mydf1[1:2, ] # a data frame object (with extra attributes)

## a method explicitly for "myFrame" class


setMethod("[",
    signature(x = "myFrame"),
    function (x, i, j, ..., drop = TRUE) 
    {
        S3Part(x) <- callNextMethod()
        x@timestamps <- c(Sys.time(), as.POSIXct(x@timestamps))
        x
    }
)

mydf1[1:2, ]


setClass("myDateTime", contains = "POSIXt")

now <- Sys.time() # class(now) is c("POSIXct", "POSIXt")
nowLt <- as.POSIXlt(now)# class(nowLt) is c("POSIXlt", "POSIXt")

mCt <- new("myDateTime", now)
mLt <- new("myDateTime", nowLt)

## S3 methods for an S4 object will be selected using S4 inheritance
## Objects mCt and mLt have different S3Class() values, but this is
## not used.
f3 <- function(x)UseMethod("f3") # an S3 generic to illustrate inheritance

f3.POSIXct <- function(x) "The POSIXct result"
f3.POSIXlt <- function(x) "The POSIXlt result"
f3.POSIXt <- function(x) "The POSIXt result"

stopifnot(identical(f3(mCt), f3.POSIXt(mCt)))
stopifnot(identical(f3(mLt), f3.POSIXt(mLt)))



## An S4 object selects S3 methods according to its S4 "inheritance"


setClass("classA", contains = "numeric",
   representation(realData = "numeric"))

Math.classA <- function(x) {(getFunction(.Generic))(x@realData)}
setMethod("Math", "classA", Math.classA)


x <- new("classA", log(1:10), realData = 1:10)

stopifnot(identical(abs(x), 1:10))

setClass("classB", contains = "classA")

y <- new("classB", x)

stopifnot(identical(abs(y), 1:10)) # (version 2.9.0 or earlier fails here)

## an S3 generic: just for demonstration purposes
f3 <- function(x, ...) UseMethod("f3")

f3.default <- function(x, ...) "Default f3"

## S3 method (only) for classA
f3.classA <- function(x, ...) "Class classA for f3"

## S3 and S4 method for numeric
f3.numeric <- function(x, ...) "Class numeric for f3"
setMethod("f3", "numeric", f3.numeric)

## The S3 method for classA and the closest inherited S3 method for classB
## are not found.

f3(x); f3(y) # both choose "numeric" method

## to obtain the natural inheritance, set identical S3 and S4 methods
setMethod("f3", "classA", f3.classA)

f3(x); f3(y) # now both choose "classA" method

## Need to define an S3 as well as S4 method to use on an S3 object
## or if called from a package without the S4 generic

MathFun <- function(x) { # a smarter "data.frame" method for Math group
  for (i in seq(length = ncol(x))[sapply(x, is.numeric)])
    x[, i] <- (getFunction(.Generic))(x[, i])
  x
}
setMethod("Math", "data.frame", MathFun)

## S4 method works for an S4 class containing data.frame,
## but not for data.frame objects (not S4 objects)

try(logIris <- log(iris)) #gets an error from the old method

## Define an S3 method with the same computation

Math.data.frame <- MathFun

logIris <- log(iris)






\end{ExampleCode}
\end{Examples}
\HeaderA{MethodsList-class}{Class MethodsList, Deprecated Representation of Methods }{MethodsList.Rdash.class}
\aliasA{body<\Rdash,MethodDefinition-method}{MethodsList-class}{body<.Rdash.,MethodDefinition.Rdash.method}
\keyword{classes}{MethodsList-class}
\keyword{methods}{MethodsList-class}
%
\begin{Description}\relax
 This class of objects was used in the original
implementation of the package to control method dispatch.  Its use
is now deprecated, but object appear as the default method slot in
generic functions.  This and any other remaining uses will be
removed in the future.

For the modern alternative, see \LinkA{listOfMethods}{listOfMethods.Rdash.class}.

The details in this documentation are retained to allow analysis of
old-style objects. 
\end{Description}
%
\begin{Details}\relax
Suppose a function \code{f} has
formal arguments \code{x} and \code{y}.  The methods list object for
that function has the object \code{as.name("x")} as its
\code{argument} slot.  An element of the methods named \code{"track"}
is selected if the actual argument corresponding to \code{x} is an
object of class \code{"track"}.  If there is such an element, it can
generally be either a function or another methods list object.

In the first case, the function defines the method to use for any call
in which \code{x} is of class \code{"track"}.  In the second case, the
new methods list object defines the available methods depending on
the remaining formal arguments, in this example, \code{y}. 

Each method  corresponds conceptually to a \emph{signature};
that is a named list of classes, with names corresponding to some or
all of the formal arguments.  In the previous example, if selecting
class \code{"track"} for \code{x}, finding that the selection was
another methods list and then selecting class \code{"numeric"} for
\code{y} would produce a method associated with the signature
\code{x = "track", y = "numeric"}.

\end{Details}
%
\begin{Section}{Slots}
\begin{description}


\item[\code{argument}:] Object of class \code{"name"}.  The name of the
argument being used for dispatch at this level. 
\item[\code{methods}:] A named list of the methods (and method lists)
defined \emph{explicitly} for this argument. 
The names are the names of classes, and the corresponding
element defines the method or methods to be used if the corresponding
argument has that class.  See the details below.
\item[\code{allMethods}:] A named list,  contains
all the directly defined methods from the \code{methods} slot, plus
any inherited methods.  Ignored when methods tables are used for dispatch (see \LinkA{Methods}{Methods} 

\end{description}
\end{Section}
%
\begin{Section}{Extends}
Class \code{"OptionalMethods"}, directly.
\end{Section}
\HeaderA{MethodWithNext-class}{Class MethodWithNext }{MethodWithNext.Rdash.class}
\keyword{classes}{MethodWithNext-class}
%
\begin{Description}\relax
 Class of method definitions set up for callNextMethod 
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects from this class are generated as a side-effect of calls to
\code{\LinkA{callNextMethod}{callNextMethod}}.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"function"}; the actual
function definition.
\item[\code{nextMethod}:] Object of class \code{"PossibleMethod"}
the method to use in response to a \code{\LinkA{callNextMethod}{callNextMethod}()}
call.
\item[\code{excluded}:] Object of class \code{"list"}; one or more
signatures excluded in finding the next method. 
\item[\code{target}:] Object of class \code{"signature"}, from class
\code{"MethodDefinition"}
\item[\code{defined}:] Object of class \code{"signature"}, from
class \code{"MethodDefinition"}
\item[\code{generic}:] Object of class \code{"character"}; the function
for which the method was created. 

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"MethodDefinition"}, directly.\\{}
Class \code{"function"}, from data part.\\{}
Class \code{"PossibleMethod"}, by class \code{"MethodDefinition"}.\\{}
Class \code{"OptionalMethods"}, by class \code{"MethodDefinition"}.
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[findNextMethod] \code{signature(method = "MethodWithNext")}:
used internally by method dispatch. 
\item[loadMethod] \code{signature(method = "MethodWithNext")}: used
internally by method dispatch. 
\item[show] \code{signature(object = "MethodWithNext")} 

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
  \code{\LinkA{callNextMethod}{callNextMethod}}, and
class \code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}}.
\end{SeeAlso}
\HeaderA{new}{ Generate an Object from a Class }{new}
\aliasA{initialize}{new}{initialize}
\keyword{programming}{new}
\keyword{classes}{new}
%
\begin{Description}\relax
Given the name or the definition of a class, plus optionally data
to be included in the object, \code{new} returns an object from that
class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
new(Class, ...)

initialize(.Object, ...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] either the name of a class, a \code{\LinkA{character}{character}}
string, (the usual case) or the object describing the class (e.g.,
the value returned by \code{getClass}).
\item[\code{...}] data to include in the new object.  Named arguments
correspond to slots in the class definition. Unnamed arguments must
be objects from classes that this class extends.
\item[\code{.Object}]  An object:  see the Details section.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The function \code{new} begins by copying the prototype object from
the class definition.  Then information is inserted according to the
\code{...} arguments, if any.  As of version 2.4 of R, the type of
the prototype object, and therefore of all objects returned by
\code{new()}, is \code{"S4"} except for classes that extend
one of the basic types, where the prototype has that basic type.  User
functions that depend on \code{\LinkA{typeof}{typeof}(object)} should be
careful to handle \code{"S4"} as a possible type.

Note that the \emph{name} of the first argument, \code{"Class"}
entails that \code{"Class"} is an undesirable slot name in any formal
class: \code{new("myClass", Class = <value>)} will not work.

The interpretation of the \code{...} arguments can be specialized to
particular classes, if an appropriate method has been defined for the
generic function \code{"initialize"}.  The \code{new} function calls
\code{initialize} with the object generated from the prototype as the
\code{.Object} argument to \code{initialize}.

By default, unnamed arguments in the \code{...} are interpreted as
objects from a superclass, and named arguments are interpreted as
objects to be assigned into the correspondingly named slots.  Thus,
explicit slots override inherited information for the same slot,
regardless of the order in which the arguments appear.

The \code{initialize} methods do not have to have \code{...} as
their second argument (see the examples).  Initialize methods are
often written when the natural parameters describing the new object
are not the names of the slots.  If you do define such a method,
note the implications for future subclasses of your class.  If these
have additional slots, and your \code{initialize} method has
\code{...} as a formal argument, then your method should pass such
arguments along via \code{\LinkA{callNextMethod}{callNextMethod}}.  If your method
does not have this argument, then either a subclass must have its
own method or else the added slots must be specified by users in
some way other than as arguments to \code{new}.

For examples of \code{initialize} methods, see
\code{\LinkA{initialize-methods}{initialize.Rdash.methods}} for existing methods for
classes \code{"traceable"} and \code{"environment"}, among
others. See the comments there on subclasses of
\code{"environment"}; any \code{initialize} methods for these should
be sure to allocate a new environment.

Methods for \code{initialize} can be inherited only by simple
inheritance, since it is a requirement that the method return an
object from the target class.  See the
\code{simpleInheritanceOnly} argument to \code{\LinkA{setGeneric}{setGeneric}} and
the discussion in \code{\LinkA{setIs}{setIs}} for the general concept.

Note that the basic vector classes, \code{"numeric"}, etc. are
implicitly defined, so one can use \code{new} for these classes.
\end{Details}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
 \LinkA{Classes}{Classes} for an overview of defining class, and
\code{\LinkA{setOldClass}{setOldClass}} for the relation to S3 classes. 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## using the definition of class "track" from \link{setClass}



## a new object with two slots specified
t1 <- new("track", x = seq_along(ydata), y = ydata)

# a new object including an object from a superclass, plus a slot
t2 <- new("trackCurve", t1, smooth = ysmooth)

### define a method for initialize, to ensure that new objects have
### equal-length x and y slots.

setMethod("initialize",
          "track",
          function(.Object, x = numeric(0), y = numeric(0)) {
            if(nargs() > 1) {
              if(length(x) != length(y))
                stop("specified x and y of different lengths")
              .Object@x <- x
              .Object@y <- y
            }
            .Object
          })

### the next example will cause an error (x will be numeric(0)),
### because we didn't build in defaults for x,
### although we could with a more elaborate method for initialize

try(new("track", y = sort(stats::rnorm(10))))

## a better way to implement the previous initialize method.
## Why?  By using callNextMethod to call the default initialize method
## we don't inhibit classes that extend "track" from using the general
## form of the new() function.  In the previous version, they could only
## use x and y as arguments to new, unless they wrote their own
## initialize method.

setMethod("initialize", "track", function(.Object, ...) {
    .Object <- callNextMethod()
    if(length(.Object@x) != length(.Object@y))
     stop("specified x and y of different lengths")
    .Object
  })

\end{ExampleCode}
\end{Examples}
\HeaderA{nonStructure-class}{A non-structure S4 Class for basic types }{nonStructure.Rdash.class}
\aliasA{Math,nonStructure-method}{nonStructure-class}{Math,nonStructure.Rdash.method}
\aliasA{Math2,nonStructure-method}{nonStructure-class}{Math2,nonStructure.Rdash.method}
\aliasA{Ops,nonStructure,nonStructure-method}{nonStructure-class}{Ops,nonStructure,nonStructure.Rdash.method}
\aliasA{Ops,nonStructure,vector-method}{nonStructure-class}{Ops,nonStructure,vector.Rdash.method}
\aliasA{Ops,vector,nonStructure-method}{nonStructure-class}{Ops,vector,nonStructure.Rdash.method}
\keyword{classes}{nonStructure-class}
%
\begin{Description}\relax
 S4 classes that are defined to extend one of the basic
vector classes should contain the class
\code{\LinkA{structure}{structure.Rdash.class}} if they behave like structures; that
is, if they should retain their class behavior under math functions
or operators, so long as their length is unchanged.
On the other hand, if their class depends on the values in the
object, not just its structure, then they should lose that class
under any such transformations.  In the latter case, they should be
defined to contain \code{nonStructure}.

If neither of these strategies applies, the class likely needs some
methods of its own for \code{\LinkA{Ops}{Ops}}, \code{\LinkA{Math}{Math}}, and/or
other generic functions. What is not usually a good idea is to allow
such computations to drop down to the default, base code.  This is
inconsistent with most definitions of such classes.
\end{Description}
%
\begin{Section}{Methods}
Methods are defined for operators and math functions (groups
\code{\LinkA{Ops}{Ops}}, \code{\LinkA{Math}{Math}} and  \code{\LinkA{Math2}{Math2}}.  In
all cases the result is an ordinary vector of the appropriate type.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{structure}{structure.Rdash.class}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setClass("NumericNotStructure", contains = c("numeric","nonStructure"))
xx <- new("NumericNotStructure", 1:10)
xx + 1 # vector
log(xx) # vector
sample(xx) # vector

\end{ExampleCode}
\end{Examples}
\HeaderA{ObjectsWithPackage-class}{A Vector of Object Names, with associated Package Names }{ObjectsWithPackage.Rdash.class}
\keyword{classes}{ObjectsWithPackage-class}
%
\begin{Description}\relax
This class of objects is used to represent ordinary character string
object names, extended with a \code{package} slot naming the package
associated with each object.
\end{Description}
%
\begin{Section}{Objects from the Class}
The function \code{\LinkA{getGenerics}{getGenerics}} returns an object of this class.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"character"}: the
object names.
\item[\code{package}:] Object of class \code{"character"} the
package names.

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"character"}, from data part.\\{}
Class \code{"vector"}, by class \code{"character"}.
\end{Section}
%
\begin{SeeAlso}\relax
 \code{Methods} for general background. 
\end{SeeAlso}
\HeaderA{promptClass}{Generate a Shell for Documentation of a Formal Class}{promptClass}
\keyword{programming}{promptClass}
\keyword{classes}{promptClass}
%
\begin{Description}\relax
Assembles all relevant slot and method information for a class, with
minimal markup for Rd processing; no QC facilities at present.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
promptClass(clName, filename = NULL, type = "class",
            keywords = "classes", where = topenv(parent.frame()),
            generatorName = clName)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{clName}] a character string naming the class to be documented.
\item[\code{filename}] usually, a connection or a character string giving the
name of the file to which the documentation shell should be written.
The default corresponds to a file whose name is the topic name for
the class documentation, followed by \code{".Rd"}.  Can also be
\code{NA} (see below).
\item[\code{type}] the documentation type to be declared in the output file.
\item[\code{keywords}] the keywords to include in the shell of the
documentation.  The keyword \code{"classes"} should be one of
them.
\item[\code{where}] where to look for the definition of the class and of
methods that use it.


\item[\code{generatorName}] the name for a generator function for this
class; only required if a generator function was created
\emph{and} saved under a name different from the class name.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The class definition is found on the search list.  Using that
definition, information about classes extended and slots is
determined.

In addition, the currently available generics with methods for this
class are found (using \code{\LinkA{getGenerics}{getGenerics}}).  Note that these
methods need not be in the same environment as the class definition; in
particular, this part of the output may depend on which packages are
currently in the search list.

As with other prompt-style functions, unless \code{filename} is
\code{NA}, the documentation shell is written to a file, and a message
about this is given.  The file will need editing to give information
about the \emph{meaning} of the class.  The output of
\code{promptClass} can only contain information from the metadata
about the formal definition and how it is used.

If \code{filename} is \code{NA}, a list-style representation of the
documentation shell is created and returned.  Writing the shell to a
file amounts to \code{cat(unlist(x), file = filename, sep = "\bsl{}n")},
where \code{x} is the list-style representation.

If a generator function is found assigned under the class name or
the optional \code{generatorName}, skeleton documentation for that
function is added to the file.
\end{Details}
%
\begin{Value}
If \code{filename} is \code{NA}, a list-style representation of the
documentation shell.  Otherwise, the name of the file written to is
returned invisibly.
\end{Value}
%
\begin{Author}\relax
VJ Carey \email{stvjc@channing.harvard.edu} and John Chambers
\end{Author}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{prompt}{prompt}} for documentation of functions,
\code{\LinkA{promptMethods}{promptMethods}} for documentation of method definitions.

For processing of the edited documentation, either use
\code{R CMD \LinkA{Rdconv}{Rdconv}},
or include the edited file in the \file{man} subdirectory of a
package.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## Not run: > promptClass("track")
A shell of class documentation has been written to the
file "track-class.Rd".

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{promptMethods}{ Generate a Shell for Documentation of Formal Methods }{promptMethods}
\keyword{programming}{promptMethods}
\keyword{methods}{promptMethods}
%
\begin{Description}\relax
Generates a shell of documentation for the methods of a generic
function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
promptMethods(f, filename = NULL, methods)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] a character string naming the generic function whose methods
are to be documented.
\item[\code{filename}] usually, a connection or a character string giving the
name of the file to which the documentation shell should be written.
The default corresponds to the coded topic name for these methods
(currently, \code{f} followed by \code{"-methods.Rd"}).  Can also be
\code{FALSE} or \code{NA} (see below).
\item[\code{methods}] Optional methods list object giving the methods to be
documented.  By default, the first methods object for this generic
is used (for example, if the current global environment has some
methods for \code{f}, these would be documented).

If this argument is supplied, it is likely to be
\code{getMethods(f, where)}, with \code{where} some package
containing methods for \code{f}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
If \code{filename} is \code{FALSE}, the text created is returned,
presumably to be inserted some other documentation file, such as the
documentation of the generic function itself (see
\code{\LinkA{prompt}{prompt}}). 

If \code{filename} is \code{NA}, a list-style representation of the
documentation shell is created and returned.  Writing the shell to a
file amounts to \code{cat(unlist(x), file = filename, sep = "\bsl{}n")},
where \code{x} is the list-style representation.

Otherwise, the documentation shell is written to the file specified by
\code{filename}.
\end{Details}
%
\begin{Value}
If \code{filename} is \code{FALSE}, the text generated;
if \code{filename} is \code{NA}, a list-style representation of the
documentation shell.
Otherwise, the name of the file written to is returned invisibly.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{prompt}{prompt}} and
\code{\LinkA{promptClass}{promptClass}}
\end{SeeAlso}
\HeaderA{ReferenceClasses}{Objects With Fields Treated by Reference (OOP-style)}{ReferenceClasses}
\aliasA{activeBindingFunction-class}{ReferenceClasses}{activeBindingFunction.Rdash.class}
\aliasA{defaultBindingFunction-class}{ReferenceClasses}{defaultBindingFunction.Rdash.class}
\aliasA{getRefClass}{ReferenceClasses}{getRefClass}
\aliasA{initFieldArgs}{ReferenceClasses}{initFieldArgs}
\aliasA{initRefFields}{ReferenceClasses}{initRefFields}
\aliasA{refClass-class}{ReferenceClasses}{refClass.Rdash.class}
\aliasA{refClassRepresentation-class}{ReferenceClasses}{refClassRepresentation.Rdash.class}
\aliasA{refMethodDef-class}{ReferenceClasses}{refMethodDef.Rdash.class}
\aliasA{refMethodDefWithTrace-class}{ReferenceClasses}{refMethodDefWithTrace.Rdash.class}
\aliasA{refObject-class}{ReferenceClasses}{refObject.Rdash.class}
\aliasA{refObjectGenerator-class}{ReferenceClasses}{refObjectGenerator.Rdash.class}
\aliasA{setRefClass}{ReferenceClasses}{setRefClass}
\aliasA{show,envRefClass-method}{ReferenceClasses}{show,envRefClass.Rdash.method}
\aliasA{show,refClassRepresentation-method}{ReferenceClasses}{show,refClassRepresentation.Rdash.method}
\aliasA{show,refMethodDef-method}{ReferenceClasses}{show,refMethodDef.Rdash.method}
\aliasA{SuperClassMethod-class}{ReferenceClasses}{SuperClassMethod.Rdash.class}
\aliasA{uninitializedField-class}{ReferenceClasses}{uninitializedField.Rdash.class}
\keyword{programming}{ReferenceClasses}
\keyword{classes}{ReferenceClasses}
%
\begin{Description}\relax
The software described here supports reference classes whose objects have
fields
accessed by reference in the style of ``OOP'' languages such as Java and
C++.
Computations with these objects invoke methods on them and
extract or set their fields.
The field and method computations potentially modify the object.
All computations referring to the objects see the modifications, in contrast to
the usual functional programming model in \R{}.
Reference classes can be used to program in \R{} directly or in combination
with an interface to an OOP-style language, allowing \R{}-written methods to
extend the interface.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setRefClass(Class, fields = , contains = , methods =,
     where =, ...)

getRefClass(Class, where =)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] 
character string name for the class.

In the call to \code{getRefClass()} this argument can also be any
object from the relevant class;  note also the corresponding reference
class methods documented in the section on ``Writing Reference Methods''.

\item[\code{fields}] 
either a character vector of field names or
a named list of the fields.  The resulting fields will be accessed with reference semantics (see
the  section on ``Reference Objects'').  If the argument is a list, the
elements of the list can be the character string name of a class, in
which case the field must be from that class or a subclass.

The element in the list can alternatively be an \emph{accessor
function}, a function of one argument that returns
the field if called with no argument or sets it to the value of the
argument otherwise.
Accessor functions are used internally and for inter-system interface
applications.
Their definition follows the rules for writing methods for the class:
they can refer to other fields and can call other methods for this
class or its superclasses.
See the section on ``Implementation'' for the internal mechanism
used by accessor functions.

Note that fields are distinct from
the slots, if any, in the object.  Slots are, as always, handled by
standard \R{} object management.  Slots for the class can be included
(as the \code{representation=} argument) in the \dots argument.

\item[\code{contains}] 
optional vector of superclasses for this class.  If a superclass is
also a reference class, the fields and class-based methods will be inherited.

\item[\code{methods}] 
a named list of function definitions that can be invoked on objects
from this class.  These can also be created by invoking the
\code{\$methods} method on the generator object returned. 
See the section on ``Writing Reference Methods'' for details.

Two optional method names are interpreted specially, \code{initialize}
and \code{finalize}. If an \code{initialize} method is defined, it
will be invoked when an object is generated from the class.  See the
discussion of method \code{\$new(...)} 
in the section ``Reference Object Generators''.

If a \code{finalize} method is defined, a function will be
\LinkA{registered}{reg.finalizer} to invoke it before the environment
in the object is discarded by the garbage collector. See the matrix
viewer example for both initialize and finalize methods.

\item[\code{where}] 
the environment in which to store the class definition.  Defaults to
the package namespace or environment for code that is part of an \R{}
package, and to the global environment for code sourced directly at
the session top level.

\item[\code{...}] 
other arguments to be passed to \code{\LinkA{setClass}{setClass}}.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{setRefClass} and \code{getRefClass} both return a generator object for the class. This is
itself a reference object, with methods to generate objects from the
class and also for defining new methods and for help-style
documentation. See the
section on ``Reference Class Generator Objects'' for details.
Note that \code{Class} in the call to \code{getRefClass()} can be an
object from the corresponding class, and that a similar reference
class method \code{\$getRefClass()} 
is available as well.

\code{setRefClass} defines the class and stores its class definition.
\code{getRefClass} requires that the class has been defined as a
reference class.

\end{Value}
%
\begin{Section}{Reference Objects}
Normal objects in \R{} are passed as arguments in function calls consistently with
functional programming semantics; that is, changes made to an object
passed as an argument are local to the function call.  The object that
supplied the argument is unchanged.

The functional model (sometimes called pass-by-value) is
suitable for many statistical computations and is implicit, for
example, in the basic \R{} software for fitting statistical models.
In some other situations, one would like all the code dealing with an
object to see the exact same content, so that changes made in any
computation would be reflected everywhere.
This is often suitable if the object has some ``objective''
reality, such as a window in a user interface.

In addition, commonly used languages, including Java, C++ and many
others, support a version of classes and methods assuming reference
semantics.
The corresponding programming mechanism
is to invoke a method on an object.
In the \R{} syntax that we use \code{"\$"} 
for this operation; one invokes a method,
\code{m1} say, on an object \code{x} by the expression
\code{x\$m1(...)}. 

Methods in this paradigm are associated with the object, or more
precisely with the class of the object, as opposed to methods in a
function-based class/method system, which are fundamentally associated
with the function (in \R{}, for example, a generic function in an \R{}
session has a table of all its currently known methods).
In this document ``methods for a class'' as opposed to
``methods for a function'' will make the distinction.

Objects in this paradigm usually have named fields on which
the methods operate.
In the \R{} implementation, the fields are defined when the class is
created.
The field itself can optionally have a specified class, meaning that only objects
from this class or one of its subclasses can be assigned to the field.
By default, fields have class \code{"ANY"}.
Fields may also be defined by supplying an accessor function which
will be called to get or set the field.
Accessor functions are likely when reference classes are part of an
inter-system interface.
The interface will usually supply the accessor functions automatically
based on the definition of the corresponding class in the other language.

Fields are accessed by reference.
In particular, invoking a method may modify the content of
the fields.

Programming for such classes involves writing new methods for a
particular class.
In the \R{} implementation, these methods are \R{} functions, with zero or
more formal arguments.
The object on which the methods are invoked is not an explicit
argument to the method.
Instead, fields and methods for the class can be referred to by name
in the method definition.
The implementation uses \R{} environments to make fields and methods
available by name.
Additional special fields allow reference to the complete object and
to the definition of the class.  See the section on ``Inheritance''.

The goal of the software described here is to provide a uniform
programming style in \R{} for software dealing with reference classes, whether
implemented directly in \R{} or through an interface to one of the OOP
languages.
\end{Section}
%
\begin{Section}{Writing Reference Methods}
Reference methods are functions supplied as elements of a named list,
either
when invoking \code{g\$methods()} 
on a generator object \code{g} or as
the argument \code{methods} in a call to \code{setRefClass}.
They are written as ordinary \R{} functions but have some special
features and restrictions.
The body of the function can contain calls to any other reference method,
including those inherited from other reference classes and may refer
to fields in the object by name.

Fields may be modified in a method by using the
non-local assignment operator, \code{<{}<-}, as in the \code{\$edit} and \code{\$undo}
methods in the example below.
Note that non-local assignment is required:  a local assignment with
the \code{<-} operator just creates a local object in the function
call, as it would in any \R{} function.
When methods are installed, a heuristic check is made for local
assignments to field names and a warning issued if any are detected.

Reference methods should be kept simple; if they need to do some
specialized \R{} computation, that computation should use a separate \R{}
function that is called from the reference method.
Specifically, methods can not use special features of the
enclosing environment mechanism, since the method's environment is
used to access fields and other methods.
In particular, methods should not use non-exported entries in the
package's namespace, because the methods may be inherited by a
reference class in another package.

Reference methods can not themselves be generic functions; if you want
additional function-based method dispatch, write a separate generic
function and call that from the method.

The entire object can be referred to in a method by the reserved
name \code{.self}, as shown in the \code{save=} method of the
example.
The special object \code{.refClassDef} contains the definition of the
class of the object.
These fields are read-only (it makes no sense to modify these
references), with one exception.
The \code{.self} field can be modified in the \code{\$initialize} 
method, because the object is still being created at this stage.
(Assignments to this field, as to all fields, need to use the
non-local assignment operator.)
This is the preferred way to assign S4-style attributes to the object,
if you need to do so; but remember that these attributes will not
behave according to reference semantics, unlike fields.

The methods available include methods inherited from superclasses, as
discussed in the next section.

Only methods actually used will be included in the environment
corresponding to an individual object.  If a method requires a
particular other method, then the first method should include a call
to \code{\$usingMethods()} 
with the name of the other method as an argument.
Declaring the methods this way is essential if the other method is used indirectly (e.g., via \code{\LinkA{sapply}{sapply}()}
or \code{\LinkA{do.call}{do.call}()}).
If it is called directly, code analysis will find it.
Declaring the method is harmless in any case, however, and may aid
readability of the source code.

Documentation for the methods can be obtained by the \code{\$help} 
method for the generator object.
Methods for classes are not documented in the \code{Rd} format used
for \R{} functions.
Instead, the \code{\$help} 
method prints the calling sequence of the method, followed by
self-documentation from the method definition, in the style of Python.
If the first element of the body of the method is a literal character
string (possibly multi-line), that string is interpreted as documentation.
See the method definitions in the example.
\end{Section}
%
\begin{Section}{Inheritance}
Reference classes inherit from other reference classes by using the
standard \R{} inheritance; that is, by including the superclasses in the
\code{contains=} argument when creating the new class.
Non-reference classes can also be included in the \code{contains=} argument.  The class definition
mechanism treats reference and non-reference superclasses slightly differently.
If the contained reference classes themselves have reference
superclasses, these will be moved ahead of any non-reference
superclasses in the class definition (otherwise the ordering of
superclasses may be ambiguous).
The names of the reference superclasses are in slot
\code{refSuperClasses} of the class definition.

Class fields are inherited.  A class definition can override a field
of the same name in a superclass only if the overriding class is a
subclass of the class of the inherited field.  This ensures that a
valid object in the field remains valid for the superclass as well.

Inherited methods are installed in the same way as directly
specified methods.
The code in a method can refer to  inherited methods in the same
way as directly specified methods.

A method may override a method of the same name in a superclass.
The overriding method can call the superclass method by
\code{callSuper(...)} as described below.

All reference classes inherit from the class \code{"envRefClass"},
which provides the following methods.

\begin{description}

\item[\code{\$callSuper(...)}]  
Calls the method inherited from a reference superclass.
The call is meaningful only from within another method, and will be
resolved to call the inherited method of the same name.
The arguments to \code{\$callSuper} 
are passed to the superclass version.
See the matrix viewer class in the example.

Note that the intended arguments for the superclass method must be
supplied explicitly; there is no convention for supplying the
arguments automatically, in contrast to the similar mechanism for
functional methods.


\item[\code{\$copy(shallow = FALSE)}]  
Creates a copy of the object.  With reference classes, unlike ordinary
\R{} objects, merely assigning the object with a different name does not
create an independent copy.  If \code{shallow} is \code{FALSE}, any
field that is itself a reference object will also be copied, and
similarly recursively for its fields.  Otherwise, while reassigning a
field to a new reference object will have no side effect, modifying
such a field will still be reflected in both copies of the object.
The argument has no effect on non-reference objects in fields.  When
there are reference objects in some fields but it is asserted that
they will not be modified, using \code{shallow = TRUE} will save some
memory and time.


\item[\code{\$field(name, value)}]  
With one argument, returns the field of the object with character
string \code{name}.  With two arguments, the corresponding field is
assigned \code{value}.  Assignment checks that \code{name} specifies a
valid field, but the single-argument version will attempt to get
anything of that name from the object's environment.

The \code{\$field()} 
method replaces the direct use of a field name, when the name of the
field must be calculated, or for looping over several fields.


\item[\code{\$export(Class)}]  
Returns the result of coercing the object to \code{Class} (typically
one of the superclasses of the object's class).  Calling the method
has no side effect on the object itself.


\item[\code{\$getRefClass()}; \code{\$getClass()}] 
These return respectively the generator object and the formal class
definition for the reference class of this object, efficiently.




\item[\code{\$import(value, Class = class(value))}]  
Import the object \code{value} into the current object, replacing the
corresponding fields in the current object.
Object \code{value} must come from one of the superclasses of the
current object's class.
If argument \code{Class} is supplied, \code{value} is first coerced to
that class.


\item[\code{\$initFields(...)}]  
Initialize the fields of the object from the supplied arguments.  This
method is usually only called from a class with a \code{\$initialize()}
method.  It corresponds to the default initialization for reference
classes.  If there are slots and non-reference superclasses, these may
be supplied in the \dots argument as well.

Typically, a specialized \code{\$initialize()}
method carries out its own computations, then invokes \code{\$initFields()}
to perform standard initialization, as shown in the
\code{matrixViewer} class in the example below.


\item[\code{\$show()}]  
This method is called when the object is printed automatically,
analogously to the \code{\LinkA{show}{show}} function.  A general method is
defined for class \code{"envRefClass"}.  User-defined reference
classes will often define their own method: see the Example below.

Note two points in the example.  As with any \code{show()} method, it
is a good idea to print the class explicitly to allow for subclasses
using the method.  Second, to call the \emph{function} \code{show()}
from the method, as opposed to the \code{\$show()} 
method itself, refer to \code{methods::show()} explicitly.


\item[\code{\$trace(what, ...)}, \code{\$untrace(what)} ] 
Apply the tracing and debugging facilities of the \code{\LinkA{trace}{trace}}
function to the reference method \code{what}.

All the arguments of the \code{\LinkA{trace}{trace}}
function can be supplied, except for \code{signature}, which is not
meaningful.

The reference method can be invoked on either an object or the
generator for the class.  See the section on Debugging below for details.


\item[\code{\$usingMethods(...)}]  
Reference methods used by this method are named as the arguments
either quoted or unquoted.  In the code analysis phase of installing the
the present method, the declared methods will be included.  It is essential
to declare any methods used in a nonstandard way (e.g., via an apply function).
Methods called directly do not need to be declared, but it is harmless to do so.
\code{\$usingMethods()} does nothing at run time. 


\end{description}
 

Objects also inherit two reserved fields:
\begin{description}

\item[\code{.self}] 
a reference to the entire object;

\item[\code{.refClassDef}] 
the class definition.


\end{description}
 
The defined fields should not override these, and in general it is
unwise to define a field whose name begins with \code{"."}, since the
implementation may use such names for special purposes.

\end{Section}
%
\begin{Section}{Reference Class Generator Objects}
The call to \code{setRefClass} defines the specified class and
returns a ``generator'' object for that class.
The generator object is itself a reference object (of class
\code{"refObjectGenerator"}).
Its fields are \code{def}, the class definition, and \code{className},
the character string name of the class.

Methods for generator objects exist to generate objects
from the class, to access help on reference methods, and to
define new reference methods for the class.
The currently available methods are:
\begin{description}

\item[\code{\$new(...)}]  
This method is equivalent to the function \code{\LinkA{new}{new}} with the
class name as an argument.  The \dots arguments are values for the
named fields.
If the class has a method defined for \code{\$initialize()}, 
this method will be called once the reference object has been
created.  You should write such a method for a class that needs to do
some special initialization.
In particular, a reference method is recommended rather than a method
for the S4 generic function \code{initialize()}, because some special initialization is
required for reference objects \emph{before} the initialization of
fields.
As with S4 classes, methods are written for \code{\$initialize()} 
and not for \code{\$new()}, 
both for the previous reason and also because \code{\$new()} 
is invoked on the generator object and would be a method for that class.

The default method for \code{\$initialize()} 
is equivalent to invoking the method \code{\$initFields(...)}. 
Named arguments assign initial values to the corresponding fields.
Unnamed arguments must be objects from this class or a reference
superclass of this class.
Fields will be initialized to the contents of the fields in such
objects, but named arguments override the corresponding inherited
fields.
Note that fields are simply assigned.  If the field is itself a
reference object, that object is not copied.
The new and previous object will share the reference.
Also, a field assigned from an unnamed argument counts as an
assignment for locked fields.
To override an inherited value for a locked field, the new value must
be one of the named arguments in the initializing call.
A later assignment of the field will result in an error.

For technical reasons, the
default method does not currently appear explicitly, but can be
invoked by \code{\$callSuper(...)} 
from a method for \code{\$initialize()}. 
Initialization methods need some care in design, as they do for S4
classes.
In particular, remember that others may subclass your class and pass
through field assignments or other arguments.  Therefore, your method
should normally include \dots as an argument, all other arguments
should have defaults or check for missingness, and your method should
pass all initialized values on via \code{\$callSuper()} or \code{\$initFields()} if
you know that your superclasses have no initialization methods.


\item[\code{\$help(topic)}]  
Prints brief help on the topic.  The topics recognized
are reference method names, quoted or not.

The information printed is the calling sequence for the method, plus
self-documentation if any.
Reference methods can have an initial character string or vector as
the first element in the body of the function defining the method.
If so, this string is taken as self-documentation for the method (see
the section on ``Writing Reference Methods'' for details).

If no topic is given or if the topic is not a method name, the
definition of the class is printed.

\item[\code{\$methods(...)}]  
With no arguments, returns a list of the reference methods for this
class.

Named arguments
are method definitions, which will be
installed in the class, as if they had been supplied in the
\code{methods} argument to \code{setRefClass()}.
Supplying methods in this way, rather than in the call to
\code{setRefClass()}, is largely for the sake of clearer source code
when many or large methods are being defined.
All methods for a class should be defined in the source code that
defines the class, typically as part of a package.
In particular, methods can not be redefined in a class in an attached
package with a namespace: The class method checks for a locked
binding of the class definition.


The new methods can refer to any currently defined method by name
(including other methods supplied in this call to
\code{\$methods()}. 
Note though that previously defined methods are not re-analyzed
meaning that they will not call the new method (unless it redefines an
existing method of the same name).

To remove a method, supply \code{NULL} as its new definition.


\item[\code{\$fields()}]  
Returns a list of the fields, each with its corresponding class.
Fields for which an accessor function was supplied in the definition
have class \code{"activeBindingFunction"}.


\item[\code{\$lock(...)}]  
The fields named in the arguments are locked; specifically, after the
lock method is called, the field may be set once.  Any further attempt
to set it will generate an error.

If called with no arguments, the method returns the names of the
locked fields.

Fields that are defined by an explicit accessor function can not be
locked (on the other hand, the accessor function can be defined to
generate an error if called with an argument).

All code to lock fields should normally be part of the definition of a
class; that is, the read-only nature of the fields is meant to be part
of the class definition, not a dynamic property added later.
In particular, fields can not be locked in a class in an attached
package with a namespace:  The class method checks for a locked
binding of the class definition.  Locked fields can not be
subsequently unlocked.


\item[\code{\$trace(what, ..., classMethod = FALSE)}]  
Establish a traced version of method \code{what} for objects generated
from this class.  The generator object tracing works like the
\code{\$trace()}
method for objects from the class, with two differences.
Since it changes the method definition in the class object itself,
tracing applies to all objects, not just the one on which the trace
method is invoked.

Second, the optional argument \code{classMethod = TRUE} allows tracing
on the methods of the generator object itself, such as \code{\$new()}.
By default, \code{what} is interpreted as the name of a method in the
class for which this object is the generator.


\item[\code{\$accessors(...)}]  
A number of
systems using the OOP programming paradigm recommend or enforce
\emph{getter and setter methods}
corresponding to each field, rather than direct access by name.
In the \R{} version presented here (and fairly often elsewhere
as well), a field named \code{abc} of an object \code{x} would be
extracted by \code{x\$getAbc()} and assigned by
\code{x\$setAbc(value)}.
The \code{\$accessors} 
method is a convenience function that creates getter and setter methods for the
specified fields.


\end{description}
 
\end{Section}
%
\begin{Section}{Implementation}
Reference classes are implemented as S4 classes with a data part of
type \code{"environment"}.
An object generated from a reference class has this type.
Fields correspond to named objects in the environment.
A field associated with an accessor function is implemented as an
\LinkA{active binding}{bindenv}.
In addition, fields with a specified class are implemented as a
special form of active binding to enforce valid assignment to the
field.
A field, say \code{data}, can be accessed generally by an expression
of the form \code{x\$data} 
for any object from the relevant class.
In a method for this class, the field can be accessed by the name
\code{data}.
A field that is not locked can be set by an expression of the form
\code{x\$data <- value}.
Inside a method, a field can be assigned by an expresion of the form
\code{x <{}<- value}.
Note the \LinkA{non-local assignment}{assignOps} operator.
The standard \R{} interpretation of this operator works to assign it in
the environment of the object.
If the field has an accessor function defined, getting and setting
will call that function.

When a method is invoked on an object, the function defining the method is
installed in the object's environment, with the same environment as the
environment of the function.

\end{Section}
%
\begin{Section}{Inter-System Interfaces}
A number of
languages use a similar reference-based programming model with classes
and class-based methods.
Aside from differences in choice of terminology and other details,
many of these languages are compatible with the programming style
described here.
\R{} interfaces to the languages exist in a number of packages.

The reference class definitions here provide a hook for
classes in the foreign language to be exposed in \R{}.
Access to fields and/or methods in the class can be
implemented by defining an \R{} reference class corresponding to
classes made available through the interface.
Typically, the inter-system interface will take care of the details of
creating the \R{} class, given a description of the foreign class (what fields
and methods it has, the classes for the fields, whether any are
read-only, etc.)
The specifics for the fields and methods can be implemented via
reference methods for the \R{} class.
In particular, the use of active bindings allows field access for
getting and setting, with
actual access handled by the inter-system interface.

\R{} methods and/or fields can be included in the class definition as for any
reference class.
The methods can use or set fields and can call other methods transparently
whether the field or method comes from the interface or is defined
directly in \R{}.

For an inter-system interface using this approach, see the code for package \code{Rcpp}, version
0.8.7 or later.
\end{Section}
%
\begin{Section}{Debugging}
The standard \R{} debugging and tracing facilities can be applied to
reference methods.
Reference methods can be passed to \code{\LinkA{debug}{debug}} and its
relatives from an object to debug further method invocations on that
object; for example, \code{debug(xx\$edit)}. 

Somewhat more flexible use is available for a reference method version
of the \code{\LinkA{trace}{trace}} function.
A corresponding \code{\$trace()} 
reference method is available for
either an object or for the reference class generator
(\code{xx\$trace()} or \code{mEdit\$trace()} in the example below).
Using \code{\$trace()} on an object sets up a tracing
version for future invocations of the specified method for that
object.
Using \code{\$trace()} on the generator for the class sets up a
tracing version for all future objects from that class (and for all
existing objects that have not yet invoked the traced method, because
reference methods are cached lazily in the object when first invoked).

In either case, all the arguments to the standard  \code{\LinkA{trace}{trace}}
function are available, except for \code{signature=} which is
meaningless since reference methods can not be S4 generic functions.
This includes the typical style \code{trace(what, browser)} for
interactive debugging and  \code{trace(what, edit = TRUE)} to edit the
reference method interactively.

\end{Section}
%
\begin{Author}\relax
John Chambers
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
## a simple editor for matrix objects.  Method  $edit() changes some
## range of values; method $undo() undoes the last edit.
mEdit <- setRefClass("mEdit",
      fields = list( data = "matrix",
        edits = "list"),
      methods = list(
     edit = function(i, j, value) {
       ## the following string documents the edit method
       'Replaces the range [i, j] of the
        object by value.
        '
         backup <-
             list(i, j, data[i,j])
         data[i,j] <<- value
         edits <<- c(edits, list(backup))
         invisible(value)
     },
     undo = function() {
       'Undoes the last edit() operation
        and update the edits field accordingly.
        '
         prev <- edits
         if(length(prev)) prev <- prev[[length(prev)]]
         else stop("No more edits to undo")
         edit(prev[[1]], prev[[2]], prev[[3]])
         ## trim the edits list
         length(edits) <<- length(edits) - 2
         invisible(prev)
     },
     show = function() {
       'Method for automatically printing matrix editors'
       cat("Reference matrix editor object of class",
          classLabel(class(.self)), "\n")
       cat("Data: \n")
       methods::show(data)
       cat("Undo list is of length", length(edits), "\n")
     }
     ))

xMat <- matrix(1:12,4,3)
xx <- mEdit$new(data = xMat)
xx$edit(2, 2, 0)
xx
xx$undo()
mEdit$help("undo")
stopifnot(all.equal(xx$data, xMat))

utils::str(xx) # show fields and names of non-trivial methods

## add a method to save the object
mEdit$methods(
     save = function(file) {
       'Save the current object on the file
        in R external object format.
       '
         base::save(.self, file = file)
     }
)

tf <- tempfile()
xx$save(tf)


## Not run: 
## Inheriting a reference class:  a matrix viewer
mv <- setRefClass("matrixViewer",
    fields = c("viewerDevice", "viewerFile"),
    contains = "mEdit",
    methods = list( view = function() {
        dd <- dev.cur(); dev.set(viewerDevice)
        devAskNewPage(FALSE)
        matplot(data, main = paste("After",length(edits),"edits"))
        dev.set(dd)},
        edit = # invoke previous method, then replot
          function(i, j, value) {
            callSuper(i, j, value)
            view()
          }))

## initialize and finalize methods
mv$methods( initialize =
  function(file = "./matrixView.pdf", ...) {
    viewerFile <<- file
    pdf(viewerFile)
    viewerDevice <<- dev.cur()
    dev.set(dev.prev())
    callSuper(...)
  },
  finalize = function() {
    dev.off(viewerDevice)
  })

## debugging an object: call browser() in method $edit()
xx$trace(edit, browser)

## debugging all objects from class mEdit in method $undo()
mEdit$trace(undo, browser)

## End(Not run)
 
\end{ExampleCode}
\end{Examples}
\HeaderA{representation}{ Construct a Representation or a Prototype for a Class Definition}{representation}
\aliasA{prototype}{representation}{prototype}
\keyword{programming}{representation}
\keyword{classes}{representation}
%
\begin{Description}\relax
In calls to
\code{\LinkA{setClass}{setClass}}, these two functions construct,
respectively, the \code{representation} and \code{prototype}
arguments.  They do various checks and handle special cases.  You're
encouraged to use them when defining classes that, for
example, extend other classes as a data part or have multiple
superclasses, or that combine extending a class and slots.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
representation(...)
prototype(...)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] 
The call to representation takes arguments that are single character
strings.  Unnamed arguments are classes that a newly defined class
extends; named arguments name the explicit slots in the new class,
and specify what class each slot should have.

In the call to \code{prototype}, if an unnamed argument is
supplied, it unconditionally forms the basis for the prototype
object.  Remaining arguments are taken to correspond to slots of
this object.  It is an error to supply more than one unnamed argument.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The \code{representation} function applies tests for the validity of
the arguments.  Each must specify the name of a class.

The classes named don't have to exist when \code{representation} is
called, but if they do, then the function will check for any duplicate
slot names introduced by each of the inherited classes.

The arguments to \code{prototype} are usually named initial values
for slots, plus an optional first argument that gives the object
itself.  The unnamed argument is typically useful if there is a data
part to the definition (see the examples below).
\end{Details}
%
\begin{Value}
The value of \code{representation}  is just the list of arguments, after these have been checked
for validity.

The value of \code{prototype} is the object to be used as the
prototype.  Slots will have been set consistently with the
arguments, but the construction does \emph{not} use the class
definition to test validity of the contents (it hardly can, since
the prototype object is usually supplied to create the definition).
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
 \code{\LinkA{setClass}{setClass}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## representation for a new class with a directly define slot "smooth"
## which should be a "numeric" object, and extending class "track"
representation("track", smooth ="numeric")


setClass("Character",representation("character"))
setClass("TypedCharacter",representation("Character",type="character"),
          prototype(character(0),type="plain"))
ttt <- new("TypedCharacter", "foo", type = "character")


setClass("num1", representation(comment = "character"),
         contains = "numeric",
         prototype = prototype(pi, comment = "Start with pi"))



\end{ExampleCode}
\end{Examples}
\HeaderA{S3Part}{ S3-style Objects and S4-class Objects}{S3Part}
\aliasA{coerce,ANY,S3-method}{S3Part}{coerce,ANY,S3.Rdash.method}
\aliasA{coerce,ANY,S4-method}{S3Part}{coerce,ANY,S4.Rdash.method}
\aliasA{coerce,oldClass,S3-method}{S3Part}{coerce,oldClass,S3.Rdash.method}
\aliasA{isXS3Class}{S3Part}{isXS3Class}
\aliasA{S3}{S3Part}{S3}
\aliasA{S3-class}{S3Part}{S3.Rdash.class}
\aliasA{S3Class}{S3Part}{S3Class}
\aliasA{S3Class<\Rdash}{S3Part}{S3Class<.Rdash.}
\aliasA{S3Part<\Rdash}{S3Part}{S3Part<.Rdash.}
\aliasA{S4}{S3Part}{S4}
\aliasA{slotsFromS3}{S3Part}{slotsFromS3}
\keyword{programming}{S3Part}
\keyword{classes}{S3Part}
%
\begin{Description}\relax
Old-style (S3) classes may be registered as S4 classes (by calling
\code{\LinkA{setOldClass}{setOldClass}}, and many have been.  These classes can
then be contained in (that is, superclasses of) regular S4 classes, allowing formal methods
and slots to be added to the S3 behavior.  The function
\code{S3Part} extracts or replaces 
the S3 part of such an object.
\code{S3Class} extracts or
replaces the S3-style class.  \code{S3Class} also applies to object
from an S4 class with \code{S3methods=TRUE} in the call to \code{\LinkA{setClass}{setClass}}.

See the details below.
Also discussed are S3 <-> S4 coercion; see the section
``S3 and S4 objects''
\end{Description}
%
\begin{Usage}
\begin{verbatim}

S3Part(object, strictS3 = FALSE, S3Class)

S3Part(object, strictS3 = FALSE, needClass = ) <- value

S3Class(object)

S3Class(object) <-  value

isXS3Class(classDef)

slotsFromS3(object)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}

\item[\code{object}]  An object from some class that extends a registered
S3 class,
usually because the class has as
one of its superclasses an S3 class registered by a call to
\code{\LinkA{setOldClass}{setOldClass}}, or from a class that extends a basic
vector, matrix or array object type.  See the details.

For most of the functions, an S3 object can also be supplied,
with the interpretation that it is its own S3 part.

\item[\code{strictS3}]   If \code{TRUE}, the value returned by
\code{S3Part} will be an S3 object, with all the S4 slots
removed.  Otherwise, an S4 object will always
be returned; for example, from the S4 class created by
\code{\LinkA{setOldClass}{setOldClass}} as a proxy for an S3 class, rather than
the underlying S3 object.

\item[\code{S3Class}]  The character vector to be stored as the S3 class
slot in the object.  Usually, and by default, retains
the slot from \code{object}.


\item[\code{needClass}] Require that the replacement value be this class or a
subclass of it.


\item[\code{value}]  For \code{S3Part<-}, the replacement value for the S3 part of the object.
This does \emph{not} need to be an S4 object; in fact, the
usual way to create objects from these classes is by giving an
S3 object of the right class as an argument to
\code{\LinkA{new}{new}}.

For \code{S3Class<-}, the character vector that will be used as
a proxy for \code{class(x)} in S3 method dispatch.  This
replacement function can be used to control S3 per-object method
selection.



\item[\code{classDef}]  A class definition object, as returned by \code{\LinkA{getClass}{getClass}}.



\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Classes that register S3 classes by a call to
\code{\LinkA{setOldClass}{setOldClass}} have slot \code{".S3Class"} to hold
the corresponding S3 vector of class strings.
The prototype of such
a class has the value for this slot determined  by the argument to
\code{\LinkA{setOldClass}{setOldClass}}.
Other S4 classes will have the same slot if the argument
\code{S3methods = TRUE} is supplied to \code{\LinkA{setClass}{setClass}}; in
this case, the slot is set to the S4 inheritance of the class.

New S4 classes that extend (contain) such
classes also have the same slot, and by default the prototype has
the value determined  by the \code{contains=} argument to
\code{\LinkA{setClass}{setClass}}.
Individual objects from the S4 class may
have 
an S3 class corresponding to the value in the prototype or to an
(S3) subclass of that value.  See the examples below.

\code{S3Part()}  with \code{strictS3 = TRUE} constructs the underlying S3 object by eliminating
all the formally defined slots and turning off the S4 bit of the
object.  With  \code{strictS3 = FALSE} the object returned is from
the corresponding S4 class.  For consistency and generality,
\code{S3Part()} works also for classes that extend the basic vector,
matrix and array classes.  Since \R{} is somewhat arbitrary about what
it treats as an S3 class (\code{"ts"} is, but \code{"matrix"} is
not), \code{S3Part()} tries to return an S3 (that is, non-S4) object
whenever the S4 class has a suitable superclass, of either S3 or
basic object type.

One general application that relies on this generality is to use
\code{S3Part()} to get a superclass object that is guaranteed not to
be an S4 object.  If you are calling some function that checks for
S4 objects, you need to be careful not to end up in a closed loop
(\code{fooS4} calls \code{fooS3}, which checks for an S4 object and
calls \code{fooS4} again, maybe indirectly).  Using \code{S3Part()}
with \code{strictS3 = TRUE} is a mechanism to avoid such loops.


Because the contents of S3 class objects have no definition or
guarantee, the computations involving S3 parts  do
\emph{not} check for slot validity.  Slots are implemented
internally in \R{} as attributes, which are copied when present in the
S3 part.  Grave problems can occur if an S4 class
extending an S3 class uses the name of an S3 attribute as the name
of an S4 slot, and S3 code sets the attribute to an object from an
invalid class according to the S4 definition.

Frequently, \code{S3Part} can and should be avoided by simply
coercing objects to the desired class; methods are automatically
defined to deal correctly with the slots when \code{\LinkA{as}{as}} is
called to extract or replace superclass objects.

The function \code{slotsFromS3()} is a generic function used
internally to access the slots associated with the S3 part of the
object.  Methods for this function are created automatically when
\code{\LinkA{setOldClass}{setOldClass}} is called with the \code{S4Class}
argument.  Usually, there is only one S3 slot, containing the S3
class, but the \code{S4Class} argument may provide additional slots,
in the case that the S3 class has some guaranteed attributes that
can be used as formal S4 slots.  See the corresponding section in
the documentation of \code{\LinkA{setOldClass}{setOldClass}}.
\end{Details}
%
\begin{Value}

\code{S3Part}:  Returns or sets  the S3 information
(and possibly some S4 slots as well, depending on arguments
\code{S3Class} and \code{keepSlots}).  See the discussion of
argument \code{strict} above.  If it is \code{TRUE} the value
returned is an S3 object.


\code{S3Class}:  Returns or sets the character vector of S3 class(es) stored in
the object, if the class has the corresponding \code{.S3Class} slot.
Currently, the function defaults to \code{\LinkA{class}{class}} otherwise.

\code{isXS3Class}: Returns \code{TRUE} or \code{FALSE} according
to whether the class defined by \code{ClassDef}
extends S3 classes (specifically, whether it has the slot for
holding the S3 class).

\code{slotsFromS3}: returns a list of the relevant slot classes, or an
empty list for any other object.
\end{Value}
%
\begin{Section}{S3 and S4 Objects: Conversion Mechanisms}

Objects in \R{} have an internal bit that indicates whether or not to
treat the object as coming from an S4 class.  This bit is tested by
\code{\LinkA{isS4}{isS4}} and can be set on or off by \code{\LinkA{asS4}{asS4}}.
The latter function, however, does no checking or interpretation;
you should only use it if you are very certain every detail has been
handled correctly.

As a friendlier alternative, methods have been defined for coercing
to the virtual classes \code{"S3"} and \code{"S4"}.  The expressions
\code{as(object, "S3")}  and \code{as(object, "S4")}  return S3
and S4 objects, respectively.  In addition, they attempt
to do conversions in a valid way, and also check validity when
coercing to S4.

The expression \code{as(object, "S3")} can be used in two ways.  For
objects from one of the registered S3 classes, the expression will
ensure that the class attribute is the full multi-string S3 class
implied by \code{class(object)}.  If the registered class has known
attribute/slots, these will also be provided.

Another use of  \code{as(object, "S3")}  is to take an S4 object and
turn it into an S3 object with corresponding attributes.  This is
only meaningful with S4 classes that have a data part.  If you want
to operate on the object without invoking S4 methods, this
conversion is usually the safest way.

The expression  \code{as(object, "S4")} will use the attributes in
the object to create an object from the S4 definition of
\code{class(object)}. This is a general mechanism to create
partially defined version of S4 objects via S3 computations  (not
much different from invoking \code{\LinkA{new}{new}} with corresponding
arguments, but usable in this form even if the S4 object has an
initialize method with different arguments). 
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version).

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
  \code{\LinkA{setOldClass}{setOldClass}} 
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## two examples extending S3 class "lm", class "xlm" directly
## and "ylm" indirectly
setClass("xlm", representation(eps = "numeric"), contains = "lm")
setClass("ylm", representation(header = "character"), contains = "xlm")

## lm.D9 is as computed in the example for stats::lm
y1 = new("ylm", lm.D9, header = "test", eps = .1)
xx = new("xlm", lm.D9, eps =.1)
y2 = new("ylm", xx, header = "test")
stopifnot(inherits(y2, "lm"))
stopifnot(identical(y1, y2))
stopifnot(identical(S3Part(y1, strict = TRUE), lm.D9))

## note the these classes can insert an S3 subclass of "lm" as the S3 part:
myData <- data.frame(time = 1:10, y = (1:10)^.5)
myLm <- lm(cbind(y, y^3)  ~ time, myData) # S3 class: c("mlm", "lm")
ym1 = new("ylm", myLm, header = "Example", eps = 0.)

##similar classes to "xlm" and "ylm", but extending S3 class c("mlm", "lm")
setClass("xmm", representation(eps = "numeric"), contains = "mlm")
setClass("ymm", representation(header="character"), contains = "xmm")

ym2 <- new("ymm", myLm, header = "Example2", eps = .001)

# but for class "ymm", an S3 part of class "lm" is an error:
try(new("ymm", lm.D9, header = "Example2", eps = .001))

setClass("dataFrameD", representation(date = "Date"),
         contains = "data.frame")
myDD <- new("dataFrameD", myData, date = Sys.Date())

## S3Part() applied to classes with a data part (.Data slot)

setClass("NumX", contains="numeric", representation(id="character"))
nn = new("NumX", 1:10, id="test")
stopifnot(identical(1:10, S3Part(nn, strict = TRUE)))
          
m1 = cbind(group, weight)
setClass("MatX", contains = "matrix", representation(date = "Date"))
mx1 = new("MatX", m1, date = Sys.Date())
stopifnot(identical(m1, S3Part(mx1, strict = TRUE)))


\end{ExampleCode}
\end{Examples}
\HeaderA{S4groupGeneric}{S4 Group Generic Functions}{S4groupGeneric}
\aliasA{Arith}{S4groupGeneric}{Arith}
\aliasA{Compare}{S4groupGeneric}{Compare}
\aliasA{Complex}{S4groupGeneric}{Complex}
\aliasA{GroupGenericFunctions}{S4groupGeneric}{GroupGenericFunctions}
\aliasA{Logic}{S4groupGeneric}{Logic}
\aliasA{Math}{S4groupGeneric}{Math}
\aliasA{Math2}{S4groupGeneric}{Math2}
\aliasA{Ops}{S4groupGeneric}{Ops}
\aliasA{Summary}{S4groupGeneric}{Summary}
\keyword{methods}{S4groupGeneric}
%
\begin{Description}\relax
Methods can be defined for \emph{group generic functions}.  Each group
generic function has a number of \emph{member} generic functions
associated with it.

Methods  defined for a group generic function cause the same
method to be defined for each member of the group, but a method explicitly
defined for a  member of the group takes precedence over a
method defined, with the same signature, for the group generic.

The functions shown in this documentation page all reside in the
\pkg{methods} package, but the mechanism is available to any
programmer, by calling \code{\LinkA{setGroupGeneric}{setGroupGeneric}} (provided package
\pkg{methods} is attached).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## S4 group generics:
Arith(e1, e2)
Compare(e1, e2)
Ops(e1, e2)
Logic(e1, e2)
Math(x)
Math2(x, digits)
Summary(x, ..., na.rm = FALSE)
Complex(z)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x, z, e1, e2}] objects.
\item[\code{digits}] number of digits to be used in \code{round} or \code{signif}.
\item[\code{...}] further arguments passed to or from methods.
\item[\code{na.rm}] logical: should missing values be removed?
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Methods can be defined for the group generic functions by calls to
\code{\LinkA{setMethod}{setMethod}} in the usual way.
Note that the group generic functions
should never be called directly
-- a suitable error message will result if they are.  When metadata
for a group generic is loaded, the methods defined become methods
for the members of the group, but only if no method has been
specified directly for the member function for the same signature.
The effect is that group generic definitions are selected before
inherited methods but after directly specified methods.  For more on
method selection, see \code{\LinkA{Methods}{Methods}}.

There are also
S3 groups \code{Math}, \code{Ops}, \code{Summary} and
\code{Complex}, see \code{?\LinkA{S3groupGeneric}{S3groupGeneric}},
with no corresponding \R{} objects, but these are irrelevant for S4
group generic functions.

The members of the group defined by a particular generic can be
obtained by calling \code{\LinkA{getGroupMembers}{getGroupMembers}}. For the group
generic functions currently defined in this package the members are
as follows:
\begin{description}

\item[\code{Arith}] \code{"+"}, \code{"-"}, \code{"*"}, \code{"\textasciicircum{}"},
\code{"\%\%"}, \code{"\%/\%"}, \code{"/"}
\item[\code{Compare}] \code{"=="}, \code{">"}, \code{"<"},
\code{"!="}, \code{"<="}, \code{">="}
\item[\code{Logic}] \code{"\&"}, \code{"|"}.

\item[\code{Ops}] \code{"Arith"}, \code{"Compare"}, \code{"Logic"}
\item[\code{Math}] \code{"abs"}, \code{"sign"}, \code{"sqrt"},
\code{"ceiling"}, \code{"floor"}, \code{"trunc"},
\code{"cummax"}, \code{"cummin"}, \code{"cumprod"}, \code{"cumsum"},
\code{"log"}, \code{"log10"}, \code{"log2"}, \code{"log1p"},
\code{"acos"}, \code{"acosh"},
\code{"asin"}, \code{"asinh"}, \code{"atan"}, \code{"atanh"},
\code{"exp"}, \code{"expm1"}, \code{"cos"}, \code{"cosh"},
\code{"sin"}, \code{"sinh"}, \code{"tan"}, \code{"tanh"},
\code{"gamma"}, \code{"lgamma"}, \code{"digamma"},
\code{"trigamma"}

\item[\code{Math2}] \code{"round"}, \code{"signif"}
\item[\code{Summary}] \code{"max"}, \code{"min"}, \code{"range"},
\code{"prod"}, \code{"sum"}, \code{"any"}, \code{"all"}
\item[\code{Complex}] \code{"Arg"}, \code{"Conj"}, \code{"Im"},
\code{"Mod"}, \code{"Re"}

\end{description}

Note that \code{Ops} merely consists of three sub groups.

All the functions in these groups (other than the group generics
themselves) are basic functions in \R{}.  They are not by default S4 generic
functions, and many of them are defined as primitives.  However, you can still define
formal methods for them, both individually and via the group generics.  It all works more or less as you
might expect, admittedly via a bit of trickery in the background.
See \LinkA{Methods}{Methods} for details.

Note that two members of the \code{Math} group, \code{\LinkA{log}{log}} and
\code{\LinkA{trunc}{trunc}}, have \dots as an extra formal argument.
Since methods for \code{Math} will have only one formal argument,
you must set a specific method for these functions in order to call
them with the extra argument(s).

For further details about group generic functions see section 10.5 of
\emph{Software for Data Analysis}.

\end{Details}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version).
\end{References}
%
\begin{SeeAlso}\relax
 The function \code{\LinkA{callGeneric}{callGeneric}} is nearly always
relevant when writing a method for a group generic.  See the
examples below and in section 10.5 of \emph{Software for Data Analysis}.

See \LinkA{S3groupGeneric}{S3groupGeneric} for S3 group generics.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setClass("testComplex", representation(zz = "complex"))
## method for whole group "Complex"
setMethod("Complex", "testComplex",
          function(z) c("groupMethod", callGeneric(z@zz)))
## exception for Arg() :
setMethod("Arg", "testComplex",
          function(z) c("ArgMethod", Arg(z@zz)))
z1 <- 1+2i
z2 <- new("testComplex", zz = z1)
stopifnot(identical(Mod(z2), c("groupMethod", Mod(z1))))
stopifnot(identical(Arg(z2), c("ArgMethod", Arg(z1))))
\end{ExampleCode}
\end{Examples}
\HeaderA{SClassExtension-class}{Class to Represent Inheritance (Extension) Relations }{SClassExtension.Rdash.class}
\keyword{classes}{SClassExtension-class}
%
\begin{Description}\relax
  An object from this class represents a single `is'
relationship; lists of these objects are used to represent all the
extensions (superclasses) and subclasses for a given class.  The
object contains information about how the relation is defined and
methods to coerce, test, and replace correspondingly. 
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects from this class are generated by \code{\LinkA{setIs}{setIs}},
from direct calls and from the \code{contains=} information in a call to \code{\LinkA{setClass}{setClass}}, and from class unions created by \code{\LinkA{setClassUnion}{setClassUnion}}.
In the last case, the information is stored in defining the \emph{subclasses} of the union class (allowing unions to contain sealed classes).
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{subClass,superClass}:] The classes being extended:
corresponding to the \code{from}, and \code{to} arguments to \code{\LinkA{setIs}{setIs}}. 
\item[\code{package}:] The package to which that class belongs. 
\item[\code{coerce}:] A function to carry out the as() computation
implied by the relation.  Note that these functions should
\emph{not} be used directly.  They only deal with the
\code{strict=TRUE} calls to the \code{\LinkA{as}{as}} function, with
the full method constructed from this mechanically. 
\item[\code{test}:] The function that would test whether the
relation holds.  Except for explicitly specified \code{test}
arguments to \code{\LinkA{setIs}{setIs}}, this function is trivial. 
\item[\code{replace}:] The method used to implement \code{as(x,
    Class) <- value}.
\item[\code{simple}:] A \code{"logical"} flag, \code{TRUE} if this
is a simple relation, either because one class is contained in the
definition of another, or because a class has been explicitly
stated to extend a virtual class.  For simple extensions, the
three methods are generated automatically.
\item[\code{by}:] If this relation has been constructed
transitively, the first intermediate class from the subclass. 
\item[\code{dataPart}:] A \code{"logical"} flag, \code{TRUE} if
the extended class is in fact the data part of the subclass.  In
this case the extended class is a basic class (i.e., a type). 
\item[\code{distance}:] The distance between the two classes,
1 for directly contained classes, plus the number of generations between otherwise.  
\end{description}

\end{Section}
%
\begin{Section}{Methods}
No methods defined with class \code{"SClassExtension"} in the
signature.
\end{Section}
%
\begin{SeeAlso}\relax
\code{\LinkA{is}{is}},
\code{\LinkA{as}{as}}, and the
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}} class.
\end{SeeAlso}
\HeaderA{selectSuperClasses}{Super Classes (of Specific Kinds) of a Class}{selectSuperClasses}
\aliasA{.selectSuperClasses}{selectSuperClasses}{.selectSuperClasses}
\keyword{programming}{selectSuperClasses}
\keyword{classes}{selectSuperClasses}
%
\begin{Description}\relax
Return superclasses of \code{ClassDef}, possibly only non-virtual or
direct or simple ones.

These functions are designed to be fast, and consequently only work
with the \code{contains} slot of the corresponding class definitions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
selectSuperClasses(Class, dropVirtual = FALSE, namesOnly = TRUE,
                   directOnly = TRUE, simpleOnly = directOnly,
                   where = topenv(parent.frame()))

.selectSuperClasses(ext, dropVirtual = FALSE, namesOnly = TRUE,
                    directOnly = TRUE, simpleOnly = directOnly)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] name of the class or (more efficiently) the class
definition object (see \code{\LinkA{getClass}{getClass}}).
\item[\code{dropVirtual}] logical indicating if only non-virtual superclasses
should be returned.
\item[\code{namesOnly}] logical indicating if only a vector names instead of
a named list class-extensions should be returned.
\item[\code{directOnly}] logical indicating if only a \emph{direct} super
classes should be returned.
\item[\code{simpleOnly}] logical indicating if only simple class extensions
should be returned.
\item[\code{where}] (only used when \code{Class} is not a class definition)
environment where the class definition of \code{Class} is found.
\item[\code{ext}] for \code{.selectSuperClasses()} only, a \code{\LinkA{list}{list}}
of class extensions, typically \code{\LinkA{getClassDef}{getClassDef}(..)@contains}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
a \code{\LinkA{character}{character}} vector (if \code{namesOnly} is true, as per
default) or a list of class extensions (as the \code{contains} slot in
the result of \code{\LinkA{getClass}{getClass}}).
\end{Value}
%
\begin{Note}\relax
The typical user level function is \code{selectSuperClasses()}
which calls \code{.selectSuperClasses()}; i.e., the latter should only
be used for efficiency reasons by experienced useRs.
\end{Note}
%
\begin{SeeAlso}\relax
\code{\LinkA{is}{is}}, \code{\LinkA{getClass}{getClass}}; further, the more technical
class \code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}} documentation.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setClass("Root")
setClass("Base", contains = "Root", representation(length = "integer"))
setClass("A", contains = "Base", representation(x = "numeric"))
setClass("B", contains = "Base", representation(y = "character"))
setClass("C", contains = c("A", "B"))

extends("C")   #-->  "C"  "A" "B"  "Base" "Root"
selectSuperClasses("C") # "A" "B"
selectSuperClasses("C", direct=FALSE) # "A" "B"  "Base"  "Root"
selectSuperClasses("C", dropVirt = TRUE, direct=FALSE)# ditto w/o "Root"
\end{ExampleCode}
\end{Examples}
\HeaderA{setClass}{Create a Class Definition}{setClass}
\aliasA{classGeneratorFunction-class}{setClass}{classGeneratorFunction.Rdash.class}
\keyword{programming}{setClass}
\keyword{classes}{setClass}
\keyword{methods}{setClass}
%
\begin{Description}\relax
Create  a class definition, specifying the representation (the
slots) and/or the classes contained in this one (the superclasses),
plus other optional details.  As a side effect, the class definition
is stored in the specified environment.  A generator function
is returned as the value of \code{setClass()}, suitable for creating
objects from the class if the class is not virtual.  Of the many
arguments to the function only \code{Class},
\code{representation} and \code{contains} are usually needed.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setClass(Class, representation, prototype, contains=character(),
         validity, access, where, version, sealed, package,
         S3methods = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Class}] character string name for the class.
\item[\code{representation}]  a named list of the slots that the new class should have, the names giving the names of the slots and the corresponding elements being the character string names of  the corresponding classes.
Usually a call to
the \code{\LinkA{representation}{representation}} function.

Backward compatibility and compatibility with S-Plus allows unnamed
elements for superclasses, but the recommended style is to use the
\code{contains=} argument instead.
\item[\code{prototype}]  an object providing the default
data for the slots in this class.  By default, each will be the
prototype object for the superclass.  If provided, using a call to
\code{\LinkA{prototype}{prototype}} will carry out some checks. 
\item[\code{contains}]  the names (and optionally package slots) for the \emph{superclasses} of this class.

\item[\code{where}]  the
environment in which to store the
definition.  Should not be supplied in standard use.  For calls to \code{setClass()} appearing in the
source code for a package, will default to the namespace of
the package.  For calls typed or sourced at the top level in a
session, will default to the global environment.

\item[\code{validity}]  if supplied, should be a validity-checking method
for objects from this class (a function that returns \code{TRUE} if
its argument is a valid object of this class and one or more strings
describing the failures otherwise).  See \code{\LinkA{validObject}{validObject}}
for details.
\item[\code{access, version}] access and version, included for
historical compatibility with S-Plus, but ignored.
\item[\code{sealed}]  if \code{TRUE}, the class definition will be sealed,
so that another call to \code{setClass} will fail on this class name.

\item[\code{package}]  an optional package name for the class.  Should very
rarely be used. By default
the name of the package in which the class definition is assigned.

\item[\code{S3methods}] if \code{TRUE}, S3 methods may be written for this
class.  S3 generic functions and primitives will
dispatch an S3 method defined for this class, given an S4 object
from the class or from a subclass of it, provided no S4
method and no more
direct S3 method is found.  This argument should rarely be used:
It is not needed for
classes that are defined via \code{\LinkA{setOldClass}{setOldClass}} or for
classes that extend such classes, which will nearly always be
the case when S3 methods are relevant.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A generator function suitable for creating objects from the class is
returned, invisibly.  A call to this function generates a call to
\code{\LinkA{new}{new}} for the class.  The call takes any number of arguments,
which will be passed on to the initialize method.  If no
\code{initialize} method is defined for the class or one of its
superclasses, the default method expects named arguments with the
name of one of the slots.

Typically the generator function is assigned the name of the class,
for programming clarity.  This is not a requirement and objects
from the class can also be generated directly from
\code{\LinkA{new}{new}}.  The advantages of the generator function are a
slightly simpler and clearer call, and that the call will contain
the package name of the class (eliminating any ambiguity if two
classes from different packages have the same name).

If the class is virtual, an attempt to generate an object  from
either the generator or \code{new()}
will result in an error.
\end{Value}
%
\begin{Section}{Basic Use: Slots and Inheritance}
The two essential arguments other than the class name are
\code{representation} and \code{contains}, defining the explicit slots
and the inheritance (superclasses). Together, these arguments define
all the information in an object from this class; that is, the names
of all the slots and the classes required for each of them.

The name of the class determines
which methods apply directly to objects from this class.  The
inheritance information specifies which methods apply indirectly,
through inheritance.  See \LinkA{Methods}{Methods}.

The slots in a class definition will be the union of all the slots
specified directly by \code{representation} and all the slots in all
the contained classes.
There can only be one slot with a given name; specifically, the
direct and inherited slot names must be unique.
That does not, however, prevent the same class from being inherited
via more than one path.

One kind of element in the \code{contains=} argument is special, specifying one of the \R{}
object types or one of a few other special \R{} types (\code{matrix} and
\code{array}).
See the section on inheriting from object types, below.


Slot name \code{"class"} is not allowed in the current implementation but
reserved. \code{"Class"} is valid, but undesirable, as it cannot be
used in \code{\LinkA{new}{new}(<cl>, Class = <slot-value>)} (because of
argument name matching).
There are other slot names with a special meaning; these names start with
the \code{"."} character.  To be safe, you should define all of
your own slots with names starting with an alphabetic character.
\end{Section}
%
\begin{Section}{Inheriting from Object Types}
In addition to containing other S4 classes, a class definition can
contain either an S3 class (see the next section) or a built-in R pseudo-class---one
of the \R{}
object types or one of the special \R{} pseudo-classes \code{"matrix"} and
\code{"array"}.
A class can contain at most one of the object types, directly or indirectly.
When it does, that contained class determines the ``data part''
of the class.

Objects from the new class try to inherit the built in
behavior of the contained type.
In the case of normal \R{} data types, including vectors, functions and
expressions, the implementation is relatively straightforward.
For any object \code{x} from the class,
\code{typeof(x)} will be the contained basic type; and a special
pseudo-slot, \code{.Data}, will be shown with the corresponding class.
See the \code{"numWithId"} example below.

Classes may also inherit from \code{"vector"}, \code{"matrix"} or
\code{"array"}.
The data part of these objects can be any vector data type.

For an object from any class that does \emph{not} contain one of these
types or classes,
\code{typeof(x)} will be \code{"S4"}.

Some \R{} data types do not behave normally, in the sense that they are
non-local references or other objects that are not duplicated.
Examples include those corresponding to classes \code{"environment"}, \code{"externalptr"}, and \code{"name"}.
These can not be the types for objects with user-defined
classes (either S4 or S3) because setting an attribute overwrites the
object in all contexts.
It is possible to define a class that inherits from such types,
through an indirect mechanism that stores the inherited object in a
reserved slot.
See the
example for class \code{"stampedEnv"} below.
S3 method dispatch and the relevant \code{as.}\emph{type}\code{()}
functions should behave correctly, but code that uses the type of the
object directly will not.

Also, keep in mind that the object passed to low-level computations
will be the underlying object type, \emph{without} any of the slots
defined in the class.
To return the full information, you will usually have to define a
method that sets the data part.

\end{Section}
%
\begin{Section}{Inheriting from S3 Classes}
Old-style S3 classes have no formal definition.  Objects are
``from'' the class when their class attribute contains the
character string considered to be the class name.

Using such classes with formal classes and methods is necessarily a
risky business, since there are no guarantees about the content of the
objects or about consistency of inherited methods.
Given that, it is still possible to define a class that inherits from
an S3 class, providing that class has been registered as an old class
(see \code{\LinkA{setOldClass}{setOldClass}}).

Broadly speaking, both S3 and S4 method dispatch try to behave
sensibly with respect to inheritance in either system.
Given an S4 object, S3 method dispatch and the \code{\LinkA{inherits}{inherits}}
function should use the S4 inheritance information.
Given an S3 object, an S4 generic function will dispatch S4 methods
using the S3 inheritance, provided that inheritance has been declared via
\code{\LinkA{setOldClass}{setOldClass}}.

\end{Section}
%
\begin{Section}{Classes and Packages}

Class definitions normally belong to packages (but can be defined in
the  global environment as well, by evaluating the expression on the
command line or in a file sourced from the command line).
The corresponding package name is part of the class definition; that
is, part of the \code{classRepresentation} object holding that
definition.  Thus, two classes with the same name can exist in
different packages, for most purposes.

When a class name is supplied for a slot or a superclass in a call to
\code{setClass}, a
corresponding class definition will be found, looking from the
namespace of the current package, assuming the call in question appears directly in the source for the
package, as it should to avoid ambiguity.
The  class definition
must be found in the namespace of the current package, in the imports for that
namespace or in the basic classes defined by the methods package.
(The methods package must be included in the \code{Depends} directive
of the package's \code{"DESCRIPTION"} file in order for the
\code{"CMD check"} utility to find these classes.)

When this rule does not identify a class uniquely (because it appears
in more than one imported package) then the \code{\LinkA{packageSlot}{packageSlot}}
of the character string name needs to be supplied with the name.
This should be a rare occurrence.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{Classes}{Classes}} for a general discussion of classes,
\code{\LinkA{Methods}{Methods}} for an analogous discussion of methods,
\code{\LinkA{makeClassRepresentation}{makeClassRepresentation}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}

## A simple class with two slots
track <- setClass("track",
         representation(x="numeric", y="numeric"))
## an object from the class
t1 <- track(x = 1:10, y = 1:10 + rnorm(10))

## A class extending the previous, adding one more slot
trackCurve <- setClass("trackCurve",
    representation(smooth = "numeric"),
    contains = "track")

## an object containing a superclass object
t1s <- trackCurve(t1, smooth = 1:10)

## A class similar to "trackCurve", but with different structure
## allowing matrices for the "y" and "smooth" slots
setClass("trackMultiCurve",
         representation(x="numeric", y="matrix", smooth="matrix"),
         prototype = list(x=numeric(), y=matrix(0,0,0),
                          smooth= matrix(0,0,0)))
## See ?setIs for further examples using these classes

## A class that extends the built-in data type "numeric"

numWithId <- setClass("numWithId", representation(id = "character"),
         contains = "numeric")

numWithId(1:3, id = "An Example")

## inherit from reference object of type "environment"
stampedEnv <-setClass("stampedEnv", contains = "environment",
      representation(update = "POSIXct"))
setMethod("[[<-", c("stampedEnv", "character", "missing"),
   function(x, i, j, ..., value) {
       ev <- as(x, "environment")
       ev[[i]] <- value  #update the object in the environment
       x@update <- Sys.time() # and the update time
       x})


e1 <- stampedEnv(update = Sys.time())

e1[["noise"]] <- rnorm(10)


\end{ExampleCode}
\end{Examples}
\HeaderA{setClassUnion}{Classes Defined as the Union of Other Classes}{setClassUnion}
\aliasA{ClassUnionRepresentation-class}{setClassUnion}{ClassUnionRepresentation.Rdash.class}
\aliasA{isClassUnion}{setClassUnion}{isClassUnion}
\keyword{programming}{setClassUnion}
\keyword{classes}{setClassUnion}
%
\begin{Description}\relax
A class may be defined as the \emph{union} of other classes; that
is, as a virtual class defined as a superclass of several other
classes. Class unions are useful in method signatures or as slots in
other classes, when we want to allow one of several classes to be supplied.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setClassUnion(name, members, where)
isClassUnion(Class)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}]  the name for the new union class. 
\item[\code{members}]  the classes that should be members of this union.
\item[\code{where}]  where to save the new class definition; by default,
the environment of the package in which the \code{setClassUnion}
call appears, or the global environment if called outside of the
source of a package.


\item[\code{Class}]  the name or definition of a class.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The classes in \code{members} must be defined before creating the
union.  However, members can be added later on to an existing
union, as shown in the example below. Class unions can be
members of other class unions.

The prototype object in the class union definition will be
\code{NULL} if class \code{"NULL"} is a member of the union and
the prototype object of the first member class otherwise (as of
version 2.15.0 of R; earlier versions had a \code{NULL} prototype even if
that was not valid).

Class unions are the only way to create a class that is extended by
a class whose definition is sealed (for example, the
basic datatypes or other classes defined in the base or methods
package in R are sealed).  You cannot say \code{setIs("function", "other")}
unless \code{"other"} is a class union.  In general, a
\code{setIs} call of this form changes the definition of the
first class mentioned (adding \code{"other"} to the list of
superclasses contained in the definition of \code{"function"}).

Class unions get around this by not modifying the first class
definition, relying instead on storing information in the subclasses
slot of the class union.  In order for this technique to work, the
internal computations for expressions such as
\code{\LinkA{extends}{extends}(class1, class2)} work
differently for class unions than for regular classes; specifically,
they test whether any class is in common between the superclasses of
\code{class1} and the subclasses of \code{class2}.

The different behavior for class unions is made possible because the
class definition object for class unions has itself a special class,
\code{"ClassUnionRepresentation"}, an extension of class
\code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}.

\end{Details}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
## a class for either numeric or logical data
setClassUnion("maybeNumber", c("numeric", "logical"))

## use the union as the data part of another class
setClass("withId", representation("maybeNumber", id = "character"))

w1 <- new("withId", 1:10, id = "test 1")
w2 <- new("withId", sqrt(w1)%%1 < .01, id = "Perfect squares")

## add class "complex" to the union "maybeNumber"
setIs("complex", "maybeNumber")

w3 <- new("withId", complex(real = 1:10, imaginary = sqrt(1:10)))

## a class union containing the existing class  union "OptionalFunction"
setClassUnion("maybeCode",
    c("expression", "language", "OptionalFunction"))

is(quote(sqrt(1:10)), "maybeCode")  ## TRUE


\end{ExampleCode}
\end{Examples}
\HeaderA{setGeneric}{Define a New Generic Function}{setGeneric}
\aliasA{setGroupGeneric}{setGeneric}{setGroupGeneric}
\keyword{programming}{setGeneric}
\keyword{methods}{setGeneric}
%
\begin{Description}\relax
Create a new generic function of the given name, that is, a function
that dispatches methods according to the classes of the arguments,
from among the formal methods defined for this function.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setGeneric(name, def= , group=list(), valueClass=character(),
           where= , package= , signature= , useAsDefault= ,
           genericFunction= , simpleInheritanceOnly = )

setGroupGeneric(name, def= , group=list(), valueClass=character(),
                knownMembers=list(), package= , where= )
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{name}]  The character string name of the generic function.
The simplest (and recommended) call, \code{setGeneric(name)},
looks for a function with this name and creates a corresponding
generic function,  if the function found was not generic.  In the
latter case, the existing function becomes the default method.

\item[\code{def}] An optional function object, defining the generic.
Don't supply this argument if you want to turn an existing non-generic
function into a generic. In this case, you usually want to use the
simple call with one argument.

Do supply \code{def} if there is no
current function of this name or for some reason you do not want
to use that function to define the generic. In that case, the
formal arguments and 
default values for the generic are taken from \code{def}.  In most
cases, the body of \code{def} will then define the default method,
as the existing function did in the one-argument call.

If you want to create a new generic function with \emph{no}
default method, then \code{def} should be only a call to
\code{\LinkA{standardGeneric}{standardGeneric}} with the same character string as
\code{name}.



\item[\code{group}]  Optionally, a character string giving the name of the group
generic function to which this function belongs.    See
\LinkA{Methods}{Methods} for details of group generic functions in method selection.

\item[\code{valueClass}]  An optional character vector of one or more class
names.  The value returned by the generic function must
have (or extend) this class, or one of the classes; otherwise,
an error is generated.

\item[\code{package}]  The name of the package with which this function is
associated.  Usually determined automatically (as the package
containing the non-generic version if there is one, or else the
package where this generic is to be saved).

\item[\code{where}]  Where to store the resulting initial methods definition,
and possibly the generic function; by
default, stored into the top-level environment.

\item[\code{signature}] 
Optionally, the vector of names, from among the formal arguments to
the function, that can appear in the signature of methods for this
function, in calls to \code{\LinkA{setMethod}{setMethod}}.  If \dots is one of
the formal arguments, it is treated specially.  Starting with
version 2.8.0 of \R{}, \dots may be signature of the generic function.
Methods will then be selected if their signature matches all the
\dots arguments.  See the documentation for topic \LinkA{dotsMethods}{dotsMethods}
for details.  In the present version, it is not possible to mix
\dots and other arguments in the signature (this restriction may be
lifted in later versions).

By default, the signature is inferred from the implicit generic
function corresponding to a non-generic function.  If no implicit
generic function has been defined, the default is all the formal
arguments except \dots, in the order they appear in the function
definition. In the case that \dots is the only formal argument, that
is also the default signature.  To use \dots as the signature in a
function that has any other arguments, you must supply the signature
argument explicitly.  See the ``Implicit Generic'' section
below for more details.

\item[\code{useAsDefault}] 
Override the usual choice of default argument.
Argument \code{useAsDefault} can be supplied, either as a function
to use for the default, or as a logical value.
This argument is now rarely needed.
See
the section on details.

\item[\code{simpleInheritanceOnly}] 
Supply this argument as \code{TRUE} to require that methods selected
be inherited through simple inheritance only; that is, from
superclasses specified in the \code{contains=} argument to
\code{\LinkA{setClass}{setClass}}, or by simple inheritance to a class union or
other virtual class.  Generic functions should require simple
inheritance if they need to be assured that they get the complete
original object, not one that has been transformed.  Examples of
functions requiring simple inheritance are \code{\LinkA{initialize}{initialize}},
because by definition it must return an object from the same class
as its argument, and \code{\LinkA{show}{show}}, because it claims to give a
full description of the object provided as its argument.

\item[\code{genericFunction}] Don't use; for (possible) internal use only.

\item[\code{knownMembers}] 
(For \code{setGroupGeneric} only.)  The names of functions that are
known to be members of this group.  This information is used to
reset cached definitions of the member generics when information
about the group generic is changed.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
The \code{setGeneric} function exists for its side effect: saving the
generic function to allow methods to be specified later.  It returns
\code{name}.
\end{Value}
%
\begin{Section}{Basic Use}
The \code{setGeneric} function is called to initialize a generic
function as preparation for defining some methods for that function.

The simplest and most common situation is that \code{name} is already
an ordinary non-generic non-primitive function, and you now want to
turn this function into a generic.  In this case you will most often
supply only \code{name}, for example:

\code{setGeneric("colSums")}

There must be an existing function of this name, on some attached
package (in this case package \code{"base"}).  A generic version of
this function will be created in the current package (or in the global
environment if the call to \code{setGeneric()} is from an ordinary
source file or is entered on the command line).  The existing function
becomes the default method, and the package slot of the new generic
function is set to the location of the original function
(\code{"base"} in the example).  It's an important feature that the
same generic function definition is created each time, depending in
the example only on the definition of \code{print} and where it is
found.  The \code{signature} of the generic function, defining which
of the formal arguments can be used in specifying methods, is set by
default to all the formal arguments except \dots.

Note that calling \code{setGeneric()} in this form is not strictly
necessary before calling \code{setMethod()} for the same function.  If
the function specified in the call to \code{setMethod} is not generic,
\code{setMethod} will execute the call to \code{setGeneric} itself.
Declaring explicitly that you want the function to be generic can be
considered better programming style; the only difference in the
result, however, is that not doing so produces a message noting the
creation of the generic function.

You cannot (and never need to) create an explicit generic version of
the primitive functions in the base package.  Those which can be
treated as generic functions have methods selected and dispatched from
the internal C code, to satisfy concerns for efficiency, and the
others cannot be made generic.  See the section on Primitive Functions
below.

The description above is the effect when the package that owns the
non-generic function has not created an implicit generic version.
Otherwise, it is this implicit generic function that is used. See the
section on Implicit Generic Functions below.  Either way, the
essential result is that the \emph{same} version of the generic
function will be created each time.

The second common use of \code{setGeneric()} is to create a new
generic function, unrelated to any existing function, and frequently
having no default method.  In this case, you need to supply a skeleton
of the function definition, to define the arguments for the function.
The body of a generic function is usually a standard form,
\code{standardGeneric(name)} where \code{name} is the quoted name of
the generic function.  When calling \code{setGeneric} in this form,
you would normally supply the \code{def} argument as a function of
this form.  See the second and third examples below.

The \code{useAsDefault} argument controls the default method for the
new generic.  If not told otherwise, \code{setGeneric} will try to
find a non-generic version of the function to use as a default.  So,
if you do have a suitable default method, it is often simpler to first
set this up as a non-generic function, and then use the one-argument
call to \code{setGeneric} at the beginning of this section.  See the
first example in the Examples section below.

If you \emph{don't} want the existing function to be taken as default,
supply the argument \code{useAsDefault}.  That argument can be the
function you want to be the default method, or \code{FALSE} to force
no default (i.e., to cause an error if there is no direct or inherited
method selected for a call to the function).
\end{Section}
%
\begin{Section}{Details}
The great majority of calls to \code{setGeneric()} should either
have one argument to ensure that an existing function can have
methods, or arguments \code{name} and \code{def} to create a new
generic function and optionally a default method.  If that's not
what you plan to do, read on.

If you want to change the behavior of an existing function (typically,
one in another package) when you create a generic version, you must
supply arguments to \code{setGeneric} correspondingly.  Whatever
changes are made, the new generic function will be assigned with a
package slot set to the \emph{current} package, not the one in which
the non-generic version of the function is found.  This step is
required because the version you are creating is no longer the same as
that implied by the function in the other package.  A message will be
printed to indicate that this has taken place and noting one of the
differences between the two functions.  It tends to be a bad idea,
because the two versions are now competing for methods, with many
chances for mistakes in programming.

The body of a generic function usually does nothing except for
dispatching methods by a call to \code{standardGeneric}.  Under some
circumstances you might just want to do some additional computation in
the generic function itself.  As long as your function eventually
calls \code{standardGeneric} that is permissible (though perhaps not a
good idea, in that it may make the behavior of your function less easy
to understand).  If your explicit definition of the generic function
does \emph{not} call \code{standardGeneric} you are in trouble,
because none of the methods for the function will ever be dispatched.

By default, the generic function can return any object.  If
\code{valueClass} is supplied, it should be a vector of class names;
the value returned by a method is then required to satisfy
\code{is(object, Class)} for one of the specified classes.  An empty
(i.e., zero length) vector of classes means anything is allowed.  Note
that more complicated requirements on the result can be specified
explicitly, by defining a non-standard generic function.

The \code{setGroupGeneric} function behaves like \code{setGeneric}
except that it constructs a group generic function, differing in two
ways from an ordinary generic function.  First, this function cannot
be called directly, and the body of the function created will contain
a stop call with this information.  Second, the group generic function
contains information about the known members of the group, used to
keep the members up to date when the group definition changes, through
changes in the search list or direct specification of methods, etc.
\end{Section}
%
\begin{Section}{Implicit Generic Functions}
Saying that a non-generic function ``is converted to a generic''
is more precisely state that the function is converted to the
corresponding \emph{implicit} generic function.  If no special action
has been taken, any function corresponds implicitly to a generic
function with the same arguments, in which all arguments other than
\dots can be used.  The signature of this generic function is the
vector of formal arguments, in order, except for \dots.

The source code for a package can define an implicit generic function
version of any function in that package (see \LinkA{implicitGeneric}{implicitGeneric}
for the mechanism).  You can not, generally, define an implicit
generic function in someone else's package. The usual reason for
defining an implicit generic is to prevent certain arguments from
appearing in the signature, which you must do if you want the
arguments to be used literally or if you want to enforce lazy
evaluation for any reason.  An implicit generic can also contain some
methods that you want to be predefined; in fact, the implicit generic
can be any generic version of the non-generic function.  The implicit
generic mechanism can also be used to prohibit a generic version (see
\code{\LinkA{prohibitGeneric}{prohibitGeneric}}).

Whether defined or inferred automatically, the implicit generic will
be compared with the generic function that \code{setGeneric} creates,
when the implicit generic is in another package.  If the two functions
are identical, then the \code{package} slot of the created generic
will have the name of the package containing the implicit generic.
Otherwise, the slot will be the name of the package in which the
generic is assigned.

The purpose of this rule is to ensure that all methods defined for a
particular combination of generic function and package names
correspond to a single, consistent version of the generic function.
Calling \code{setGeneric} with only \code{name} and possibly
\code{package} as arguments guarantees getting the implicit generic
version, if one exists.

Including any of the other arguments can force a new, local version of
the generic function.  If you don't want to create a new version,
don't use the extra arguments.
\end{Section}
%
\begin{Section}{Generic Functions and Primitive Functions}
A number of the basic \R{} functions are specially implemented as
primitive functions, to be evaluated directly in the underlying C code
rather than by evaluating an \R{} language definition.  Most have
implicit generics (see \code{\LinkA{implicitGeneric}{implicitGeneric}}), and become
generic as soon as methods (including group methods) are defined on
them.  Others cannot be made generic.

Even when methods are defined for such functions, the generic version
is not visible on the search list, in order that the C version
continues to be called.  Method selection will be initiated in the C
code.  Note, however, that the result is to restrict methods for
primitive functions to signatures in which at least one of the classes
in the signature is a formal S4 class.

To see the generic version of a primitive function, use
\code{\LinkA{getGeneric}{getGeneric}(name)}.  The function
\code{\LinkA{isGeneric}{isGeneric}} will tell you whether methods are defined
for the function in the current session.

Note that S4 methods can only be set on those primitives which are
`\LinkA{internal generic}{internal generic}', plus \code{\%*\%}.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{Methods}{Methods}} and the links there for a general discussion,
\code{\LinkA{dotsMethods}{dotsMethods}} for methods that dispatch on
``\dots'', and \code{\LinkA{setMethod}{setMethod}} for method definitions.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}


## create a new generic function, with a default method
setGeneric("props", function(object) attributes(object))

## A new generic function with no default method
setGeneric("increment",
  function(object, step, ...)
    standardGeneric("increment")
)


###   A non-standard generic function.  It insists that the methods
###   return a non-empty character vector (a stronger requirement than
###    valueClass = "character" in the call to setGeneric)

setGeneric("authorNames",
    function(text) {
      value <- standardGeneric("authorNames")
      if(!(is(value, "character") && any(nchar(value)>0)))
        stop("authorNames methods must return non-empty strings")
      value
      })



## An example of group generic methods, using the class
## "track"; see the documentation of \link{setClass} for its definition

## define a method for the Arith group

setMethod("Arith", c("track", "numeric"),
 function(e1, e2) {
  e1@y <- callGeneric(e1@y , e2)
  e1
})

setMethod("Arith", c("numeric", "track"),
 function(e1, e2) {
  e2@y <- callGeneric(e1, e2@y)
  e2
})

## now arithmetic operators  will dispatch methods:

t1 <- new("track", x=1:10, y=sort(stats::rnorm(10)))

t1 - 100
1/t1


\end{ExampleCode}
\end{Examples}
\HeaderA{setLoadActions}{Set Actions For Package Loading}{setLoadActions}
\aliasA{evalOnLoad}{setLoadActions}{evalOnLoad}
\aliasA{evalqOnLoad}{setLoadActions}{evalqOnLoad}
\aliasA{getLoadActions}{setLoadActions}{getLoadActions}
\aliasA{hasLoadAction}{setLoadActions}{hasLoadAction}
\aliasA{setLoadAction}{setLoadActions}{setLoadAction}
\keyword{package}{setLoadActions}
%
\begin{Description}\relax
These functions 
provide a mechanism
for packages to specify computations to be done during the loading of
the package namespace.
Such actions are a flexible way to provide information only available
at load time (such as locations in a dynamically linked library).


A call to
\code{setLoadAction()}  or \code{setLoadActions()} specifies one or more functions
to be
called when the corresponding package is loaded, with the \dots argument
names being used as identifying names for the actions.

\code{getLoadActions} reports the currently defined load actions,
given a package's namespace as its argument.

\code{hasLoadAction} returns \code{TRUE} if a load action
corresponding to the given name has previously been set for the
\code{where} namespace.

\code{evalOnLoad()} and \code{evalqOnLoad()} schedule a specific expression for
evaluation at load time.
\end{Description}
%
\begin{Usage}
\begin{verbatim}

setLoadAction(action, aname=, where=)

setLoadActions(..., .where=)

getLoadActions(where=)

hasLoadAction(aname, where=)

evalOnLoad(expr, where=, aname=)

evalqOnLoad(expr, where=, aname=)

\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}

\item[\code{action, ...}] 
functions of one or more arguments, to be called when this package is
loaded. The functions will be called with one argument (the package
namespace) so all following arguments must have default values.

If the elements of \dots are named, these names will be used for the
corresponding load metadata.


\item[\code{where, .where}] 
the namespace of the package for which the list of load actions are
defined. This argument is
normally omitted if the call comes from the source code for the package itself, but will
be needed if a package supplies load actions for another package.


\item[\code{aname}] the name for the action.  If an action is set without
supplying a name,  the
default uses the position in the sequence of actions specified
(\code{".1"}, etc.).


\item[\code{expr}] an expression to be evaluated in a load action in
environment \code{where}.  In the case of \code{evalqOnLoad()},
the expression is interpreted literally, in that of
\code{evalOnLoad()} it must be precomputed, typically as an object
of type \code{"language"}.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The \code{evalOnLoad()} and \code{evalqOnLoad()} functions are for
convenience.
They construct a function to evaluate the expression and call
\code{setLoadAction()} to schedule a call to that function.

Each of the functions supplied as an argument to \code{setLoadAction()} or
\code{setLoadActions()} is saved as metadata in the
namespace, typically that of the package containing the call to
\code{setLoadActions()}.
When this package's namespace is loaded, each of these functions will
be called.
Action functions are called in the order they are supplied to
\code{setLoadActions()}.
The objects assigned have metadata names constructed from the names
supplied in the call; unnamed arguments are taken to be named by their
position in the list of actions (\code{".1"}, etc.).

Multiple calls to \code{setLoadAction()} or  \code{setLoadActions()} can be used in a package's
code; the actions will be scheduled after any previously specified,
except if the name given to \code{setLoadAction()} is that of an
existing action.
In typical applications, \code{setLoadActions()} is more convenient
when calling from the package's own code to set several actions.
Calls to \code{setLoadAction()} are more convenient if the action name
is to be constructed, which is more typical when one package
constructs load actions for another package.

Actions can be revised by assigning with the same name, actual or
constructed, in a subsequent call.
The replacement must still be a valid function, but can of course do
nothing if the intention was to remove a previously specified action.

The functions must have at least one argument.  They will be called
with one argument, the namespace of the package.
The functions will be called at the end of processing of S4 metadata, after
dynamically linking any libraries, the call to \code{.onLoad()}, if
any, and caching method and class definitions, but before the namespace is sealed.

Functions may therefore assign or modify objects in the namespace
supplied as the argument in the call.
The mechanism allows packages to save information not available until
load time, such as values obtained from a dynamically linked library.

Load actions should be contrasted with user load hooks supplied by
\code{\LinkA{setHook}{setHook}()}.
User hooks are generally provided from outside the package and are run
after the namespace has been sealed.
Load actions are part of the package code, and the list of actions is
normally established when the package is installed.


Load actions can be supplied directly in the source code for a package.
It is also possible and useful to provide facilities in one package to
create load actions in another package.
The software needs to be careful to assign the action
functions in the correct environment, namely the namespace of the target
package.

\end{Details}
%
\begin{Value}
\code{setLoadAction()}  and \code{setLoadActions()} are called for their side effect and return no
useful value.

\code{getLoadActions()} returns a named list of the actions in the
supplied namespace.

\code{hasLoadAction()} returns \code{TRUE} if the specified action
name appears in the actions for this package.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
## in the code for some package

## ... somewhere else
setLoadActions(function(attach)
   cat(c("Loaded", "Unloaded")[attach], "at", Sys.time(), "\n"),
  setCount = function(ns) assign("myCount", 1, envir = ns),
  function(ns) assign("myPointer", getMyExternalPointer(), envir = ns))
  ... somewhere later
if(countShouldBe0)
  setLoadAction(function(ns) assign("myCount", 0, envir = ns), "setCount")

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{setMethod}{ Create and Save a Method }{setMethod}
\aliasA{removeMethod}{setMethod}{removeMethod}
\keyword{programming}{setMethod}
\keyword{classes}{setMethod}
\keyword{methods}{setMethod}
%
\begin{Description}\relax
Create and save a formal method for a given function and list of classes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setMethod(f, signature=character(), definition,
          where = topenv(parent.frame()),
          valueClass = NULL, sealed = FALSE)

removeMethod(f, signature, where)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}]  A generic function or the character-string name of the function. 
\item[\code{signature}]  A match of formal argument names for \code{f} with
the character-string names of corresponding classes.  See the
details below; however, if the signature is not trivial, you should use \code{\LinkA{method.skeleton}{method.skeleton}} to generate a valid call to \code{setMethod}.
\item[\code{definition}]  A function definition, which will become the method
called when the arguments in a call to \code{f} match the
classes in \code{signature}, directly or through inheritance. 
\item[\code{where}] the environment in which to store the definition of the
method.
For \code{setMethod}, it is recommended to omit this argument and to include the call in source code that is evaluated at the top level; that is, either in an R session by something equivalent to a call to \code{\LinkA{source}{source}}, or as part of the R source code for a package.

For \code{removeMethod}, the default is the location of the (first)
instance of the method for this signature.
\item[\code{valueClass}]  Obsolete and unused, but see the same argument for \code{\LinkA{setGeneric}{setGeneric}}. 
\item[\code{sealed}]  If \code{TRUE}, the method so defined cannot be
redefined by another call to \code{setMethod} (although it can
be removed and then re-assigned).
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The call to \code{setMethod} stores the supplied method definition  in
the metadata table for this generic function in the environment,
typically the global environment or the namespace of a package.
In the case of a package, the table object becomes part of the namespace or environment of the
package.
When the package is loaded into a later session, the
methods will be merged into the table of methods in the corresponding
generic function object.

Generic functions are referenced by the combination of the function name and
the package name;
for example, the function \code{"show"} from the package
\code{"methods"}.
Metadata for methods is identified by the two strings; in particular, the
generic function object itself has slots containing its name and its
package name.
The package name of a generic is set according to the package
from which it originally comes; in particular, and frequently, the
package where a non-generic version of the function originated.
For example, generic functions for all the functions in package \pkg{base} will
have \code{"base"} as the package name, although none of them is an
S4 generic on that package.
These include most of the base functions that are primitives, rather than
true functions; see the section on primitive functions in the
documentation for \code{\LinkA{setGeneric}{setGeneric}} for details.

Multiple packages can have methods for the same generic function; that
is, for the same combination of generic function name and package
name.
Even though the methods are stored in separate tables in separate
environments, loading the corresponding packages adds the methods to
the table in the generic function itself, for the duration of the session.

The class
names in the signature can be any formal class, including basic
classes such as \code{"numeric"}, \code{"character"}, and
\code{"matrix"}.  Two additional special class names can appear:
\code{"ANY"}, meaning that this argument can have any class at all;
and \code{"missing"}, meaning that this argument \emph{must not}
appear in the call in order to match this signature.  Don't confuse
these two:  if an argument isn't mentioned in a signature, it
corresponds implicitly to class \code{"ANY"}, not to
\code{"missing"}.  See the example below.  Old-style (`S3')
classes can also be used, if you need compatibility with these, but
you should definitely declare these classes by calling
\code{\LinkA{setOldClass}{setOldClass}} if you want S3-style inheritance to work.


Method definitions can
have default expressions for arguments, but a current limitation is
that the generic function must have \emph{some} default expression for the
same argument in order for the method's defaults to be used.
If so, and if the corresponding argument is
missing in the call to the generic function, the default expression
in the method is used.  If the method definition has no default for
the argument, then the expression supplied in the definition of the
generic function itself is used, but note that this expression will
be evaluated using the enclosing environment of the method, not of
the generic function.
Note also that specifying class \code{"missing"} in the signature
does not require any default expressions, and method selection does
not evaluate default expressions.
All actual (non-missing) arguments in the signature of the
generic function will be evaluated when a method is selected---when
the call to \code{standardGeneric(f)} occurs.

It is possible to have some differences between the
formal arguments to a method supplied to \code{setMethod} and those
of the generic. Roughly, if the generic has \dots as one of its
arguments, then the method may have extra formal arguments, which
will be matched from the arguments matching \dots in the call to
\code{f}.  (What actually happens is that a local function is
created inside the method, with the modified formal arguments, and the method
is re-defined to call that local function.)

Method dispatch tries to match the class of the actual arguments in a
call to the available methods collected for \code{f}.  If there is a
method defined for the exact same classes as in this call, that
method is used.  Otherwise, all possible signatures are considered
corresponding to the actual classes or to superclasses of the actual
classes (including \code{"ANY"}).
The method having the least distance from the actual classes is
chosen; if more than one method has minimal distance, one is chosen
(the lexicographically first in terms of superclasses) but a warning
is issued.
All inherited methods chosen are stored in another table, so that
the inheritance calculations only need to be done once per session
per sequence of actual classes.
See
\LinkA{Methods}{Methods} for more details.

The function \code{removeMethod} removes the specified method from the
metadata table in the corresponding environment.
It's not a function that is used much, since one normally wants to
redefine a method rather than leave no definition.

\end{Details}
%
\begin{Value}
These functions exist for their side-effect, in setting or removing a
method in the object defining methods for the specified generic.

The value returned by \code{removeMethod} is \code{TRUE} if a method
was found to be removed.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax

\code{\LinkA{method.skeleton}{method.skeleton}}, which is the recommended way to generate a skeleton of the call to \code{setMethod}, with the correct formal arguments and other details.

\LinkA{Methods}{Methods} and the links there for a general discussion, \code{\LinkA{dotsMethods}{dotsMethods}} for methods that dispatch on
``\dots'', and \code{\LinkA{setGeneric}{setGeneric}} for generic functions.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}


require(graphics)
## methods for plotting track objects (see the example for \link{setClass})
##
## First, with only one object as argument:
setMethod("plot", signature(x="track", y="missing"),
  function(x,  y, ...) plot(slot(x, "x"), slot(x, "y"), ...)
)
## Second, plot the data from the track on the y-axis against anything
## as the x data.
setMethod("plot", signature(y = "track"),
 function(x, y, ...) plot(x, slot(y, "y"), ...)
)
## and similarly with the track on the x-axis (using the short form of
## specification for signatures)
setMethod("plot", "track",
 function(x, y, ...) plot(slot(x, "y"), y,  ...)
)
t1 <- new("track", x=1:20, y=(1:20)^2)
tc1 <- new("trackCurve", t1)
slot(tc1, "smooth") <- smooth.spline(slot(tc1, "x"), slot(tc1, "y"))$y #$
plot(t1)
plot(qnorm(ppoints(20)), t1)
## An example of inherited methods, and of conforming method arguments
## (note the dotCurve argument in the method, which will be pulled out
## of ... in the generic.
setMethod("plot", c("trackCurve", "missing"),
function(x, y, dotCurve = FALSE, ...) {
  plot(as(x, "track"))
  if(length(slot(x, "smooth") > 0))
    lines(slot(x, "x"), slot(x, "smooth"),
         lty = if(dotCurve) 2 else 1)
  }
)
## the plot of tc1 alone has an added curve; other uses of tc1
## are treated as if it were a "track" object.
plot(tc1, dotCurve = TRUE)
plot(qnorm(ppoints(20)), tc1)

## defining methods for a special function.
## Although "[" and "length" are not ordinary functions
## methods can be defined for them.
setMethod("[", "track",
  function(x, i, j, ..., drop) {
    x@x <- x@x[i]; x@y <- x@y[i]
    x
  })
plot(t1[1:15])

setMethod("length", "track", function(x)length(x@y))
length(t1)

## methods can be defined for missing arguments as well
setGeneric("summary") ## make the function into a generic

## A method for summary()
## The method definition can include the arguments, but
## if they're omitted, class "missing" is assumed.

setMethod("summary", "missing", function() "<No Object>")


\end{ExampleCode}
\end{Examples}
\HeaderA{setOldClass}{Register Old-Style (S3) Classes and Inheritance}{setOldClass}
\aliasA{.OldClassesList}{setOldClass}{.OldClassesList}
\aliasA{.setOldIs}{setOldClass}{.setOldIs}
\aliasA{anova-class}{setOldClass}{anova.Rdash.class}
\aliasA{anova.glm-class}{setOldClass}{anova.glm.Rdash.class}
\aliasA{anova.glm.null-class}{setOldClass}{anova.glm.null.Rdash.class}
\aliasA{aov-class}{setOldClass}{aov.Rdash.class}
\aliasA{data.frame-class}{setOldClass}{data.frame.Rdash.class}
\aliasA{data.frameRowLabels-class}{setOldClass}{data.frameRowLabels.Rdash.class}
\aliasA{Date-class}{setOldClass}{Date.Rdash.class}
\aliasA{density-class}{setOldClass}{density.Rdash.class}
\aliasA{dump.frames-class}{setOldClass}{dump.frames.Rdash.class}
\aliasA{factor-class}{setOldClass}{factor.Rdash.class}
\aliasA{formula-class}{setOldClass}{formula.Rdash.class}
\aliasA{glm-class}{setOldClass}{glm.Rdash.class}
\aliasA{glm.null-class}{setOldClass}{glm.null.Rdash.class}
\aliasA{hsearch-class}{setOldClass}{hsearch.Rdash.class}
\aliasA{initialize,data.frame-method}{setOldClass}{initialize,data.frame.Rdash.method}
\aliasA{initialize,factor-method}{setOldClass}{initialize,factor.Rdash.method}
\aliasA{initialize,ordered-method}{setOldClass}{initialize,ordered.Rdash.method}
\aliasA{initialize,summary.table-method}{setOldClass}{initialize,summary.table.Rdash.method}
\aliasA{initialize,table-method}{setOldClass}{initialize,table.Rdash.method}
\aliasA{integrate-class}{setOldClass}{integrate.Rdash.class}
\aliasA{libraryIQR-class}{setOldClass}{libraryIQR.Rdash.class}
\aliasA{lm-class}{setOldClass}{lm.Rdash.class}
\aliasA{logLik-class}{setOldClass}{logLik.Rdash.class}
\aliasA{maov-class}{setOldClass}{maov.Rdash.class}
\aliasA{mlm-class}{setOldClass}{mlm.Rdash.class}
\aliasA{mtable-class}{setOldClass}{mtable.Rdash.class}
\aliasA{mts-class}{setOldClass}{mts.Rdash.class}
\aliasA{oldClass-class}{setOldClass}{oldClass.Rdash.class}
\aliasA{ordered-class}{setOldClass}{ordered.Rdash.class}
\aliasA{packageInfo-class}{setOldClass}{packageInfo.Rdash.class}
\aliasA{packageIQR-class}{setOldClass}{packageIQR.Rdash.class}
\aliasA{POSIXct-class}{setOldClass}{POSIXct.Rdash.class}
\aliasA{POSIXlt-class}{setOldClass}{POSIXlt.Rdash.class}
\aliasA{POSIXt-class}{setOldClass}{POSIXt.Rdash.class}
\aliasA{recordedplot-class}{setOldClass}{recordedplot.Rdash.class}
\aliasA{rle-class}{setOldClass}{rle.Rdash.class}
\aliasA{socket-class}{setOldClass}{socket.Rdash.class}
\aliasA{summary.table-class}{setOldClass}{summary.table.Rdash.class}
\aliasA{summaryDefault-class}{setOldClass}{summaryDefault.Rdash.class}
\aliasA{table-class}{setOldClass}{table.Rdash.class}
\keyword{programming}{setOldClass}
\keyword{methods}{setOldClass}
%
\begin{Description}\relax
Register an old-style (a.k.a. `S3') class as a formally defined
class. The \code{Classes} argument is the character vector used as the
\code{class} attribute; in particular, if there is more than one
string, old-style class inheritance is mimicked.  Registering via
\code{setOldClass} allows S3 classes to appear in method signatures,
as a slot in an S4 class, or as a superclass of an S4 class.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
setOldClass(Classes, prototype, where, test = FALSE, S4Class)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{Classes}] 
A character vector, giving the names for S3
classes, as they would appear on the right side of an assignment of
the \code{class} attribute in S3 computations.

In addition to S3 classes, an object type or other valid data part
can be specified, if the S3 class is known to require its data to
be of that form.

\item[\code{prototype}] 
An optional object to use as the prototype.  This should be provided
as the default S3 object for the class.  If omitted, the S4 class
created to register the S3 class is \code{VIRTUAL}.  See the
details.

\item[\code{where}] 
Where to store the class definitions, the global or top-level
environment by default.  (When either function is called in the
source for a package, the class definitions will be included in the
package's environment by default.)

\item[\code{test}] flag, if \code{TRUE}, arrange to test inheritance
explicitly for each object, needed if the S3 class can have a
different set of class strings, with the same first string.
This is a different mechanism in implementation and should be
specified separately for each pair of classes that have an
optional inheritance.  See the `Details'.

\item[\code{S4Class}]  optionally, the class definition or the class name
of an S4 class.  The new class will have all the slots and other
properties of this class, plus its S3 inheritance as defined by
the \code{Classses} argument.  Arguments \code{prototype} and
\code{test} must not be supplied in this case.  See the section
on ``S3 classes with known attributes'' below.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Each of the names will be defined as an S4 class, extending the
remaining classes in \code{Classes}, and the class \code{oldClass},
which is the `root' of all old-style classes. S3 classes have
no formal definition, and therefore no formally defined slots. If a
\code{prototype} argument is supplied in the call to
\code{setOldClass()}, objects from the class can be generated, by a
call to \code{\LinkA{new}{new}}; however, this usually not as relevant as
generating objects from subclasses (see the section on extending S3
classes below).   If  a prototype is not provided,
the class will be created as a virtual S4 class.
The main disadvantage is that the prototype object in an S4 class that
uses this class as a slot will have a \code{NULL} object in that slot,
which can sometimes lead to confusion.

Beginning with version 2.8.0 of \R{}, support is provided for using a
(registered) S3 class as a superclass of a new S4 class.  See the
section on extending S3 classes below, and the examples.

See \LinkA{Methods}{Methods} for the details of method dispatch and
inheritance.

Some S3 classes cannot be represented as an ordinary combination of S4
classes and superclasses, because objects from the S3 class can have a
variable set of strings in the class. It is still possible to register
such classes as S4 classes, but now the inheritance has to be verified
for each object, and you must call \code{setOldClass} with argument
\code{test=TRUE} once for each superclass.

For example, ordered factors \emph{always} have the S3
class \code{c("ordered", "factor")}.  This is proper behavior, and
maps simply into two S4 classes, with \code{"ordered"} extending
\code{"factor"}.

But objects whose class attribute has \code{"POSIXt"} as the first
string may have either (or neither) of \code{"POSIXct"} or
\code{"POSIXlt"} as the second string.  This behavior can be mapped
into S4 classes but now to evaluate \code{is(x, "POSIXlt")}, for
example, requires checking the S3 class attribute on each object.
Supplying the \code{test=TRUE} argument to \code{setOldClass} causes
an explicit test to be included in the class definitions.  It's
never wrong to have this test, but since it adds significant
overhead to methods defined for the inherited classes, you should
only supply this argument if it's known that object-specific tests
are needed.

The list \code{.OldClassesList} contains the old-style classes that
are defined by the methods package.  Each element of the list is a
character vector, with multiple strings if inheritance is included.
Each element of the list was passed to \code{setOldClass} when
creating the \pkg{methods} package; therefore, these classes can be used
in \code{\LinkA{setMethod}{setMethod}} calls, with the inheritance as implied by
the list.
\end{Details}
%
\begin{Section}{Extending S3 classes}
A call to \code{setOldClass} creates formal classes corresponding
to S3 classes, allows these to be used as slots in other classes or in
a signature in \code{\LinkA{setMethod}{setMethod}}, and mimics the S3
inheritance.

In documentation for the initial implementation of S4 classes in \R{},
users were warned against defining S4 classes that contained S3
classes, even if those had been registered.  The warning was based
mainly on two points.  1: The S3 behavior of the objects would fail
because the S3 class would not be visible, for example, when S3
methods are dispatched.  2: Because S3 classes have no formal
definition, nothing can be asserted in general about the S3 part of
an object from such a class.  (The warning was repeated as recently
as the first reference below.)

Nevertheless, defining S4 classes to contain an S3 class and extend
its behavior is attractive in many applications.  The alternative is
to be stuck with S3 programming, without the flexibility and security of
formal class and method definitions.

Beginning with version 2.8.0, \R{} provides support for extending
registered S3 classes; that is, for new classes defined by a call to
\code{\LinkA{setClass}{setClass}} in which the \code{contains=} argument
includes an S3 class.  See the examples below.  The support is aimed
primarily at providing the S3 class information for all classes that
extend class \LinkA{oldClass}{oldClass.Rdash.class}, in particular by ensuring that
all objects from such classes contain the S3 class in a special
slot.

There are three different ways to indicate an extension to an existing
S3 class:  \code{setOldClass()},  \code{setClass()} and
\code{setIs()}.  In most cases, calling \code{setOldClass} is the
best approach,  but the alternatives may be preferred in the special
circumstances described below.

Suppose \code{"A"} is any class extending \code{"oldClass"}. then

\code{setOldClass(c("B", "A"))}

creates a new class \code{"B"} whose S3 class
concatenates \code{"B"}  with \code{S3Class("A")}.  The new class is a
virtual class.  If \code{"A"} was defined with known attribute/slots,
then \code{"B"} has these slots also; therefore, you must believe that
the corresponding S3 objects from class \code{"B"} do indeed have the
claimed attributes.  Notice that you can supply an S4 definition for the
new class to specify additional attributes (as described in the next
section.)
The first alternative call produces a non-virtual class.

\code{setClass("B", contains = "A")}

This creates a non-virtual class with the same slots and superclasses
as class \code{"A"}.  However, class \code{"B"} is not included in
the S3 class slot of the new class, unless you provide it explicitly
in the prototype.

\code{setClass("B"); setIs("B", "A", .....)}

This creates a virtual class that extends \code{"A"}, but does not
contain the slots of \code{"A"}.  The additional arguments to
\code{\LinkA{setIs}{setIs}} should provide a coerce and replacement method.
In order for the new class to inherit S3 methods, the coerce method must
ensure that the class \code{"A"} object produced has a suitable S3
class.  The only likely reason to prefer this third approach is that
class \code{"B"} is not consistent with known attributes in class
\code{"A"}.

Beginning with version 2.9.0 of \R{}, objects from a class extending an
S3 class will be converted to the corresponding S3 class when being
passed to an S3 method defined for that class (that is, for one of the
strings in the S3 class attribute).  This is intended to ensure, as
far as possible, that such methods will work if they work for ordinary
S3 objects.  See \code{\LinkA{Classes}{Classes}} for details.
\end{Section}
%
\begin{Section}{S3 Classes with known attributes}
A further specification of an S3 class can be made \emph{if} the
class is guaranteed to have some attributes of known class (where as
with slots, ``known'' means that the attribute is an object of
a specified class, or a subclass of that class).

In this case, the call to \code{setOldClass()} can supply an S4 class
definition representing the known structure.  Since S4 slots are
implemented as attributes (largely for just this reason), the know
attributes can be specified in the representation of the S4 class.
The usual technique will be to create an S4 class with the desired
structure, and then supply the class name or definition as the
argument \code{S4Class} to \code{setOldClass()}.

See the definition of class \code{"ts"} in the examples below.  The
call to \code{\LinkA{setClass}{setClass}} to create the S4 class can use the same
class name, as here, so long as the class definition is not sealed.
In the example, we define \code{"ts"} as a vector structure with a
numeric slot for \code{"tsp"}.  The validity of this definition relies
on an assertion that all the S3 code for this class is consistent with
that definition; specifically, that all \code{"ts"} objects will
behave as vector structures and will have a numeric \code{"tsp"}
attribute. We believe this to be true of all the base code in \R{}, but
as always with S3 classes, no guarantee is possible.

The S4 class definition can  have virtual superclasses (as in
the \code{"ts"} case) if the S3 class is asserted to behave
consistently with these (in the example, time-series objects are
asserted to be consistent with the \LinkA{structure}{structure.Rdash.class} class).

For another example, look at the S4 class definition for \code{"data.frame"}.

Be warned that failures of the S3 class to live up to its asserted
behavior will usually go uncorrected, since S3 classes inherently
have no definition, and the resulting invalid S4 objects can cause
all sorts of grief.  Many S3 classes are not candidates for known
slots, either because the presence or class of the attributes are
not guaranteed  (e.g., \code{dimnames} in arrays, although these are
not even S3 classes), or because the class uses named components of
a list rather than attributes (e.g., \code{"lm"}).  An attribute
that is sometimes missing cannot be represented as a slot, not even
by pretending that it is present with class \code{"NULL"}, because
attributes unlike slots can not have value \code{NULL}.

One irregularity that is usually tolerated, however, is to optionally
add other attributes to those guaranteed to exist (for example,
\code{"terms"} in \code{"data.frame"} objects returned by
\code{\LinkA{model.frame}{model.frame}}).  As of version 2.8.0, validity checks by
\code{\LinkA{validObject}{validObject}} ignore extra attributes; even if this check
is tightened in the future, classes extending S3 classes would likely
be exempted because extra attributes are so common.
\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version: see section 10.6 for method
selection and section 13.4 for generic functions).

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setClass}{setClass}}, \code{\LinkA{setMethod}{setMethod}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
require(stats)
setOldClass(c("mlm", "lm"))
setGeneric("dfResidual", function(model)standardGeneric("dfResidual"))
setMethod("dfResidual", "lm", function(model)model$df.residual)

## dfResidual will work on mlm objects as well as lm objects
myData <- data.frame(time = 1:10, y = (1:10)^.5)
myLm <- lm(cbind(y, y^3)  ~ time, myData)

showClass("data.frame")# to see the predefined S4 "oldClass"

## two examples extending S3 class "lm", class "xlm" directly
## and "ylm" indirectly
setClass("xlm", representation(eps = "numeric"), contains = "lm")
setClass("ylm", representation(header = "character"), contains = "xlm")
ym1 = new("ylm", myLm, header = "Example", eps = 0.)
## for more examples, see ?\link{S3Class}.

utils::str(.OldClassesList)



## Examples of S3 classes with guaranteed attributes
## an S3 class "stamped" with a vector and  a "date" attribute
## Here is a generator function and an S3 print method.
## NOTE:  it's essential that the generator checks the attribute classes
stamped <- function(x, date = Sys.time()) {
    if(!inherits(date, "POSIXt"))
      stop("bad date argument")
    if(!is.vector(x))
      stop("x must be a vector")
    attr(x, "date") <- date
    class(x) <- "stamped"
    x
}

print.stamped <- function(x, ...) {
    print(as.vector(x))
    cat("Date: ",  format(attr(x,"date")), "\n")
}

## Now, an S4 class with the same structure:
setClass("stamped4", contains = "vector", representation(date = "POSIXt"))

## We can use the S4 class to register "stamped", with its attributes:
setOldClass("stamped", S4Class = "stamped4")
selectMethod("show", "stamped")
## and then remove "stamped4" to clean up
removeClass("stamped4")

someLetters <- stamped(sample(letters, 10),
                       ISOdatetime(2008, 10, 15, 12, 0, 0))

st <- new("stamped", someLetters)
st
# show() method prints the object's class, then calls the S3 print method.

stopifnot(identical(S3Part(st, TRUE), someLetters))

# creating the S4 object directly from its data part and slots
new("stamped", 1:10, date = ISOdatetime(1976, 5, 5, 15, 10, 0))

## Not run: 
## The code in R that defines "ts" as an S4 class
setClass("ts", contains = "structure",
      representation(tsp = "numeric"),
      prototype(NA, tsp = rep(1,3)))
# prototype to be a legal S3 time-series
## and now registers it as an S3 class
    setOldClass("ts", S4Class = "ts", where = envir)

## End(Not run)



\end{ExampleCode}
\end{Examples}
\HeaderA{show}{Show an Object}{show}
\aliasA{show,ANY-method}{show}{show,ANY.Rdash.method}
\aliasA{show,classRepresentation-method}{show}{show,classRepresentation.Rdash.method}
\aliasA{show,genericFunction-method}{show}{show,genericFunction.Rdash.method}
\aliasA{show,MethodDefinition-method}{show}{show,MethodDefinition.Rdash.method}
\aliasA{show,MethodWithNext-method}{show}{show,MethodWithNext.Rdash.method}
\aliasA{show,ObjectsWithPackage-method}{show}{show,ObjectsWithPackage.Rdash.method}
\aliasA{show,traceable-method}{show}{show,traceable.Rdash.method}
\aliasA{show-methods}{show}{show.Rdash.methods}
\keyword{programming}{show}
%
\begin{Description}\relax
Display the object, by printing, plotting or whatever suits its
class.  This function exists to be specialized by methods.  The
default method calls \code{\LinkA{showDefault}{showDefault}}.

Formal methods for \code{show} will
usually be invoked for automatic printing (see the details).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
show(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] Any R object
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Objects from an S4 class (a class defined by a call to
\code{\LinkA{setClass}{setClass}}) will be displayed automatically is if by a
call to \code{show}.  S4 objects that occur as attributes of S3
objects will also be displayed in this form; conversely, S3 objects
encountered as slots in S4 objects will be printed using the S3
convention, as if by a call to \code{\LinkA{print}{print}}.

Methods defined for \code{show} will only be inherited  by simple
inheritance, since otherwise the method would not receive the
complete, original object, with misleading results.  See the
\code{simpleInheritanceOnly} argument to \code{\LinkA{setGeneric}{setGeneric}} and
the discussion in \code{\LinkA{setIs}{setIs}} for the general concept.

\end{Details}
%
\begin{Value}
\code{show} returns an invisible \code{NULL}.
\end{Value}
%
\begin{SeeAlso}\relax
\code{\LinkA{showMethods}{showMethods}} prints all the methods for one or more
functions.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## following the example shown in the setMethod documentation ...
setClass("track",
         representation(x="numeric", y="numeric"))
setClass("trackCurve", 
         representation("track", smooth = "numeric"))

t1 <- new("track", x=1:20, y=(1:20)^2)

tc1 <- new("trackCurve", t1)

setMethod("show", "track",
  function(object)print(rbind(x = object@x, y=object@y))
)
## The method will now be used for automatic printing of t1

t1

## Not run:   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
x    1    2    3    4    5    6    7    8    9    10    11    12
y    1    4    9   16   25   36   49   64   81   100   121   144
  [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20]
x    13    14    15    16    17    18    19    20
y   169   196   225   256   289   324   361   400

## End(Not run)
## and also for tc1, an object of a class that extends "track"
tc1

## Not run:   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12]
x    1    2    3    4    5    6    7    8    9    10    11    12
y    1    4    9   16   25   36   49   64   81   100   121   144
  [,13] [,14] [,15] [,16] [,17] [,18] [,19] [,20]
x    13    14    15    16    17    18    19    20
y   169   196   225   256   289   324   361   400

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{showMethods}{Show all the methods for the specified function(s)}{showMethods}
\keyword{methods}{showMethods}
%
\begin{Description}\relax
Show a summary of the methods for one or more generic functions,
possibly restricted to those involving specified classes.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
showMethods(f = character(), where = topenv(parent.frame()),
            classes = NULL, includeDefs = FALSE,
            inherited = !includeDefs,
            showEmpty, printTo = stdout(), fdef)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] one or more function names.  If omitted, all functions
will be shown that match the other arguments.

The argument can also be an expression that evaluates to a single
generic function, in which
case argument \code{fdef} is ignored.  Providing an expression for
the function allows examination of hidden or anonymous functions;
see the example for \code{isDiagonal()}.
\item[\code{where}] Where to find the generic function, if not supplied as an
argument. When \code{f} is missing, or length 0, this also
determines which generic functions to examine.  If \code{where} is
supplied, only the generic functions returned by
\code{getGenerics(where)} are eligible for printing.  If
\code{where} is also missing, all the cached generic functions are
considered.
\item[\code{classes}] If argument \code{classes} is supplied, it is a vector
of class names that restricts the displayed results to those methods
whose signatures include one or more of those classes.
\item[\code{includeDefs}] If \code{includeDefs} is \code{TRUE}, include the
definitions of the individual methods in the printout.
\item[\code{inherited}] logical indicating if methods that have been found by
inheritance, so far in the session, will be included and marked as
inherited.  Note that an inherited method will not usually appear
until it has been used in this session.  See
\code{\LinkA{selectMethod}{selectMethod}} if you want to know what method would be
dispatched for particular classes of arguments.
\item[\code{showEmpty}] logical indicating whether methods with no defined
methods matching the other criteria should be shown at all.  By
default, \code{TRUE} if and only if argument \code{f} is not
missing.
\item[\code{printTo}] The connection on which the information will be
shown; by default, on standard output.
\item[\code{fdef}] Optionally, the generic function definition to use; if
missing, one is found, looking in \code{where} if that is specified.
See also comment in `Details'.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The name and package of the generic are followed by the list of
signatures for which methods are currently defined, according to the
criteria determined by the various arguments.  Note that the package
refers to the source of the generic function.  Individual methods
for that generic can come from other packages as well.

When more than one generic function is involved, either as specified or
because \code{f} was missing, the functions are found and
\code{showMethods} is recalled for each, including the generic as the
argument \code{fdef}.  In complicated situations, this can avoid some
anomalous results.
\end{Details}
%
\begin{Value}
If \code{printTo} is \code{FALSE}, the character vector that would
have been printed is returned; otherwise the value is the connection
or filename, via \code{\LinkA{invisible}{invisible}}.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setMethod}{setMethod}}, and \code{\LinkA{GenericFunctions}{GenericFunctions}}
for other tools involving methods;
\code{\LinkA{selectMethod}{selectMethod}} will show you the method dispatched for a
particular function and signature of classes for the arguments.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
require(graphics)

## Assuming the methods for plot
## are set up as in the example of help(setMethod),
## print (without definitions) the methods that involve class "track":
showMethods("plot", classes = "track")
## Not run: 
# Function "plot":
# x = ANY, y = track
# x = track, y = missing
# x = track, y = ANY

require("Matrix")
showMethods("%*%")# many!
    methods(class = "Matrix")# nothing
showMethods(class = "Matrix")# everything
showMethods(Matrix:::isDiagonal) # a non-exported generic

## End(Not run)




not.there <- !any("package:stats4" == search())
if(not.there) library(stats4)
showMethods(classes = "mle")
if(not.there) detach("package:stats4")
\end{ExampleCode}
\end{Examples}
\HeaderA{signature-class}{Class \code{"signature"} For Method Definitions}{signature.Rdash.class}
\aliasA{show,signature-method}{signature-class}{show,signature.Rdash.method}
\keyword{classes}{signature-class}
%
\begin{Description}\relax
This class represents the mapping of some of the formal
arguments of a function onto the corresponding classes.  It is used for
two slots in the \code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} class.
\end{Description}
%
\begin{Section}{Objects from the Class}
Objects can be created by calls of the form \code{new("signature",
    functionDef, ...)}.  The \code{functionDef} argument, if it is
supplied as a function object, defines the formal names.  The other
arguments define the classes.  More typically, the objects are
created as side effects of defining methods.  Either way, note that
the classes are expected to be well defined, usually because the
corresponding class definitions exist.  See the comment on the
\code{package} slot.
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] Object of class \code{"character"} the class names. 
\item[\code{names}:] Object of class \code{"character"} the
corresponding argument names. 
\item[\code{package}:] Object of class \code{"character"} the
names of the packages corresponding to the class names. The
combination of class name and package uniquely defines the
class.  In principle, the same class name could appear in more
than one package, in which case the \code{package} information
is required for the signature to be well defined. 
\end{description}

\end{Section}
%
\begin{Section}{Extends}
Class \code{"character"}, from data part.
Class \code{"vector"}, by class "character".
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[initialize] \code{signature(object = "signature")}: see the
discussion of objects from the class, above. 

\end{description}

\end{Section}
%
\begin{SeeAlso}\relax
class \code{\LinkA{MethodDefinition}{MethodDefinition.Rdash.class}} for the use of this class.
\end{SeeAlso}
\HeaderA{slot}{The Slots in an Object from a Formal Class}{slot}
\aliasA{.hasSlot}{slot}{.hasSlot}
\aliasA{.slotNames}{slot}{.slotNames}
\aliasA{@<\Rdash}{slot}{@<.Rdash.}
\aliasA{getSlots}{slot}{getSlots}
\aliasA{slot<\Rdash}{slot}{slot<.Rdash.}
\aliasA{slotNames}{slot}{slotNames}
\keyword{programming}{slot}
\keyword{classes}{slot}
%
\begin{Description}\relax
These functions return or set information about the individual slots
in an object.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
object@name
object@name <- value

slot(object, name)
slot(object, name, check = TRUE) <- value
.hasSlot(object, name)

slotNames(x)
getSlots(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] An object from a formally defined class.
\item[\code{name}] The name of the slot. The operator
takes a fixed name, which can be unquoted if it is syntactically a
name in the language.  A slot name can be any non-empty string, but
if the name is not made up of letters, numbers, and \code{.}, it
needs to be quoted (by backticks or single or double quotes).

In the case of the \code{slot} function, \code{name} can be any
expression that evaluates to a valid slot in the class definition.
Generally, the only reason to use the functional form rather than
the simpler operator is \emph{because} the slot name has to be computed.

\item[\code{value}] A new value for the named slot.  The value must be
valid for this slot in this object's class.
\item[\code{check}] In the replacement version of \code{slot}, a flag.  If
\code{TRUE}, check the assigned value for validity
as the value of this slot.  User's coded should not set this to
\code{FALSE} in normal use, since the resulting object can be invalid.

\item[\code{x}] either the name of a class (as character string), or a class
definition.  If given an argument that is neither a character string
nor a class definition, \code{slotNames} (only) uses \code{class(x)}
instead.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The definition of the class specifies all slots directly and
indirectly defined for that class.  Each slot has a name and an
associated class.  Extracting a slot returns an object from that
class.  Setting a slot first coerces the value to the specified slot
and then stores it.

Unlike general attributes, slots are not partially matched, and asking
for (or trying to set) a slot with an invalid name for that class
generates an error.

The \code{\LinkA{@}{@}} extraction operator and \code{slot}
function themselves do no checking against the class definition,
simply matching the name in the object itself.
The replacement forms do check (except for \code{slot} in the case
\code{check=FALSE}).  So long as slots are set without cheating, the
extracted slots will be valid.

Be aware that there are two ways to cheat, both to be avoided but
with no guarantees.  The obvious way is to assign a slot with
\code{check=FALSE}.  Also, slots in \R{} are implemented as
attributes, for the sake of some back compatibility.  The current
implementation does not prevent attributes being assigned, via
\code{\LinkA{attr<-}{attr<.Rdash.}}, and such assignments are not checked for
legitimate slot names.
\end{Details}
%
\begin{Value}
The \code{"@"} operator and the \code{slot} function extract or
replace the formally defined slots for the object.

Functions \code{slotNames} and \code{getSlots} return respectively the
names of the slots and the classes associated with the slots in the
specified class definition.  Except for its extended interpretation of
\code{x} (above), \code{slotNames(x)} is just \code{names(getSlots(x))}.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{@}{@}},
\code{\LinkA{Classes}{Classes}},
\code{\LinkA{Methods}{Methods}},
\code{\LinkA{getClass}{getClass}},
\code{\LinkA{names}{names}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}


setClass("track", representation(x="numeric", y="numeric"))
myTrack <- new("track", x = -4:4, y = exp(-4:4))
slot(myTrack, "x")
slot(myTrack, "y") <- log(slot(myTrack, "y"))
utils::str(myTrack)

getSlots("track") # or
getSlots(getClass("track"))
slotNames(class(myTrack)) # is the same as
slotNames(myTrack)


\end{ExampleCode}
\end{Examples}
\HeaderA{StructureClasses}{Classes Corresponding to Basic Structures}{StructureClasses}
\aliasA{array-class}{StructureClasses}{array.Rdash.class}
\aliasA{initialize,array-method}{StructureClasses}{initialize,array.Rdash.method}
\aliasA{initialize,matrix-method}{StructureClasses}{initialize,matrix.Rdash.method}
\aliasA{initialize,mts-method}{StructureClasses}{initialize,mts.Rdash.method}
\aliasA{initialize,ts-method}{StructureClasses}{initialize,ts.Rdash.method}
\aliasA{Math,structure-method}{StructureClasses}{Math,structure.Rdash.method}
\aliasA{matrix-class}{StructureClasses}{matrix.Rdash.class}
\aliasA{Ops,array,array-method}{StructureClasses}{Ops,array,array.Rdash.method}
\aliasA{Ops,array,structure-method}{StructureClasses}{Ops,array,structure.Rdash.method}
\aliasA{Ops,structure,array-method}{StructureClasses}{Ops,structure,array.Rdash.method}
\aliasA{Ops,structure,structure-method}{StructureClasses}{Ops,structure,structure.Rdash.method}
\aliasA{Ops,structure,vector-method}{StructureClasses}{Ops,structure,vector.Rdash.method}
\aliasA{Ops,vector,structure-method}{StructureClasses}{Ops,vector,structure.Rdash.method}
\aliasA{show,ts-method}{StructureClasses}{show,ts.Rdash.method}
\aliasA{structure-class}{StructureClasses}{structure.Rdash.class}
\aliasA{ts-class}{StructureClasses}{ts.Rdash.class}
\keyword{classes}{StructureClasses}
%
\begin{Description}\relax
The virtual class \code{structure} and classes that
extend it are formal classes analogous to S language structures such
as arrays and time-series.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
## The following class names can appear in method signatures,
## as the class in as() and is() expressions, and, except for
## the classes commented as VIRTUAL, in calls to new()

"matrix"
"array"
"ts"

"structure" ## VIRTUAL
\end{verbatim}
\end{Usage}
%
\begin{Section}{Objects from the Classes}
Objects can be created by calls of the form \code{new(Class, ...)},
where \code{Class} is the quoted name of the specific class (e.g.,
\code{"matrix"}), and the other arguments, if any, are interpreted as
arguments to the corresponding function, e.g., to function
\code{matrix()}.  There is no particular advantage over calling those
functions directly, unless you are writing software designed to work
for multiple classes, perhaps with the class name and the arguments
passed in.

Objects created from the classes \code{"matrix"} and \code{"array"}
are unusual, to put it mildly, and have been for some time.  Although
they may appear to be objects from these classes, they do not have the
internal structure of either an S3 or S4 class object.  In particular,
they have no \code{"class"} attribute and are not recognized as
objects with classes (that is, both \code{\LinkA{is.object}{is.object}} and
\code{\LinkA{isS4}{isS4}} will return \code{FALSE} for such objects).
However, methods (both S4 and S3) can be defined for these
pseudo-classes and new classes (both S4 and S3) can inherit from them.

That the objects still behave as if they came from the corresponding
class (most of the time, anyway) results from special code
recognizing such objects being built into the base code of \R{}.
For most purposes, treating the classes in the usual way will work,
fortunately.  One consequence of the special treatment is that these
two classes\emph{may} be used as the data part of an S4 class; for
example, you can get away with \code{contains = "matrix"} in a call
to \code{\LinkA{setGeneric}{setGeneric}} to create an S4 class that is a subclass
of \code{"matrix"}.  There is no guarantee that everything will work
perfectly, but a number of classes have been written in this form
successfully.

Note that a class containing \code{"matrix"} or \code{"array"} will
have a  \code{.Data} slot with that class.  This is the only use of
\code{.Data} other than as a pseudo-class indicating the type of the
object.  In this case the type of the object will be the type of the
contained matrix or array. See \code{\LinkA{Classes}{Classes}} for a general
discussion.

The class \code{"ts"}  is basically an S3 class
that has been registered with S4, using the
\code{\LinkA{setOldClass}{setOldClass}} mechanism.  Versions of \R{} through 2.7.0
treated this class as a pure S4 class, which was in principal a good
idea, but in practice did not allow subclasses to be defined and had
other intrinsic problems.  (For example, setting the
\code{"tsp"} parameters as a slot often fails because the built-in
implementation does not allow the slot to be temporarily
inconsistent with the length of the data. Also, the S4 class
prevented the correct specification of the S3 inheritance for class
\code{"mts"}.)

Time-series objects, in contrast to matrices and arrays, have a valid
S3 class, \code{"ts"}, registered  using an S4-style definition (see the
documentation for \code{\LinkA{setOldClass}{setOldClass}} in the examples section
for an abbreviated listing of how this is done.  The S3
inheritance of \code{"mts"} in package \pkg{stats} is also
registered.
These classes, as well as \code{"matrix"} and \code{"array"} should
be valid in most examples as superclasses for new S4 class
definitions.

All of these classes have special S4 methods for
\code{\LinkA{initialize}{initialize}} that accept the same arguments as the basic
generator functions, \code{\LinkA{matrix}{matrix}},
\code{\LinkA{array}{array}}, and \code{\LinkA{ts}{ts}}, in so far as possible.
The limitation is that a class that has more than one non-virtual
superclass must accept objects from that superclass in the call to
\code{\LinkA{new}{new}}; therefore, a such a class (what is called a
``mixin'' in some languages) uses the default method for
\code{\LinkA{initialize}{initialize}}, with no special arguments.

\end{Section}
%
\begin{Section}{Extends}
The specific classes all extend class \code{"structure"}, directly, and
class \code{"vector"}, by class \code{"structure"}.
\end{Section}
%
\begin{Section}{Methods}
\begin{description}

\item[coerce] Methods are defined to coerce arbitrary objects to
these classes, by calling the corresponding basic function, for
example, \code{as(x, "matrix")} calls \code{as.matrix(x)}.
If \code{strict = TRUE} in the call to \code{as()}, the method
goes on to delete all other slots and attributes other than the
\code{dim} and \code{dimnames}.

\item[Ops] Group methods (see, e.g., \code{\LinkA{S4groupGeneric}{S4groupGeneric}})
are defined for combinations of structures and vectors (including
special cases for array and matrix), implementing the concept of
vector structures as in the reference.  Essentially, structures
combined with vectors retain the structure as long as the
resulting object has the same length.  Structures combined with
other structures remove the structure, since there is no
automatic way to determine what should happen to the slots
defining the structure.

Note that these methods will be activated when a package is loaded
containing a class that inherits from any of the structure
classes or class \code{"vector"}.


\end{description}

\end{Section}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.)

Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
\emph{The New S Language}.
Wadsworth \& Brooks/Cole (for the original vector structures).
\end{References}
%
\begin{SeeAlso}\relax
Class \LinkA{nonStructure}{nonStructure.Rdash.class}, which enforces the
alternative model, in which all slots are dropped if any math
transformation or operation is applied to an object from a class
extending one of the basic classes.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
showClass("structure")

## explore a bit :
showClass("ts")
(ts0 <- new("ts"))
str(ts0)

showMethods("Ops") # six methods from these classes, but maybe many more
\end{ExampleCode}
\end{Examples}
\HeaderA{testInheritedMethods}{Test for and Report about  Selection of Inherited Methods}{testInheritedMethods}
\aliasA{.Other-class}{testInheritedMethods}{.Other.Rdash.class}
\aliasA{MethodSelectionReport-class}{testInheritedMethods}{MethodSelectionReport.Rdash.class}
\keyword{programming}{testInheritedMethods}
\keyword{classes}{testInheritedMethods}
\keyword{methods}{testInheritedMethods}
%
\begin{Description}\relax
A set of distinct inherited signatures is generated to test
inheritance for all the methods of a specified generic function.  If
method selection is ambiguous for some of these, a summary of the
ambiguities is attached to the returned object.  This test should be
performed by package authors \emph{before} releasing a package.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
testInheritedMethods(f, signatures, test = TRUE, virtual = FALSE,
                     groupMethods = TRUE, where = .GlobalEnv)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{f}] a generic function or the character string name of one.  By default,
all currently defined subclasses of all the method signatures for this
generic will be examined.  The other arguments are mainly options to
modify which inheritance patterns will be examined.

\item[\code{signatures}] 
An optional set of subclass signatures to use instead of the relevant
subclasses computed by \code{testInheritedMethods}.  See the Details
for how this is done.  This argument might be supplied after a call
with \code{test = FALSE}, to test selection in batches.

\item[\code{test}] 
optional flag to control whether method selection is actually tested.
If \code{FALSE}, returns just the list of relevant signatures for
subclasses, without calling \code{\LinkA{selectMethod}{selectMethod}} for each signature.
If there are a very large number of signatures, you may want to collect the full list  and then test them in batches.

\item[\code{virtual}] 
should virtual classes be included in the relevant subclasses.
Normally not, since only the classes of actual arguments will trigger
the inheritance calculation in a call to the generic function.
Including virtual classes may be useful if the class has no current
non-virtual subclasses but you anticipate your users may define such
classes in the future.

\item[\code{groupMethods}] 
should methods for the group generic function be included?

\item[\code{where}] 
the environment in which to look for class definitions.  Nearly
always, use the default global environment after attaching all the
packages with relevant methods and/or class definitions.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The following description applies when the optional arguments are
omitted, the usual case.
First, the defining signatures for all methods are computed by calls
to \code{\LinkA{findMethodSignatures}{findMethodSignatures}}.
From these all the known non-virtual subclasses are found for each
class that appears in the signature of some method.
These subclasses are split into groups according to which class they
inherit from, and only one subclass from each group is retained (for
each argument in the generic signature).
So if a method was defined with class \code{"vector"} for some
argument, one actual vector class is chosen arbitrarily.
The case of \code{"ANY"} is dealt with specially, since all classes
extend it.  A dummy, nonvirtual class, \code{".Other"}, is used to
correspond to all classes that have no superclasses among those being
tested.

All combinations of retained subclasses for the
arguments in the generic signature are then computed.
Each row of the resulting matrix is a signature to be tested by a call
to \code{\LinkA{selectMethod}{selectMethod}}.
To collect information on ambiguous selections,
\code{testInheritedMethods} establishes a calling handler for the
special signal \code{"ambiguousMethodSelection"}, by setting the
corresponding option.
\end{Details}
%
\begin{Value}
An object of class \code{"methodSelectionReport"}.  The details of
this class are currently subject to change.  It has slots
\code{"target"}, \code{"selected"}, \code{"candidates"}, and
\code{"note"}, all referring to the ambiguous cases (and so of length
0 if there were none).  These slots are intended to be examined by the
programmer to detect and preferably fix ambiguous method selections.
The object contains in addition slots \code{"generic"}, the name of
the generic function, and
\code{"allSelections"},  giving the vector of labels for all
the signatures tested.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (Section 10.6 for basics of method selection.)

Chambers, John M. (2009)
\emph{Class Inheritance in R}
\url{http://stat.stanford.edu/~jmc4/classInheritance.pdf} (to be
submitted to the R Journal).
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
## if no other attached packages have methods for `+` or its group
## generic functions, this returns a 16 by 2 matrix of selection
## patterns (in R 2.9.0)
testInheritedMethods("+")
\end{ExampleCode}
\end{Examples}
\HeaderA{TraceClasses}{Classes Used Internally to Control Tracing }{TraceClasses}
\aliasA{.doTracePrint}{TraceClasses}{.doTracePrint}
\aliasA{.InitTraceFunctions}{TraceClasses}{.InitTraceFunctions}
\aliasA{.makeTracedFunction}{TraceClasses}{.makeTracedFunction}
\aliasA{.untracedFunction}{TraceClasses}{.untracedFunction}
\aliasA{derivedDefaultMethodWithTrace-class}{TraceClasses}{derivedDefaultMethodWithTrace.Rdash.class}
\aliasA{functionWithTrace-class}{TraceClasses}{functionWithTrace.Rdash.class}
\aliasA{genericFunctionWithTrace-class}{TraceClasses}{genericFunctionWithTrace.Rdash.class}
\aliasA{groupGenericFunctionWithTrace-class}{TraceClasses}{groupGenericFunctionWithTrace.Rdash.class}
\aliasA{MethodDefinitionWithTrace-class}{TraceClasses}{MethodDefinitionWithTrace.Rdash.class}
\aliasA{MethodWithNextWithTrace-class}{TraceClasses}{MethodWithNextWithTrace.Rdash.class}
\aliasA{nonstandardGenericWithTrace-class}{TraceClasses}{nonstandardGenericWithTrace.Rdash.class}
\aliasA{show,genericFunctionWithTrace-method}{TraceClasses}{show,genericFunctionWithTrace.Rdash.method}
\aliasA{show,MethodDefinitionWithTrace-method}{TraceClasses}{show,MethodDefinitionWithTrace.Rdash.method}
\aliasA{show,MethodWithNextWithTrace-method}{TraceClasses}{show,MethodWithNextWithTrace.Rdash.method}
\aliasA{show,sourceEnvironment-method}{TraceClasses}{show,sourceEnvironment.Rdash.method}
\aliasA{traceable-class}{TraceClasses}{traceable.Rdash.class}
\keyword{classes}{TraceClasses}
%
\begin{Description}\relax
 The classes described  here are used by the R function
\code{\LinkA{trace}{trace}} to create versions of functions and methods
including browser calls, etc., and also to \code{\LinkA{untrace}{untrace}} the
same objects.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
### Objects from the following classes are generated
### by calling trace() on an object from the corresponding
### class without the "WithTrace" in the name.

"functionWithTrace"
"MethodDefinitionWithTrace"
"MethodWithNextWithTrace"
"genericFunctionWithTrace"
"groupGenericFunctionWithTrace"

### the following is a virtual class extended by each of the
### classes above

"traceable"
\end{verbatim}
\end{Usage}
%
\begin{Section}{Objects from the Class}
Objects will be created from these classes by calls to \code{trace}.
(There is an \code{\LinkA{initialize}{initialize}} method for class
\code{"traceable"}, but you are unlikely to need it directly.)
\end{Section}
%
\begin{Section}{Slots}
\begin{description}

\item[\code{.Data}:] The data part, which will be \code{"function"}
for class \code{"functionWithTrace"}, and similarly for the other
classes.
\item[\code{original}:] Object of the original class; e.g.,
\code{"function"} for class \code{"functionWithTrace"}. 

\end{description}

\end{Section}
%
\begin{Section}{Extends}
Each of the classes extends the corresponding untraced class, from the
data part; e.g., \code{"functionWithTrace"} extends \code{"function"}.
Each of the specific classes extends \code{"traceable"}, directly,
and class \code{"VIRTUAL"}, by class \code{"traceable"}.
\end{Section}
%
\begin{Section}{Methods}
The point of the specific classes is that objects generated from them,
by function \code{trace()}, remain callable or dispatchable, in
addition to their new trace information.
\end{Section}
%
\begin{SeeAlso}\relax
 function \code{\LinkA{trace}{trace}} 
\end{SeeAlso}
\HeaderA{validObject}{ Test the Validity of an Object }{validObject}
\aliasA{getValidity}{validObject}{getValidity}
\aliasA{setValidity}{validObject}{setValidity}
\keyword{programming}{validObject}
\keyword{classes}{validObject}
%
\begin{Description}\relax
The validity of \code{object} related to its class definition is
tested.  If the object is valid, \code{TRUE} is returned; otherwise,
either a vector of strings describing validity failures is returned,
or an error is generated (according to whether \code{test} is
\code{TRUE}).  Optionally, all slots in the object can also be validated.

The function \code{setValidity} sets the validity method of a class
(but more normally, this method will be supplied as the
\code{validity} argument to \code{\LinkA{setClass}{setClass}}).  The method
should be a function of one object that returns \code{TRUE} or a
description of the non-validity.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
validObject(object, test = FALSE, complete = FALSE)

setValidity(Class, method, where = topenv(parent.frame()) )

getValidity(ClassDef)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}]  any object, but not much will happen unless the
object's class has a formal definition.
\item[\code{test}] logical; if \code{TRUE} and validity fails, the
function returns a vector of strings describing the problems.  If
\code{test} is \code{FALSE} (the default) validity failure generates
an error.
\item[\code{complete}] logical; if \code{TRUE}, validity methods will be
applied recursively to any of the slots that have such methods.
\item[\code{Class}] the name or class definition of the class whose validity
method is to be set.
\item[\code{ClassDef}] a class definition object, as from
\code{\LinkA{getClassDef}{getClassDef}}.
\item[\code{method}] a validity method;  that is, either \code{NULL} or a
function of one argument (\code{object}).  Like
\code{validObject}, the function should return \code{TRUE} if the
object is valid, and one or more descriptive strings if any problems
are found.  Unlike \code{validObject}, it should never generate an
error.

\item[\code{where}] the modified class definition will be stored in this
environment.

Note that validity methods do not have to check validity of
superclasses: the logic of \code{validObject} ensures these tests are
done once only.  As a consequence, if one validity method wants to use
another, it should extract and call the method from the other
definition of the other class by calling \code{getValidity()}: it
should \emph{not} call \code{validObject}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Validity testing takes place `bottom up': Optionally, if
\code{complete=TRUE}, the validity of the object's slots, if any, is
tested.  Then, in all cases, for each of the classes that this class
extends (the `superclasses'), the explicit validity method of
that class is called, if one exists.  Finally, the validity method of
\code{object}'s class is called, if there is one.

Testing generally stops at the first stage of finding an error, except
that all the slots will be examined even if a slot has failed its
validity test.

The standard validity test (with \code{complete=FALSE}) is applied
when an object is created via \code{\LinkA{new}{new}} with any optional
arguments (without the extra arguments the result is just the class
prototype object).

An attempt is made to fix up the definition of a validity method if
its argument is not \code{object}.
\end{Details}
%
\begin{Value}
\code{validObject} returns \code{TRUE} if the object is valid.
Otherwise a vector of strings describing problems found, except that
if \code{test} is \code{FALSE}, validity failure generates an error,
with the corresponding strings in the error message.
\end{Value}
%
\begin{References}\relax
Chambers, John M. (2008)
\emph{Software for Data Analysis: Programming with R}
Springer.  (For the R version.)

Chambers, John M. (1998)
\emph{Programming with Data}
Springer (For the original S4 version.) 
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{setClass}{setClass}};
class \code{\LinkA{classRepresentation}{classRepresentation.Rdash.class}}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
setClass("track",
          representation(x="numeric", y = "numeric"))
t1 <- new("track", x=1:10, y=sort(stats::rnorm(10)))
## A valid "track" object has the same number of x, y values
validTrackObject <- function(object) {
    if(length(object@x) == length(object@y)) TRUE
    else paste("Unequal x,y lengths: ", length(object@x), ", ",
               length(object@y), sep="")
}
## assign the function as the validity method for the class
setValidity("track", validTrackObject)
## t1 should be a valid "track" object
validObject(t1)
## Now we do something bad
t2 <- t1
t2@x <- 1:20
## This should generate an error
## Not run: try(validObject(t2))


setClass("trackCurve",
         representation("track", smooth = "numeric"))

## all superclass validity methods are used when validObject
## is called from initialize() with arguments, so this fails
## Not run: trynew("trackCurve", t2)


setClass("twoTrack", representation(tr1 = "track", tr2 ="track"))

## validity tests are not applied recursively by default,
## so this object is created (invalidly)
tT  <- new("twoTrack", tr2 = t2)

## A stricter test detects the problem
## Not run: try(validObject(tT, complete = TRUE))

\end{ExampleCode}
\end{Examples}
\clearpage
