<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE xtpipes SYSTEM "xtpipes.dtd" >
<xtpipes>
   <sax content-handler="xtpipes.util.ScriptsManager"
        lexical-handler="xtpipes.util.ScriptsManagerLH" >
     <script element="br" >
  <set name="br" >
    <![CDATA[
       <xsl:stylesheet version="1.0"
          xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
       >
          <xsl:output omit-xml-declaration = "yes" />
          <xsl:template match="br" >
            <xsl:copy>
              <xsl:apply-templates select="@*" />
              <xsl:comment>.</xsl:comment>
            </xsl:copy>
          </xsl:template>
          <xsl:template match="*|@*|text()|comment()" >
            <xsl:copy>
              <xsl:apply-templates select="*|@*|text()|comment()" />
            </xsl:copy>
          </xsl:template>
       </xsl:stylesheet>
    ]]>
  </set>
  <xslt name="." xml="." xsl="br" />
</script>

     <script element="span::msup" >
   <set name="m-sub-sup" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="span[
    ((@class = 'msup') or (@class = 'msub')
                       or (@class = 'msubsup'))
  and
    not(
      child::span[ (@class = 'mrow-sub') ]
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                       and
                       (@class != 'mid-script')
                     ]
    )
  and
    not(
      child::span[ (@class = 'mrow-super') ]
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                       and
                       (@class != 'mid-script')
                     ]
    )
]" >
   <xsl:apply-templates select="child::span[
                          @class = 'mrow-base' ]/*" />
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

   </set>
   <xslt name="." xml="." xsl="m-sub-sup" />
   <set name="m-sup-2-3" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

  <xsl:template match="span[
    (@class = 'msup')
  and
    (normalize-space(
      child::span[ (@class = 'mrow-super') ]
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                     ]
     ) = '2')
  and not(
  child::span[ (@class = 'mrow-base') ]
    / child::span[ not( @title = 'speech-extra' ) ]
                 [ position() = last() ]
    / self::* [ @class = 'mo-op' ]
)

]" >
   <xsl:copy>
      <xsl:apply-templates select="*|@*|text()|comment()"
                           mode="squared" />
   </xsl:copy>
</xsl:template>
<xsl:template match="*|@*|text()|comment()"
                           mode="squared" >
   <xsl:copy>
     <xsl:choose>
        <xsl:when test=" @class = 'mrow-super' ">
           <xsl:apply-templates select="@*" />
           <span class="mo-op">
             <xsl:text> squared </xsl:text>
           </span>
        </xsl:when>
        <xsl:otherwise>
           <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:otherwise>
     </xsl:choose>
   </xsl:copy>
</xsl:template>
<xsl:template match="span[
    (@class = 'msup')
  and
    (normalize-space(
      child::span[ (@class = 'mrow-super') ]
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                     ]
     ) = '3')
  and not(
  child::span[ (@class = 'mrow-base') ]
    / child::span[ not( @title = 'speech-extra' ) ]
                 [ position() = last() ]
    / self::* [ @class = 'mo-op' ]
)

]" >
   <xsl:copy>
      <xsl:apply-templates select="*|@*|text()|comment()"
                           mode="cube" />
   </xsl:copy>
</xsl:template>
<xsl:template match="*|@*|text()|comment()"
                           mode="cube" >
   <xsl:copy>
     <xsl:choose>
        <xsl:when test=" @class = 'mrow-super' ">
           <xsl:apply-templates select="@*" />
           <span class="mo-op">
             <xsl:text> cube </xsl:text>
           </span>
        </xsl:when>
        <xsl:otherwise>
           <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:otherwise>
     </xsl:choose>
   </xsl:copy>
</xsl:template>

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="m-sup-2-3" />

</script>
<script element="span::msub" >
  <set name="m-sub-sup" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

  <xsl:template match="span[
    ((@class = 'msup') or (@class = 'msub')
                       or (@class = 'msubsup'))
  and
    not(
      child::span[ (@class = 'mrow-sub') ]
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                       and
                       (@class != 'mid-script')
                     ]
    )
  and
    not(
      child::span[ (@class = 'mrow-super') ]
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                       and
                       (@class != 'mid-script')
                     ]
    )
]" >
   <xsl:apply-templates select="child::span[
                          @class = 'mrow-base' ]/*" />
</xsl:template>

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="m-sub-sup" />

</script>
<script element="span::msubsup" >
  <set name="subsup-prime" >
   <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

   <xsl:template match="span[
    (@class = 'msubsup')
  and
    (count(
        child::* [ @class='mrow-super' ]
       / child::span [ not(@title = 'speech-extra') ] ) = 1)
  and
    (count(
       child::* [ @class='mrow-super' ]
          / child::span [ not(@title = 'speech-extra') ]
          / child::span) = 1)
  and
    child::* [ @class='mrow-super' ]
       / child::span [ not(@title = 'speech-extra') ]
       / child::span[ @class='char' ]
       / child::span[
            (@class = 'ch 2032') or (@class = 'ch 2033')
                                 or (@class = 'ch 2034')
         ]
]" >
  <xsl:copy>
    <xsl:attribute name="class" >
       <xsl:text>msub</xsl:text>
    </xsl:attribute>
    <span class="mrow-base">
       <xsl:apply-templates select="
             *[@class = 'mrow-base'] / *
          " />
       <xsl:apply-templates select="
             *[@class = 'mrow-super']
             / child::span [ not(@title = 'speech-extra') ]
          " />
    </span>
    <xsl:apply-templates select="*[@class = 'mrow-sub']" />
  </xsl:copy>
</xsl:template>

         <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="subsup-prime" />

  <set name="m-sub-sup" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

  <xsl:template match="span[
    ((@class = 'msup') or (@class = 'msub')
                       or (@class = 'msubsup'))
  and
    not(
      child::span[ (@class = 'mrow-sub') ]
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                       and
                       (@class != 'mid-script')
                     ]
    )
  and
    not(
      child::span[ (@class = 'mrow-super') ]
        / child::span[ (@class != 'begin-script')
                       and
                       (@class != 'end-script')
                       and
                       (@class != 'mid-script')
                     ]
    )
]" >
   <xsl:apply-templates select="child::span[
                          @class = 'mrow-base' ]/*" />
</xsl:template>

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="m-sub-sup" />

  <set name="m-subsup-2-3" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

  <xsl:template match="span[
    (@class = 'msubsup')
  and
    (normalize-space(
      child::span[ (@class = 'mrow-super') ]
        / child::span[ (@class != 'mid-script')
                       and
                       (@class != 'end-script')
                     ]
     ) = '2')
  and not(
  child::span[ (@class = 'mrow-base') ]
    / child::span[ not( @title = 'speech-extra' ) ]
                 [ position() = last() ]
    / self::* [ @class = 'mo-op' ]
)

]" >
   <xsl:copy>
      <xsl:attribute name="class" >
         <xsl:text>msub</xsl:text>
      </xsl:attribute>
      <xsl:apply-templates select="*|text()|comment()"
                           mode="sub-squared" />
   </xsl:copy>
</xsl:template>
<xsl:template match="*|@*|text()|comment()"
                           mode="sub-squared" >
   <xsl:copy>
     <xsl:choose>
        <xsl:when test=" @class = 'mrow-sub' ">
           <xsl:apply-templates select="*[
                       not( @class = 'end-script' )
                     ]
                           |@*|text()|comment()" />
           <xsl:apply-templates select="
               following-sibling::*[1] / *[
                        @class = 'end-script'
                  ] " />
        </xsl:when>
        <xsl:when test=" @class = 'mrow-super' ">
           <xsl:attribute name="class" >
               <xsl:text>squared-super</xsl:text>
           </xsl:attribute>
           <span class="mo-op">
             <xsl:text> squared </xsl:text>
           </span>
        </xsl:when>
        <xsl:otherwise>
           <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:otherwise>
     </xsl:choose>
   </xsl:copy>
</xsl:template>
<xsl:template match="span[
    (@class = 'msubsup')
  and
    (normalize-space(
      child::span[ (@class = 'mrow-super') ]
        / child::span[ (@class != 'mid-script')
                       and
                       (@class != 'end-script')
                     ]
     ) = '3')
  and not(
  child::span[ (@class = 'mrow-base') ]
    / child::span[ not( @title = 'speech-extra' ) ]
                 [ position() = last() ]
    / self::* [ @class = 'mo-op' ]
)

]" >
   <xsl:copy>
      <xsl:attribute name="class" >
         <xsl:text>msub</xsl:text>
      </xsl:attribute>
      <xsl:apply-templates select="*|text()|comment()"
                           mode="sub-cube" />
   </xsl:copy>
</xsl:template>
<xsl:template match="*|@*|text()|comment()"
                           mode="sub-cube" >
   <xsl:copy>
     <xsl:choose>
        <xsl:when test=" @class = 'mrow-sub' ">
           <xsl:apply-templates select="*[
                       not( @class = 'end-script' )
                     ]
                           |@*|text()|comment()" />
           <xsl:apply-templates select="
               following-sibling::*[1] / *[
                        @class = 'end-script'
                  ] " />
        </xsl:when>
        <xsl:when test=" @class = 'mrow-super' ">
           <xsl:attribute name="class" >
               <xsl:text>cube-super</xsl:text>
           </xsl:attribute>
           <span class="mo-op">
             <xsl:text> cube </xsl:text>
           </span>
        </xsl:when>
        <xsl:otherwise>
           <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:otherwise>
     </xsl:choose>
   </xsl:copy>
</xsl:template>

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="m-subsup-2-3" />

</script>

     <script element="span::mfrac" >
  <set name="mfrac" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="span[ @class = 'mfrac' ]" >
  <xsl:copy>
    <xsl:choose>
       <xsl:when test="
   (string-length(
      normalize-space(child::span[ @class = 'mrow-numerator' ][1])
     ) = 1)
   and
   (string-length(
     normalize-space(child::span[ @class = 'mrow-enumerator' ][1])
     ) = 1)
">
   <xsl:variable name="a">
   <xsl:value-of select="
      normalize-space(child::span[ @class = 'mrow-numerator' ][1])
   " />
</xsl:variable>
<xsl:variable name="b">
   <xsl:value-of select="
      normalize-space(child::span[ @class = 'mrow-enumerator' ][1])
   " />
</xsl:variable>

   <xsl:choose>
      <xsl:when test="
           (translate($a,'123456789','') != '')
           or
           (translate($b,'123456789','') != '')
       " >
         <xsl:apply-templates select="*|@*|text()|comment()" />
      </xsl:when>
      <xsl:when test=" $a &lt; $b ">
         <xsl:attribute  name="class">
             <xsl:text>word-frac</xsl:text>
         </xsl:attribute>
         <xsl:choose>
   <xsl:when test=" $a = 1 "><xsl:text> one </xsl:text></xsl:when>
   <xsl:when test=" $a = 2 "><xsl:text> two </xsl:text></xsl:when>
   <xsl:when test=" $a = 3 "><xsl:text> three </xsl:text></xsl:when>
   <xsl:when test=" $a = 4 "><xsl:text> four </xsl:text></xsl:when>
   <xsl:when test=" $a = 5 "><xsl:text> five </xsl:text></xsl:when>
   <xsl:when test=" $a = 6 "><xsl:text> six </xsl:text></xsl:when>
   <xsl:when test=" $a = 7 "><xsl:text> seven </xsl:text></xsl:when>
   <xsl:when test=" $a = 8 "><xsl:text> eight </xsl:text></xsl:when>
   <xsl:when test=" $a = 9 "><xsl:text> nine </xsl:text></xsl:when>
</xsl:choose>

         <xsl:choose>
   <xsl:when test=" $b = 2 "><xsl:text> half</xsl:text></xsl:when>
   <xsl:when test=" $b = 3 "><xsl:text> third</xsl:text></xsl:when>
   <xsl:when test=" $b = 4 "><xsl:text> fourth</xsl:text></xsl:when>
   <xsl:when test=" $b = 5 "><xsl:text> fifth</xsl:text></xsl:when>
   <xsl:when test=" $b = 6 "><xsl:text> sixth</xsl:text></xsl:when>
   <xsl:when test=" $b = 7 "><xsl:text> seventh</xsl:text></xsl:when>
   <xsl:when test=" $b = 8 "><xsl:text> eighth</xsl:text></xsl:when>
   <xsl:when test=" $b = 9 "><xsl:text> nineth</xsl:text></xsl:when>
</xsl:choose>
<xsl:if test=" $a &gt; 1 "><xsl:text>s</xsl:text></xsl:if>
<xsl:text> </xsl:text>

      </xsl:when>
      <xsl:otherwise>
         <xsl:apply-templates select="*|@*|text()|comment()" />
      </xsl:otherwise>
   </xsl:choose>
</xsl:when>

       <xsl:when test="
      (@class = 'mfrac')
    and
      child::span[ @class = 'mrow-enumerator' ]
        / child::span[ @class = 'continuous-mfrac' ]
    and
      ( normalize-space(
          child::span[ @class = 'mrow-numerator' ]
        )
        =
        normalize-space(
          child::span[ @class = 'mrow-enumerator' ]
           / child::span[ @class = 'continuous-mfrac' ]
           / child::span[ @class = 'mrow-numerator' ]
        )
      )
    and (
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   preceding-sibling::*[1] )
   =
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'continuous-mfrac' ] /
   preceding-sibling::*[1] )
)

" >
  <xsl:variable name="a">
   <xsl:apply-templates select="
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mcontinuous-mfrac' ] /
         preceding-sibling::*[2]
   "  mode="enum-op" />
</xsl:variable>
<xsl:variable name="b">
   <xsl:apply-templates select="
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mcontinuous-mfrac' ] /
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[
           (@class = 'mfrac') or (@class = 'mcontinuous-mfrac')
         ] /
         preceding-sibling::*[2]
   "  mode="enum-op" />
</xsl:variable>

  <xsl:choose>
     <xsl:when test="
         normalize-space($a)=normalize-space($b)
     " >
         <xsl:attribute name="class">
            <xsl:value-of select=" 'continuous-mfrac' " />
         </xsl:attribute>
         <xsl:apply-templates select="*|text()|comment()" />
     </xsl:when>
     <xsl:otherwise>
         <xsl:apply-templates select="*|@*|text()|comment()" />
     </xsl:otherwise>
  </xsl:choose>
</xsl:when>

       <xsl:when test="          
   (translate(
      normalize-space(
      child::span[ @class = 'mrow-numerator' ]),
                              '0123456789','')= '')
   and (  normalize-space(
   child::span[ @class = 'mrow-numerator' ])
  and
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-numerator' ])
)
and
(  normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-numerator' ])
  and
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-numerator' ])
)

   and (  child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   preceding-sibling::*[1][@class = 'mo-bin']
)
and
(  normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   preceding-sibling::*[1] )
   =
   normalize-space(
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   child::span[ @class = 'mrow-enumerator' ] /
   child::span[ @class = 'mfrac' ] /
   preceding-sibling::*[1] )
)

">
  <xsl:variable name="a">
   <xsl:apply-templates select="
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mfrac' ] /
         preceding-sibling::*[2]
   "  mode="enum-op" />
</xsl:variable>
<xsl:variable name="b">
   <xsl:apply-templates select="
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mfrac' ] /
         child::span[ @class = 'mrow-enumerator' ] /
         child::span[ @class = 'mfrac' ] /
         preceding-sibling::*[2]
   "  mode="enum-op" />
</xsl:variable>
<xsl:variable name="c">
   <xsl:value-of select="
    normalize-space(
      child::span[ @class = 'mrow-enumerator' ] /
      child::span[ @class = 'mfrac' ] /
      child::span[ @class = 'mrow-enumerator' ] /
      child::span[ @class = 'mfrac' ] /
      child::span[ @class = 'mrow-enumerator' ] )
   "  />
</xsl:variable>

  <xsl:choose>
     <xsl:when test="
         ( translate($a,'0123456789 ','') = '')
         and (normalize-space($a)=normalize-space($b))
         and starts-with( $c, normalize-space( $a ))
         and starts-with(
               normalize-space(
                 substring-after( $c, normalize-space( $a )) )
               ,
               normalize-space(
                    child::span[ @class = 'mrow-enumerator' ] /
                    child::span[ @class = 'mfrac' ] /
                    preceding-sibling::*[1]                  )
             )
     " >
         <xsl:attribute name="class">
            <xsl:value-of select=" 'continuous-mfrac' " />
         </xsl:attribute>
         <xsl:apply-templates select="*|text()|comment()" />
     </xsl:when>
     <xsl:otherwise>
         <xsl:apply-templates select="*|@*|text()|comment()" />
     </xsl:otherwise>
  </xsl:choose>
</xsl:when>

       <xsl:otherwise>
         <xsl:apply-templates select="*|@*|text()|comment()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template>
<xsl:template match="*" mode="enum-op">
   <xsl:if test="preceding-sibling::*" >
      <xsl:apply-templates select=" preceding-sibling::*[1] " />
   </xsl:if>
   <xsl:value-of select="." />
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="mfrac" />
</script>

     <script element="span::munder-underline" >
  <set name="munder" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not(
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template>

     <xsl:template match="span[
    (@class = 'munder-underline')
   and
    child::span[
       (@class = 'mo-0332')
       and
       descendant::span[ @class = 'mi' ]
   ]
]" >
  <xsl:copy>
    <xsl:apply-templates select="@*" />
    <xsl:variable name="content">
       <xsl:apply-templates select="*" mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test="
          string-length( normalize-space( $content )) = 1
       " >
           <xsl:apply-templates
              select=" *[ @class != 'begin-end' ] " />
           <span class="begin-end" title="speech-extra" >
              <xsl:text> under bar </xsl:text>
           </span>
       </xsl:when>
       <xsl:otherwise>
          <xsl:apply-templates select="*|text()|comment()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="munder" />
</script>
<script element="span::mover-overline" >
  <set name="mover" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not(
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template>

     <xsl:template match="span[
    (@class = 'mover-overline')
   and
    child::span[
       (@class = 'mo-00AF')
       and
       descendant::span[ @class = 'mi' ]
   ]
]" >
  <xsl:copy>
    <xsl:apply-templates select="@*" />
    <xsl:variable name="content">
       <xsl:apply-templates select="*" mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test="
          string-length( normalize-space( $content )) = 1
       " >
           <xsl:apply-templates
              select=" *[ @class != 'begin-end' ] " />
           <span class="begin-end" title="speech-extra" >
              <xsl:text> over bar </xsl:text>
           </span>
       </xsl:when>
       <xsl:otherwise>
          <xsl:apply-templates select="*|text()|comment()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="mover" />
</script>

     <script element="span::limits-msub-msup" >
  <set name="smash" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="span[
       (@class = 'limits-msub-msup')
     and
       child::*[ (position() = 1)
                 and (@class = 'limits-mrow-base')
                 and child::*[ (position() = 1)
                         and (@class = 'limits-msub-msup')
       ]             ]
]" >
  <xsl:copy>
     <xsl:apply-templates select="@*" />
     <xsl:apply-templates select="
                   *[1]
                   / *[1]
                   / *[ not(@class='limits-mrow-super') ]  " />
     <xsl:apply-templates select=" *[
                   preceding-sibling::*
                 and
                   not(@class='limits-mrow-super') ]" />
     <xsl:apply-templates select="
                   *[1]
                   / *[1]
                   / *[@class='limits-mrow-super' ]  " />
     <xsl:apply-templates select=" *[
                   preceding-sibling::*
                 and
                   (@class='limits-mrow-super') ]" />
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="smash" />
</script>

     <script element="span::mathvariant-bold" >
  <set name="bold" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not(
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template>

     <xsl:template match="span[ @class = 'mathvariant-bold' ]" >
  <xsl:copy>
    <xsl:apply-templates select="@*" />
    <xsl:variable name="content">
       <xsl:apply-templates select="*" mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test="
          string-length( normalize-space( $content )) = 1
       " >
          <span class="begin-end" title="speech-extra" >
             <xsl:text> bold </xsl:text>
          </span>
          <xsl:apply-templates select="*|text()|comment()" />
       </xsl:when>
       <xsl:otherwise>
          <span class="begin-end" title="speech-extra" >
             <xsl:text> begin bold </xsl:text>
          </span>
          <xsl:apply-templates select="*|text()|comment()" />
          <span class="begin-end" title="speech-extra" >
             <xsl:text> end bold </xsl:text>
          </span>
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="bold" />
</script>

     <script element="span::mi" >
  <set name="math-cap" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="span[ @class = 'mi' ]" >
  <xsl:copy>
    <xsl:apply-templates select="@*" />
      <xsl:if test=" string-length(.) = 1 " >
         <xsl:if test="
                     (translate(.,'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                                  '') = '' )
                  " >
            <span class="capital-description"
                  title="speech-extra" >
               <xsl:text> capital </xsl:text>
            </span>
         </xsl:if>
      </xsl:if>
    <xsl:apply-templates select="*|text()|comment()" />
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="math-cap" />
</script>

     <script element="div::tr" >
  <set name="bold" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="div[
    parent::div[ @class = 'tr' ]
    and ( normalize-space(.) = '' )
    and not( normalize-space(following-sibling::*) != '' )
]" >
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="bold" />
</script>

     <script element="span::inline-math" >
    <set name="num-sub" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="span[
    (@class = 'msub')
  and
    (count( child::span[ @class = 'mrow-base' ]
           / child::* ) = 1 )
  and not( ancestor::*[
      (@class = 'msub')
    or
      (@class = 'msup')
    or
      (@class = 'msubsup')
    ] )
  and
    not( child::span[ @class = 'mrow-sub' ]
           / child::* [
                not( @title = 'speech-extra' )
              and
                not( @class = 'mn' )
              and
                not(
                  (@class = 'mo-punc')
                  and
                  ( . = ',' )
                  and
                  preceding-sibling::*[1][ @class = 'mn' ]
                  and
                  following-sibling::*[1][ @class = 'mn' ]
                  and
                  following-sibling::*[2][ @class = 'mn' ]
                  and
                  following-sibling::*[3][ @class = 'mn' ]
                  and
                  (  not(following-sibling::*[4])
                     or
                     not(following-sibling::*[4][ @class = 'mn' ])
                  )
                )
              and
                not(
                  (@class = 'mo-punc')
                  and
                  ( . = '.' )
                  and
                  following-sibling::*[1][ @class = 'mn' ]
                  and
                  not(
                    following-sibling::*[
                       (@class = 'mo-punc')
                     and
                       (. = '.')
                    ]
                  )
                )
          ])
]" >
  <xsl:copy>
     <xsl:apply-templates select="@*" />
     <xsl:apply-templates select="*[1]" />
     <span class="mrow-sub">
        <span class="space" title="speech-extra">
           <xsl:text> </xsl:text>
        </span>
        <xsl:apply-templates
           select="*[2] / *[
                    not(@title = 'speech-extra')
                 and
                    not(
                      (@class = 'mo-punc')
                      and (. = ',')
                    )
          ]" />
     </span>
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="num-sub" />

  <dom name="." xml="." method="fracLevel" class="tex4ht.HtSpk" />
<set name="rmXmlDecl" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="rmXmlDecl" />


  <dom name="." xml="." method="scriptLevel" class="tex4ht.HtSpk" />
<set name="rmXmlDecl" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="rmXmlDecl" />


  <dom name="." xml="." method="rootLevel" class="tex4ht.HtSpk" />
<set name="rmXmlDecl" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="rmXmlDecl" />


  <set name="inline-math" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not(
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template match="span[
   (@class = 'end-script')
   and
   ancestor::* [ following-sibling::* [
                         not( @class = 'content-less' )
                      ]
               ][1]
           / following-sibling::* [
                         not( @class = 'content-less' )
                     ][1]
           / self::*
    [
       (@class = 'end-math')
       or
       (@class = 'end-script')
       or
       (@class = 'end-root')
       or
       (@class = 'end-stack')
       or
       (@class = 'mid-stack')
       or
       (@class = 'end-array')
       or
       (@class = 'tr')
       or
       (@title = 'implicit-baseline')
    ]
]"  >
</xsl:template>

<xsl:template match="span[
   ((@class = 'mfrac') and
                       (translate(
                          concat(
                            span[ (@class = 'mrow-numerator')],
                            span[ (@class = 'mrow-enumerator')]
                          )  ,'0123456789','') = '')
                       and
                       not(descendant::*/descendant::*/descendant::*)
    or
    (@class = 'word-frac'))
   and
   preceding-sibling::*[1]
       / self::span[ @class = 'mn']
 ]" >
  <xsl:text> and </xsl:text>
  <xsl:copy>
    <xsl:apply-templates select="*|@*|text()|comment()" />
  </xsl:copy>
</xsl:template>

<xsl:template match="span[
    (@class = 'mo-bin')
  and
    (   preceding-sibling::*[
           (position()=1)
           and
           ( (@title='speech-extra')
             or (@class='mo-bin')
             or (@class='mo-rel')  )
        ]
        and
        (
           following-sibling::*[ (@class='mn') or (@class='mi') ]
          or
           (count(following-sibling::*[
               not(@title = 'speech-extra')
            ]) = 1)
        )
      or
        not(preceding-sibling::*)
    )
  and
    (normalize-space(.)='minus')
]" >
  <xsl:copy>
    <xsl:attribute name="class">
       <xsl:text>mo-unary</xsl:text>
    </xsl:attribute>
    <xsl:apply-templates select="*|text()|comment()"
                         mode="minus-neg" />
  </xsl:copy>
</xsl:template>
<xsl:template match="*|@*|text()|comment()" mode="minus-neg" >
  <xsl:copy>
    <xsl:apply-templates select="*|@*|text()|comment()"
                         mode="minus-neg" />
  </xsl:copy>
</xsl:template>
<xsl:template match="text()" mode="minus-neg" >
  <xsl:choose>
    <xsl:when test=" . = 'minus' " >
      <xsl:text>negative</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="." />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="span[ @class = 'end-limits-script' ]" >
  <xsl:if test=" parent::*[ not(following-sibling::*) ] ">
    <xsl:copy>
       <xsl:apply-templates select=" @* " />
       <xsl:choose>
          <xsl:when test="
                parent::*[ preceding-sibling::span[
                                  @class != 'limits-mrow-base'
                         ]  ]
            " >
            <xsl:text> end scripts </xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text> end script </xsl:text>
          </xsl:otherwise>
       </xsl:choose>
    </xsl:copy>
  </xsl:if>
</xsl:template>
<xsl:template match="span[ @class = 'begin-limits-script' ]" >
    <xsl:copy>
       <xsl:apply-templates select=" @* " />
       <xsl:choose>
          <xsl:when test="
                parent::*[ @class = 'limits-mrow-super'  ]
          " >
              <xsl:apply-templates
                  select=" parent::*
                           / preceding-sibling::*[1] "
                  mode = "extra-over" />
          </xsl:when>
          <xsl:when test="
                parent::*[ @class = 'limits-mrow-sub'  ]
          " >
              <xsl:apply-templates
                  select=" parent::*
                           / preceding-sibling::*[1] "
                  mode = "extra-under" />
          </xsl:when>
       </xsl:choose>
       <xsl:apply-templates select="*|text()|comment()" />
    </xsl:copy>
</xsl:template>
<xsl:template match="*" mode="extra-over" >
   <xsl:if   test = " self::span[ @class = 'limits-mrow-super' ] " >
     <xsl:text> over </xsl:text>
     <xsl:apply-templates select=" preceding-sibling::*[1] "
                    mode = "extra-over" />
   </xsl:if>
</xsl:template>
<xsl:template match="*" mode="extra-under" >
   <xsl:if   test = " self::span[ @class = 'limits-mrow-sub' ] " >
     <xsl:text> under </xsl:text>
     <xsl:apply-templates select=" preceding-sibling::*[1] "
                    mode = "extra-under" />
   </xsl:if>
</xsl:template>

<xsl:template match="span[
    (@class = 'begin-script')
  and
    following-sibling::*[
         child::span / child::span[
            (@class = 'ch 2032') or (@class = 'ch 2033')
                                 or (@class = 'ch 2034')
    ]    ]
]" >
</xsl:template>
<xsl:template match="span[
    (@class = 'end-script')
  and
    preceding-sibling::*[
         child::span / child::span[
            (@class = 'ch 2032') or (@class = 'ch 2033')
                                 or (@class = 'ch 2034')
    ]    ]
]" >
</xsl:template>


     <xsl:template match="span[
    (@class = 'inline-math')
  and
    (count( child::*[ not(@title) or (@title != 'speech-extra') ]
 ) = 1)
]" >
  <xsl:copy>
    <xsl:variable name="content">
       <xsl:apply-templates
           select="child::*[ not(@title) or (@title != 'speech-extra') ]
"
             mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test="
          string-length( normalize-space( $content )) = 1
       " >
          <xsl:attribute name="class">
             <xsl:text>semi-math</xsl:text>
          </xsl:attribute>
          <xsl:apply-templates select="child::*[ not(@title) or (@title != 'speech-extra') ]
" />
       </xsl:when>
       <xsl:when test="  child::*[
     (position() = 2)
   and
     ((@class = 'msub') or (@class = 'msup') or (@class = 'msubsup'))
]" >
    <xsl:variable name="content">
       <xsl:apply-templates select="child::*[2] / child::*[
                                       @class = 'mrow-base' ]"
                            mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test="
          string-length( normalize-space( $content )) = 1
       " >
          <xsl:attribute name="class">
             <xsl:text>semi-math</xsl:text>
          </xsl:attribute>
          <xsl:apply-templates select="*[2]" />

      </xsl:when>
       <xsl:otherwise>
          <xsl:apply-templates select="*|@*|comment()|text()" />
       </xsl:otherwise>
    </xsl:choose>
</xsl:when>

       <xsl:otherwise>
          <xsl:apply-templates select="*|@*|comment()|text()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="inline-math" />
  <set name="inline-math-2" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not(
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template match="span[
     (@class = 'end-script')
   and
     ancestor::*[ preceding-sibling::* [
       ((@class = 'begin-script') or (@class = 'mid-script')) ]]

]" >
  <xsl:copy>
     <xsl:apply-templates select="*|@*|comment()" />
     <xsl:value-of select="
            ancestor::*[ preceding-sibling::* [
                           ((@class = 'begin-script') or
                            (@class = 'mid-script'))     ]]  [1]
            / preceding-sibling::* [
                           ((@class = 'begin-script') or
                            (@class = 'mid-script'))  ][1]
      " />
  </xsl:copy>
</xsl:template>

<xsl:template match="span[ @class = 'mi' ]" >
  <span class="space" title="speech-extra">
     <xsl:text> </xsl:text>
  </span>
  <xsl:copy>
     <xsl:apply-templates select="*|@*|text()|comment()" />
  </xsl:copy>
</xsl:template>

<xsl:template match="span[
     (@class = 'begin-script')
   and
     following-sibling::* [1] / child::*[
       (position() = 1)
       and
       (@class = 'mrow-base')
       and
       ( normalize-space(.) = '' )
     ]
]"  >
</xsl:template>


     <xsl:template match="span[
    (@class = 'inline-math')
  and
    (count( child::*[ not(@title) or (@title != 'speech-extra') ]
 ) = 2)
  and
    child::span[
        (@class = 'mo-unary')
      and
        following-sibling::*[1]
        / descendant::span[ @class = 'mi' ]
    ]
]" >
  <xsl:copy>
    <xsl:variable name="content">
       <xsl:apply-templates
           select="child::*[
               (not(@title) or (@title != 'speech-extra'))
               and not( @class = 'mo-unary' )
             ]"
             mode="content" />
    </xsl:variable>
    <xsl:choose>
       <xsl:when test="
          string-length( normalize-space( $content )) = 1
       " >
          <xsl:attribute name="class">
             <xsl:text>semi-math</xsl:text>
          </xsl:attribute>
          <xsl:apply-templates select="child::*[ not(@title) or (@title != 'speech-extra') ]
" />
       </xsl:when>
       <xsl:otherwise>
          <xsl:apply-templates select="*|@*|comment()|text()" />
       </xsl:otherwise>
    </xsl:choose>
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="inline-math-2" />
  <set name="empty-el" >
   <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

   <xsl:template match="*[ not(child::*) ]" >
  <xsl:copy>
    <xsl:apply-templates select="@*|comment()|text()" />
    <xsl:if test=" normalize-space(.) = '' " >
       <xsl:comment>.</xsl:comment>
    </xsl:if>
  </xsl:copy>
</xsl:template>

         <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="empty-el" />

</script>

     <script element="div::display-math" >
    <set name="num-sub" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="span[
    (@class = 'msub')
  and
    (count( child::span[ @class = 'mrow-base' ]
           / child::* ) = 1 )
  and not( ancestor::*[
      (@class = 'msub')
    or
      (@class = 'msup')
    or
      (@class = 'msubsup')
    ] )
  and
    not( child::span[ @class = 'mrow-sub' ]
           / child::* [
                not( @title = 'speech-extra' )
              and
                not( @class = 'mn' )
              and
                not(
                  (@class = 'mo-punc')
                  and
                  ( . = ',' )
                  and
                  preceding-sibling::*[1][ @class = 'mn' ]
                  and
                  following-sibling::*[1][ @class = 'mn' ]
                  and
                  following-sibling::*[2][ @class = 'mn' ]
                  and
                  following-sibling::*[3][ @class = 'mn' ]
                  and
                  (  not(following-sibling::*[4])
                     or
                     not(following-sibling::*[4][ @class = 'mn' ])
                  )
                )
              and
                not(
                  (@class = 'mo-punc')
                  and
                  ( . = '.' )
                  and
                  following-sibling::*[1][ @class = 'mn' ]
                  and
                  not(
                    following-sibling::*[
                       (@class = 'mo-punc')
                     and
                       (. = '.')
                    ]
                  )
                )
          ])
]" >
  <xsl:copy>
     <xsl:apply-templates select="@*" />
     <xsl:apply-templates select="*[1]" />
     <span class="mrow-sub">
        <span class="space" title="speech-extra">
           <xsl:text> </xsl:text>
        </span>
        <xsl:apply-templates
           select="*[2] / *[
                    not(@title = 'speech-extra')
                 and
                    not(
                      (@class = 'mo-punc')
                      and (. = ',')
                    )
          ]" />
     </span>
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="num-sub" />

  <dom name="." xml="." method="fracLevel" class="tex4ht.HtSpk" />
<set name="rmXmlDecl" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="rmXmlDecl" />


  <dom name="." xml="." method="scriptLevel" class="tex4ht.HtSpk" />
<set name="rmXmlDecl" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="rmXmlDecl" />


  <dom name="." xml="." method="rootLevel" class="tex4ht.HtSpk" />
<set name="rmXmlDecl" >
  <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

        <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="rmXmlDecl" />


  <set name="display-math" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not(
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template match="span[
   (@class = 'end-script')
   and
   ancestor::* [ following-sibling::* [
                         not( @class = 'content-less' )
                      ]
               ][1]
           / following-sibling::* [
                         not( @class = 'content-less' )
                     ][1]
           / self::*
    [
       (@class = 'end-math')
       or
       (@class = 'end-script')
       or
       (@class = 'end-root')
       or
       (@class = 'end-stack')
       or
       (@class = 'mid-stack')
       or
       (@class = 'end-array')
       or
       (@class = 'tr')
       or
       (@title = 'implicit-baseline')
    ]
]"  >
</xsl:template>

<xsl:template match="span[
   ((@class = 'mfrac') and
                       (translate(
                          concat(
                            span[ (@class = 'mrow-numerator')],
                            span[ (@class = 'mrow-enumerator')]
                          )  ,'0123456789','') = '')
                       and
                       not(descendant::*/descendant::*/descendant::*)
    or
    (@class = 'word-frac'))
   and
   preceding-sibling::*[1]
       / self::span[ @class = 'mn']
 ]" >
  <xsl:text> and </xsl:text>
  <xsl:copy>
    <xsl:apply-templates select="*|@*|text()|comment()" />
  </xsl:copy>
</xsl:template>

<xsl:template match="span[
    (@class = 'mo-bin')
  and
    (   preceding-sibling::*[
           (position()=1)
           and
           ( (@title='speech-extra')
             or (@class='mo-bin')
             or (@class='mo-rel')  )
        ]
        and
        (
           following-sibling::*[ (@class='mn') or (@class='mi') ]
          or
           (count(following-sibling::*[
               not(@title = 'speech-extra')
            ]) = 1)
        )
      or
        not(preceding-sibling::*)
    )
  and
    (normalize-space(.)='minus')
]" >
  <xsl:copy>
    <xsl:attribute name="class">
       <xsl:text>mo-unary</xsl:text>
    </xsl:attribute>
    <xsl:apply-templates select="*|text()|comment()"
                         mode="minus-neg" />
  </xsl:copy>
</xsl:template>
<xsl:template match="*|@*|text()|comment()" mode="minus-neg" >
  <xsl:copy>
    <xsl:apply-templates select="*|@*|text()|comment()"
                         mode="minus-neg" />
  </xsl:copy>
</xsl:template>
<xsl:template match="text()" mode="minus-neg" >
  <xsl:choose>
    <xsl:when test=" . = 'minus' " >
      <xsl:text>negative</xsl:text>
    </xsl:when>
    <xsl:otherwise>
      <xsl:value-of select="." />
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="span[ @class = 'end-limits-script' ]" >
  <xsl:if test=" parent::*[ not(following-sibling::*) ] ">
    <xsl:copy>
       <xsl:apply-templates select=" @* " />
       <xsl:choose>
          <xsl:when test="
                parent::*[ preceding-sibling::span[
                                  @class != 'limits-mrow-base'
                         ]  ]
            " >
            <xsl:text> end scripts </xsl:text>
          </xsl:when>
          <xsl:otherwise>
            <xsl:text> end script </xsl:text>
          </xsl:otherwise>
       </xsl:choose>
    </xsl:copy>
  </xsl:if>
</xsl:template>
<xsl:template match="span[ @class = 'begin-limits-script' ]" >
    <xsl:copy>
       <xsl:apply-templates select=" @* " />
       <xsl:choose>
          <xsl:when test="
                parent::*[ @class = 'limits-mrow-super'  ]
          " >
              <xsl:apply-templates
                  select=" parent::*
                           / preceding-sibling::*[1] "
                  mode = "extra-over" />
          </xsl:when>
          <xsl:when test="
                parent::*[ @class = 'limits-mrow-sub'  ]
          " >
              <xsl:apply-templates
                  select=" parent::*
                           / preceding-sibling::*[1] "
                  mode = "extra-under" />
          </xsl:when>
       </xsl:choose>
       <xsl:apply-templates select="*|text()|comment()" />
    </xsl:copy>
</xsl:template>
<xsl:template match="*" mode="extra-over" >
   <xsl:if   test = " self::span[ @class = 'limits-mrow-super' ] " >
     <xsl:text> over </xsl:text>
     <xsl:apply-templates select=" preceding-sibling::*[1] "
                    mode = "extra-over" />
   </xsl:if>
</xsl:template>
<xsl:template match="*" mode="extra-under" >
   <xsl:if   test = " self::span[ @class = 'limits-mrow-sub' ] " >
     <xsl:text> under </xsl:text>
     <xsl:apply-templates select=" preceding-sibling::*[1] "
                    mode = "extra-under" />
   </xsl:if>
</xsl:template>

<xsl:template match="span[
    (@class = 'begin-script')
  and
    following-sibling::*[
         child::span / child::span[
            (@class = 'ch 2032') or (@class = 'ch 2033')
                                 or (@class = 'ch 2034')
    ]    ]
]" >
</xsl:template>
<xsl:template match="span[
    (@class = 'end-script')
  and
    preceding-sibling::*[
         child::span / child::span[
            (@class = 'ch 2032') or (@class = 'ch 2033')
                                 or (@class = 'ch 2034')
    ]    ]
]" >
</xsl:template>


           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="display-math" />
  <set name="display-math-2" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not(
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template>

<xsl:template match="span[
     (@class = 'end-script')
   and
     ancestor::*[ preceding-sibling::* [
       ((@class = 'begin-script') or (@class = 'mid-script')) ]]

]" >
  <xsl:copy>
     <xsl:apply-templates select="*|@*|comment()" />
     <xsl:value-of select="
            ancestor::*[ preceding-sibling::* [
                           ((@class = 'begin-script') or
                            (@class = 'mid-script'))     ]]  [1]
            / preceding-sibling::* [
                           ((@class = 'begin-script') or
                            (@class = 'mid-script'))  ][1]
      " />
  </xsl:copy>
</xsl:template>

<xsl:template match="span[ @class = 'mi' ]" >
  <span class="space" title="speech-extra">
     <xsl:text> </xsl:text>
  </span>
  <xsl:copy>
     <xsl:apply-templates select="*|@*|text()|comment()" />
  </xsl:copy>
</xsl:template>

<xsl:template match="span[
     (@class = 'begin-script')
   and
     following-sibling::* [1] / child::*[
       (position() = 1)
       and
       (@class = 'mrow-base')
       and
       ( normalize-space(.) = '' )
     ]
]"  >
</xsl:template>


           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="display-math-2" />
  <set name="empty-el" >
   <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

   <xsl:template match="*[ not(child::*) ]" >
  <xsl:copy>
    <xsl:apply-templates select="@*|comment()|text()" />
    <xsl:if test=" normalize-space(.) = '' " >
       <xsl:comment>.</xsl:comment>
    </xsl:if>
  </xsl:copy>
</xsl:template>

         <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

</set>
<xslt name="." xml="." xsl="empty-el" />

</script>

     
     <script element="div::split-side" >
  <set name="clean-split" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="*" mode="content" >
  <xsl:choose>
     <xsl:when test=" @class = 'char' " >
       <xsl:text>x</xsl:text>
     </xsl:when>
     <xsl:when test=" not(
            (@title = 'speech-extra') or (@class = 'accent-char')
         ) " >
       <xsl:apply-templates select="*|text()" mode="content" />
     </xsl:when>
  </xsl:choose>
</xsl:template>

     <xsl:template match=" div[ @class='split-side' ]
" >
    <xsl:variable name="content">
       <xsl:apply-templates select="*" mode="content" />
    </xsl:variable>
    <xsl:if test="
       string-length( normalize-space( $content )) != 0
    " >
       <xsl:copy>
          <xsl:apply-templates select=" *|@*|text()|comment() " />
       </xsl:copy>
    </xsl:if>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="clean-split" />
</script>

     <script element="div::newtheorem" >
  <set name="newtheorem" >
     <![CDATA[
   <xsl:stylesheet version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   >
      <xsl:output omit-xml-declaration = "yes" />

     <xsl:template match="
    div[   (@class='newtheorem')
         and
           child::*[1] / child::span[ @class = 'theorem-head' ]
    ]
" >
   <xsl:copy>
     <xsl:apply-templates select="*|@*|text()|comment()" />
     <div class="begin-end" title="speech-extra">
        <xsl:value-of select="
           concat( ' end ',
                   string( child::*[1] /
                           child::span[ @class = 'theorem-head' ] )
           ) " />
     </div>
   </xsl:copy>
</xsl:template>

     <xsl:template match="*[ not(child::*) ]" >
  <xsl:copy>
    <xsl:apply-templates select="@*|comment()|text()" />
    <xsl:if test=" normalize-space(.) = '' " >
       <xsl:comment>.</xsl:comment>
    </xsl:if>
  </xsl:copy>
</xsl:template>

           <xsl:template match="*|@*|text()|comment()" >
        <xsl:copy>
          <xsl:apply-templates select="*|@*|text()|comment()" />
        </xsl:copy>
      </xsl:template>
   </xsl:stylesheet>
]]>

  </set>
  <xslt name="." xml="." xsl="newtheorem" />
</script>

   </sax>
</xtpipes>

