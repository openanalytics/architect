%--------------------------------------------
%
% Package pgfplots, library for polar coordinates.
%
% Copyright 2010 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%  A polar axis lives in (ANGLE,LENGTH).
%  That is
%    x == ANGLE
%    y == LENGTH
%
%

\pgfplotsdefineaxistype[polar]{polar}{%
	\pgfplots@polaraxis@activate
}%

\newif\ifpgfplots@polaraxis@rellimits

\pgfplotsset{
	/pgfplots/every polar axis/.style={
		grid=major,
		xtick pos=right,
		ytick pos=right,
		every axis title shift=1.2\baselineskip,
		legend style={anchor=center},
		/pgfplots/polar labels,
	},
	/pgfplots/polar labels/.code={
		% this is equivalent to 'use units=false'. But that key is only available if the units lib is loaded.
		\pgfplots@units@usefalse
		\if1\b@pgfplots@polaraxis@fix@positioning
			\pgfkeysalso{%
				every axis x label/.style={
					at={(xticklabel cs:0.125)},
					sloped={at position=45},
					anchor=near ticklabel,
					near ticklabel at=45,
				},
				every axis y label/.style={
					at={(yticklabel cs:0.5)},
					anchor=near ticklabel,
				},
			}%
		\else
			\pgfkeysalso{%
				% is this a good choice? No, it is not.
				% In fact, I believe that neither xlabel nor ylabel is a good idea for a polar plot.
				% BUT: if we simply leave the defaults, they will be placed outside of the circle - and
				% this will confuse the units library which (for some reason) always generates labels.
				every axis x label/.style={
					at={(rel axis cs:0,0.5)},
					anchor=north,
				},
				every axis y label/.style={
					at={(0.2,0.85)},
					anchor=center,
				},
			}%
		\fi
	},
	/pgfplots/polar labels style/.style={%
		/pgfplots/polar labels/.append style={#1}%
	},%
	/pgfplots/xticklabel in circle/.style={
		xtick align=inside,
		xticklabel style={
			rotate=90,
			sloped like x axis={%
				execute for upside down={\tikzset{anchor=north east}},
				%allow upside down,
				reset nontranslations=false},
			anchor=south west,
			%font=\tiny,
		}
	},
}

\def\pgfplots@polaraxis@activate{%
	% FIXME : activating it results in strange output:
	\pgfplots@LUA@backend@supportedfalse
	%
	\let\pgfplotsqpointxy@cart=\pgfplotsqpointxy
	\let\pgfplotsqpointxy=\pgfplotsqpointxy@polaraxis
	\let\pgfplotsqpointxy@orthogonal=\pgfplotsqpointxy
	\if1\b@pgfplots@polaraxis@fix@positioning
		% this is needed in order to let
		% \pgfplotspointonorientedsurfaceab work
		\def\pgfplotsqpointxyz##1##2##3{%
			% ignore z here.
			\pgfplotsqpointxy{##1}{##2}%
		}%
	\fi
	\let\pgfplotspointouternormalvectorofaxis@=\pgfplotspointouternormalvectorofaxis@polaraxis
	\def\pgfplotspointouternormalvectorofaxis@ifdependson@v##1##2##3{##2}%
	\def\pgfplots@drawtickgridlines@INSTALLCLIP@onorientedsurf##1{}%
	\let\pgfplots@clippath@prepare@for@axistype=\pgfplots@clippath@prepare@for@axistype@polaraxis
	\let\pgfplots@handle@invalid@range@defaultlimits=\pgfplots@handle@invalid@range@defaultlimits@polar%
	\let\pgfplots@check@invalid@range=\pgfplots@check@invalid@range@polar
	\let\pgfplotspointonorientedsurfaceabwithbshift=\pgfplotspointonorientedsurfaceabwithbshift@polaraxis
	\let\pgfplots@drawgridlines@onorientedsurf@fromto=\pgfplots@drawgridlines@onorientedsurf@fromto@polar
	\let\pgfplotspoint@initialisation@axes=\pgfplotspoint@initialisation@axes@polar%
	\let\pgfplotspoint@initialisation@units=\pgfplotspoint@initialisation@units@polar
	\let\pgfplotsaxisifcontainspoint=\pgfplotsaxisifcontainspoint@polar
	\let\pgfplots@prepare@axis@API=\pgfplots@prepare@axis@API@polar
	\def\axisdefaultheight{\axisdefaultwidth}%
	\let\pgfplots@initsizes=\pgfplots@initsizes@polar
	\let\pgfplots@BB@for@plotbox@get@unit@scales@for@limits=\pgfplots@BB@for@plotbox@get@unit@scales@for@limits@polar
	\let\pgfplots@limits@ready=\pgfplots@limits@ready@polar
	\let\pgfplots@assign@default@tick@foraxis@normalizetickdist=\pgfplots@assign@default@tick@foraxis@normalizetickdist@polar
	\let\pgfplots@show@ticklabel@=\pgfplots@show@ticklabel@@polar
	\let\pgfplots@transformshift@along@outer@normal@on@line@of@oriented@surf=\pgfplots@transformshift@along@outer@normal@on@line@of@oriented@surf@polar
	\let\pgfplots@enlarge@limit@for=\pgfplots@enlarge@limit@for@polar
	\let\pgfplotstransformtoaxisdirection@=\pgfplotstransformtoaxisdirection@@polar
	\def\pgfplots@xtick@disable@last@tick{0}%
	\let\pgfplots@xtick@check@tickshow=\pgfplots@xtick@check@tickshow@polar%
	\let\pgfplots@set@options@sanitize=\relax
	\let\pgfplots@set@options@sanitizemode=\relax
	\let\pgfplotscoordmathnotifydatascalesetfor=\pgfplotscoordmathnotifydatascalesetfor@polar
	%
	% this here is set *before* 'every polar axis' is invoked.
	\pgfplotsset{
		enlarge x limits=false,
	}%
	\expandafter\def\expandafter\pgfplots@notify@options@are@set\expandafter{%
		\pgfplots@notify@options@are@set
		\pgfplotsset{separate axis lines}%
	}%
	\def\pgfplots@xticklabel@pos{}%
	\def\pgfplots@yticklabel@pos{}%
	\def\pgfplots@zticklabel@pos{}%
	\def\pgfplots@init@ticklabelaxisspecfor##1##2{}%
	\def\pgfplots@init@ticklabelaxisspec@twodim@for##1##2{}%
	\def\pgfplots@xticklabelaxisspec{v10}%
	\def\pgfplots@yticklabelaxisspec{0v0}%
	\def\pgfplots@zticklabelaxisspec{00v}%
	%
	% cartesian cs
	\tikzdeclarecoordinatesystem{cartesian}{\edef\pgfplots@loc@TMPa{##1}\expandafter\pgfplotspointcartesian@\pgfplots@loc@TMPa\pgfplots@coord@end}%
	%
}%

\let\pgfplots@prepare@axis@API@orig=\pgfplots@prepare@axis@API
\def\pgfplots@prepare@axis@API@polar{%
	\pgfplots@prepare@axis@API@orig
	\let\pgfplotsaxisupdatelimitsforcoordinatetwodim=\pgfplotsaxisupdatelimitsforcoordinatetwodim@polar
	\let\pgfplotsaxisupdatelimitsforcoordinatethreedim=\pgfplotsaxisupdatelimitsforcoordinatetwodim@polar
}%

\let\pgfplotstransformtoaxisdirection@@orig=\pgfplotstransformtoaxisdirection@
\def\pgfplotstransformtoaxisdirection@@polar[#1]#2{%
	\if#2y%
		\pgfplotstransformtoaxisdirection@@orig[#1]{#2}%
	\else
		% ah, the angle. Treat it with special care.
		\pgfplots@sloped@allowupsidedownfalse
		\pgfplots@sloped@resets@nontranslationstrue
		%
		\def\pgfplots@loc@TMPa{#1}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\pgfqkeys{/pgfplots/sloped}{#1}%
		\fi
		\ifpgfplots@sloped
			%
			\ifpgfplots@sloped@resets@nontranslations
				\pgftransformresetnontranslations
			\fi
			%
			\pgfkeysgetvalue{/pgfplots/sloped/at position}\pgfplots@loc@TMPd
			\ifx\pgfplots@loc@TMPd\pgfutil@empty
				\def\pgfplots@loc@TMPd{90}%
			\else
				\pgfmathparse{90+\pgfplots@loc@TMPd}%
				\let\pgfplots@loc@TMPd=\pgfmathresult
			\fi
			\pgfpointpolar{\pgfplots@loc@TMPd}{1pt}%
			%
			\ifdim\pgf@x<0pt%   
				% oh. upside down.
				\pgfkeysvalueof{/pgfplots/sloped/execute for upside down}%
				\ifpgfplots@sloped@allowupsidedown
				\else
					% do not allow upside down labels:
					\global\pgf@x=-\pgf@x%
					\global\pgf@y=-\pgf@y%
				\fi
			\fi%
			%
			\pgf@ya=-\pgf@y%
			% set up rotation matrix 
			%  [ cos(alpha) sin(alpha); 
			%   -sin(alpha) cos(alpha) ]
			% where cos(alpha) = n_x and sin(alpha) = n_y:
			\pgftransformcm%
			{\pgf@sys@tonumber{\pgf@x}}{\pgf@sys@tonumber{\pgf@y}}%
			{\pgf@sys@tonumber{\pgf@ya}}{\pgf@sys@tonumber{\pgf@x}}{\pgfpointorigin}%
		\fi
	\fi
}

\def\pgfplotsaxisupdatelimitsforcoordinatetwodim@polar#1#2#3{%
	%
	%
	% Update limits:
	% I do not respect x limits (since they are periodic).
	% Consequently, I do not respect the clip limits options here (I
	% suppose it is useless)
	%
	% for y (radius) limits, I always use the ABSOLUTE value:
	\pgfmathfloatabs@{#2}%
	\let\pgfplots@loc@limit=\pgfmathresult
	%
	\ifpgfplots@autocompute@ymax
		\ifpgfplots@yislinear
			\pgfplotsmathfloatmax{\pgfplots@ymax}{\pgfplots@loc@limit}%
			\global\let\pgfplots@ymax=\pgfmathresult
		\else
			\pgfplotsmathmax{\pgfplots@ymax}{\pgfplots@loc@limit}%
			\global\let\pgfplots@ymax=\pgfmathresult
		\fi
	\fi
	%
	% Compute data range:
	\pgfplotsmathfloatmin{\pgfplots@data@xmin}{#1}%
	\global\let\pgfplots@data@xmin=\pgfmathresult
	\pgfplotsmathfloatmax{\pgfplots@data@xmax}{#1}%
	\global\let\pgfplots@data@xmax=\pgfmathresult
	\pgfplotsmathfloatmin{\pgfplots@data@ymin}{#2}%
	\global\let\pgfplots@data@ymin=\pgfmathresult
	\pgfplotsmathfloatmax{\pgfplots@data@ymax}{#2}%
	\global\let\pgfplots@data@ymax=\pgfmathresult
%\pgfplots@message{Updated limits: (\pgfplots@xmin,\pgfplots@ymin) rectangle  (\pgfplots@xmax,\pgfplots@ymax).}%
%
%\tracingmacros=0\tracingcommands=0
}%
\def\pgfplotsaxisifcontainspoint@polar#1#2{%
	\begingroup
	\pgfmath@basic@mod@{\pgfplots@current@point@x}{360}%
	\pgf@xa=\pgfmathresult pt %
	%
	\pgf@ya=\pgfplots@current@point@y pt %
	\ifdim\pgf@ya<0pt
		% absolute value:
		\pgf@ya=-\pgf@ya
	\fi
%\message{ifcontainspoint(\the\pgf@xa,\pgfplots@current@point@y) limits = [\pgfplots@xmin@mod:\pgfplots@xmax@mod] x [\the\pgfplots@ymin@reg,\the\pgfplots@ymax@reg]^^J}%
	% 
	% I assume that \pgfplots@[xyz]min@reg and min@reg are registers
	% containing the limits.
	\pgfplots@loop@CONTINUEfalse
	\ifdim\pgf@ya<\pgfplots@ymin@reg
	\else
		\ifdim\pgf@ya>\pgfplots@ymax@reg
		\else
			\if1\b@pgfplots@polar@limit@around@zero
				% check condition 
				%     x <= max || x >= min
				% <=> ! (x > max && x < min)
				\pgfplots@loop@CONTINUEtrue
				\ifdim\pgf@xa>\pgfplots@xmax@mod pt %
					\ifdim\pgf@xa<\pgfplots@xmin@mod pt %
						\pgfplots@loop@CONTINUEfalse
					\fi
				\fi
			\else
				\ifdim\pgf@xa<\pgfplots@xmin@mod pt %
				\else
					\ifdim\pgf@xa>\pgfplots@xmax@mod pt %
					\else
						\pgfplots@loop@CONTINUEtrue
					\fi
				\fi
			\fi
		\fi
	\fi
	\ifpgfplots@loop@CONTINUE
		\def\pgfplots@loc@TMPa{#1}%
	\else
		\def\pgfplots@loc@TMPa{#2}%
	\fi
	\expandafter\endgroup\pgfplots@loc@TMPa%
}

\def\pgfplots@check@invalid@range@polar{%
	%
	% A polar axis allows \addplot3, but it ignores the third
	% coordinate.
	\pgfplots@threedimfalse
	%
	\pgfplots@limits@are@computedtrue
	\ifx\pgfplots@xmin\pgfplots@invalidrange@xmin
		\pgfplotscoordmath{x}{zero}%
		\let\pgfplots@xmin=\pgfmathresult
	\fi
	\ifx\pgfplots@xmax\pgfplots@invalidrange@xmax
		\pgfplotscoordmath{x}{parsenumber}{360}%
		\let\pgfplots@xmax=\pgfmathresult
	\fi
	\ifx\pgfplots@ymin\pgfplots@invalidrange@ymin
		\pgfplotscoordmath{y}{zero}%
		\let\pgfplots@ymin=\pgfmathresult
	\fi
	\ifx\pgfplots@ymax\pgfplots@invalidrange@ymax
		\pgfplots@limits@are@computedfalse
	\fi
	\ifpgfplots@limits@are@computed
		\ifx\pgfplots@data@xmin\pgfplots@invalidrange@xmin
			\global\let\pgfplots@data@xmin=\pgfplots@xmin
		\fi
		\ifx\pgfplots@data@xmin\pgfplots@invalidrange@xmax
			\global\let\pgfplots@data@xmax=\pgfplots@xmax
		\fi
		\ifx\pgfplots@data@ymin\pgfplots@invalidrange@ymin
			\global\let\pgfplots@data@ymin=\pgfplots@ymin
		\fi
		\ifx\pgfplots@data@ymin\pgfplots@invalidrange@ymax
			\global\let\pgfplots@data@ymax=\pgfplots@ymax
		\fi
		\ifpgfplots@clip@limits@x
		\else
			% there is a rare change that min > max.
			% Handle that ...
			\pgfplotscoordmath{x}{min}{\pgfplots@xmin}{\pgfplots@xmax}%
			\global\let\pgfplots@xmin=\pgfmathresult
			\pgfplotscoordmath{x}{max}{\pgfplots@xmin}{\pgfplots@xmax}%
			\global\let\pgfplots@xmax=\pgfmathresult
		\fi
		\ifpgfplots@clip@limits@y
		\else
			%
			\pgfplotscoordmath{y}{min}{\pgfplots@ymin}{\pgfplots@ymax}%
			\global\let\pgfplots@ymin=\pgfmathresult
			\pgfplotscoordmath{y}{max}{\pgfplots@ymin}{\pgfplots@ymax}%
			\global\let\pgfplots@ymax=\pgfmathresult
			%
		\fi
		\ifpgfplots@clip@limits@z
		\else
			\ifpgfplots@threedim
				\pgfplotscoordmath{z}{min}{\pgfplots@zmin}{\pgfplots@zmax}%
				\global\let\pgfplots@zmin=\pgfmathresult
				\pgfplotscoordmath{z}{max}{\pgfplots@zmin}{\pgfplots@zmax}%
				\global\let\pgfplots@zmax=\pgfmathresult
			\fi
		\fi
	\else
		\pgfplots@handle@invalid@range
	\fi
}%

\def\pgfplotspointcartesian@#1,#2\pgfplots@coord@end{%
	\pgfpointxy@orig{#1}{#2}%
}%
\def\pgfplotscoordmathnotifydatascalesetfor@polar#1{%
	\def\pgfplotscoordmathnotifydatascalesetfor##1{}%
	\edef\pgfplotscoordmathnotifydatascalesetfor@{#1}%
	\def\pgfplotscoordmathnotifydatascalesetfor@@{x}%
	\ifx\pgfplotscoordmathnotifydatascalesetfor@@\pgfplotscoordmathnotifydatascalesetfor@
		\pgfplotscoordmath{#1}{datascaletrafo set params}{0}{0}%
	\else
		\def\pgfplotscoordmathnotifydatascalesetfor@@{y}%
		\ifx\pgfplotscoordmathnotifydatascalesetfor@@\pgfplotscoordmathnotifydatascalesetfor@
			\pgfplotscoordmath{#1}{datascaletrafo set shift}{0}%
		\fi
	\fi
	\let\pgfplotscoordmathnotifydatascalesetfor=\pgfplotscoordmathnotifydatascalesetfor@polar
}%

% #1: the "a" value on the oriented surf
% #2: the "b" value. 
% #3: the shift along the normal.
%
\def\pgfplotspointonorientedsurfaceabwithbshift@polaraxis#1#2#3{%
	% implement the shift in "b" direction explicitly:
	%
	\pgfplotspointonorientedsurfaceab{#1}{#2}%
	\edef\pgfplots@loc@TMPe{\pgf@x=\the\pgf@x\space\pgf@y=\the\pgf@y\space}%
	\pgfpointadd
		{\pgfplots@loc@TMPe}%
		{%
			\begingroup
			% I need a '-' here because for polaraxis axes, the "b" axis
			% points to the *outside* instead of the inside.
			\pgf@xa=-#3\relax
			\if r\pgfkeysvalueof{/pgfplots/\pgfplotspointonorientedsurfaceB\space dir/value}%
				% oh. a reversed axis.
				\pgf@xa=-\pgf@xa
			\fi
			\edef\pgfmathresult{\pgf@sys@tonumber\pgf@xa}%
			\pgfmath@smuggleone\pgfmathresult
			\endgroup
			\let\pgfplots@loc@TMPa=\pgfmathresult
			\pgfqpointscale{\pgfplots@loc@TMPa}{%
				\if x\pgfplotspointonorientedsurfaceB
					% the angle.
					% FIXME : datascaling!
					% FIXME : aspect ratios!
					\pgfmath@basic@sin@{#2}%
					\pgf@x=-\pgfmathresult pt
					\pgfmath@basic@cos@{#2}%
					\pgf@y=\pgfmathresult pt
				\else
					% the length.
					% FIXME : datascaling!
					% FIXME : aspect ratios!
					% perhaps pgfpointpolarxy?
					\if y\pgfplotspointonorientedsurfaceB
                        \if r\pgfkeysvalueof{/pgfplots/\pgfplotspointonorientedsurfaceA\space dir/value}%
                            \pgfqpointpolar{-#1}{-1pt}%
                        \else
                            \pgfqpointpolar{#1}{1pt}%
                        \fi
					\else
						\pgfpointorigin
					\fi
				\fi
			}%
		}%
}


\def\pgfplotsqpointxy@polaraxis#1#2{%
	\pgf@process{%
		\pgfplotsmathpoltocartbasic{#1}{#2}\x\y
		\pgfqpointxy@orig\x\y
%\message{pgfplotsqpointxy{#1}{#2} ---> (\x,\y) ---> (\the\pgf@x,\the\pgf@y)}%
	}%
}%
\def\pgfplots@clippath@prepare@for@axistype@polaraxis{%
	\def\pgfplots@clippath@install##1{%
		\pgfpathmoveto
			{\pgfplotsqpointxy\pgfplots@xmin\pgfplots@ymax}%
		\pgfpatharcaxes{\pgfplots@xmin}{\pgfplots@xmax}
			{\pgfqpointxy@orig{\pgfplots@ymax}{0}}%
			{\pgfqpointxy@orig{0}{\pgfplots@ymax}}%
		\if1\pgfplots@xtick@disable@last@tick
			% we have min angle = max angle.
			\ifdim\pgfplots@ymin pt=0pt
			\else
				\pgfseteorule
				\pgfpathmoveto
					{\pgfplotsqpointxy\pgfplots@xmin\pgfplots@ymin}%
				\pgfpatharcaxes{\pgfplots@xmin}{\pgfplots@xmax}
					{\pgfqpointxy@orig{\pgfplots@ymin}{0}}%
					{\pgfqpointxy@orig{0}{\pgfplots@ymin}}%
			\fi
		\else
			% we have min angle != max angle.
			\ifdim\pgfplots@ymin pt=0pt
				% Ok, then pass through origin:
				\pgfpathlineto\pgfplotspointaxisorigin
			\else
				% complicated special case.
				\pgfpathlineto
					{\pgfplotsqpointxy\pgfplots@xmax\pgfplots@ymin}%
				\pgfpatharcaxes{\pgfplots@xmax}{\pgfplots@xmin}
					{\pgfqpointxy@orig{\pgfplots@ymin}{0}}%
					{\pgfqpointxy@orig{0}{\pgfplots@ymin}}%
			\fi
			\pgfpathclose
		\fi
		\pgfplots@clippath@use@{##1}%
	}%
}%

\def\pgfplotspointouternormalvectorofaxis@polaraxis#1#2#3\relax{%
	\if v#1%
		% ah, we want to find the outer normal for an ANGLE.
		%
		% That's tricky because we need the current value! What if we
		% do not have one?
		\pgfplotspointouternormalvectorofaxisgetv{#1#2#3}%
		% in direction of the length.
		\ifx\pgfplotsretval\pgfutil@empty
			\pgfplotswarning{missing near ticklabel at}{}\pgfeov% 
			% oh, what a mess. We do not know the angle! 
			% this means the alignment will be wrong (most likely...)
			\def\pgfplotsretval{0}%
		\fi
		% FIXME : datascaling!
		% FIXME : aspect ratios!
		% perhaps pgfpointpolarxy?
		\if r\pgfkeysvalueof{/pgfplots/x dir/value}%
			\pgfqpointpolar{-\pgfplotsretval}{-1pt}%
		\else
			\pgfqpointpolar{\pgfplotsretval}{1pt}%
		\fi
	\else
		\if v#2%
			\if#10%
				\def\pgfplotsretval{\pgfplots@xmin}%
			\else
				\def\pgfplotsretval{\pgfplots@xmax}%
			\fi
			% in direction of the angle.
			% FIXME : datascaling!
			% FIXME : aspect ratios!
			\pgfmath@basic@sin@{\pgfplotsretval}%
			\pgf@x=-\pgfmathresult pt
			\pgfmath@basic@cos@{\pgfplotsretval}%
			\pgf@y=\pgfmathresult pt
		\else
			\pgfqpoint{0pt}{1pt}%
		\fi
	\fi
	%\pgf@process{\pgfpointnormalised{}}%
	\pgf@process{}%
	\endgroup
}%

\def\pgfplotspoint@initialisation@axes@polar{%
	%
	\begingroup
	\pgfplotsqpointxy{\pgfplots@xmin}{\pgfplots@ymin}%
	\xdef\pgfplotspointminminmin{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
	%
	\pgfplotsqpointxy{\pgfplots@xmax}{\pgfplots@ymax}%
	\xdef\pgfplotspointxaxis{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
	%
	% the length of the "angle" axis is 2*pi*r .
	% The radius, however, is the length of (0,ymax) which is (0pt,\pgf@xx*ymax):
	\pgfmath@basic@multiply@{\pgf@sys@tonumber\pgf@xx}{\pgfplots@ymax}%
	\pgfmathmultiply@{\pgfmathresult}{6.28318530717959}% 2*pi * r
	\if0\pgfplots@xtick@disable@last@tick
		% oh: minangle != maxangle. We have a partial circle. 
		% compute the arc length (<360 deg)
		\pgf@xa=\pgfplots@xmax pt
		\advance\pgf@xa by-\pgfplots@xmin pt
		\divide\pgf@xa by360
		\ifdim\pgf@xa<1pt
			\edef\pgfplots@loc@TMPa{\pgf@sys@tonumber\pgf@xa}%
			\pgfmathmultiply@{\pgfmathresult}{\pgfplots@loc@TMPa}%
		\fi
	\fi
	\xdef\pgfplotspointxaxislength{\pgfmathresult pt}%
	%
	\pgfpointdiff
		{\pgfplotsqpointxy{\pgfplots@xmax}{\pgfplots@ymin}}%
		{\pgfplotsqpointxy{\pgfplots@xmax}{\pgfplots@ymax}}%
	\xdef\pgfplotspointyaxis{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
	\pgfmathveclen{\pgf@x}{\pgf@y}%
	\xdef\pgfplotspointyaxislength{\pgfmathresult pt}%
	%
	\global\let\pgfplotspointzaxis=\pgfpointorigin
	\gdef\pgfplotspointzaxislength{0pt}%
	\endgroup
	%
}
\let\pgfplotspoint@initialisation@units@orig=\pgfplotspoint@initialisation@units
\def\pgfplotspoint@initialisation@units@polar{%
	\def\pgfplotspointunitx{%
		\pgfplotspointouternormalvectorofaxisgetv{v10}% angle varying, radius at outer pos
		\ifx\pgfplotsretval\pgfutil@empty
			\def\pgfplotsretval{0}%
		\fi
		\if r\pgfkeysvalueof{/pgfplots/x dir/value}%
			\edef\pgfplotsretval{-\pgfplotsretval}%
		\fi
		\pgfmath@basic@sin@{\pgfplotsretval}%
		\pgf@x=-\pgfmathresult pt
		\pgfmath@basic@cos@{\pgfplotsretval}%
		\pgf@y=\pgfmathresult pt
	}%
	\def\pgfplotsunitxlength{1}%
	\def\pgfplotsunitxinvlength{1}%
	%
	\def\pgfplotspointunity{%
		% FIXME : what about 'x dir=reverse' !?
		\pgfqpointpolar{\pgfplots@xmin}{1pt}%
	}%
	\def\pgfplotsunitylength{1}%
	\def\pgfplotsunityinvlength{1}%
}%

\def\pgfplots@transformshift@along@outer@normal@on@line@of@oriented@surf@polar#1#2{%
	\if v#1%
		\let\pgfplots@loc@TMPa=\pgfplotspointonorientedsurfaceA%
		\if v#2%
			\pgfplots@error{Exactly one of '#1' or '#2' must be 'v', not both}%
		\fi
	\else
		\if v#2%
			\let\pgfplots@loc@TMPa=\pgfplotspointonorientedsurfaceB%
		\else
			\pgfplots@error{One of '#1' or '#2' must be 'v'}%
		\fi
	\fi
	%
	\if x\pgfplots@loc@TMPa
	\else
		\pgfplots@transformshift@along@outer@normal@on@line@of@oriented@surf@orig{#1}{#2}%
	\fi
}%
\def\pgfplots@drawgridlines@onorientedsurf@fromto@polar#1{%
	\if x\pgfplotspointonorientedsurfaceA
		\pgfpathmoveto{\pgfplotspointonorientedsurfaceab{#1}{\csname pgfplots@\pgfplotspointonorientedsurfaceB min\endcsname}}%
		\pgfpathlineto{\pgfplotspointonorientedsurfaceab{#1}{\csname pgfplots@\pgfplotspointonorientedsurfaceB max\endcsname}}%
	\else
		\if y\pgfplotspointonorientedsurfaceA\relax
			\pgfpathmoveto{\pgfplotspointonorientedsurfaceab{#1}{\csname pgfplots@\pgfplotspointonorientedsurfaceB min\endcsname}}%
			\pgf@x=#1\pgf@xx
			\pgf@y=#1\pgf@yy
			\edef\pgfplots@loc@TMPa{\the\pgf@x\space and \the\pgf@y}%
			\def\pgfplots@loc@TMPb{\pgfpatharc{\pgfplots@xmin}{\pgfplots@xmax}}%
			\expandafter\pgfplots@loc@TMPb\expandafter{\pgfplots@loc@TMPa}%
		\else
		\fi
	\fi
}%

\let\pgfplots@initsizes@original=\pgfplots@initsizes

\def\pgfplots@initsizes@polar{%
	% I copy-pasted most of this code, up to just one position where
	% I introduced the modified scaling for polar axes
	%----------------------------------
	% INIT.
	%
	%
	\pgfmath@basic@mod@{\pgfplots@xmin}{360}%
	\let\pgfplots@xmin@mod=\pgfmathresult
	\pgfmath@basic@mod@{\pgfplots@xmax}{360}%
	\let\pgfplots@xmax@mod=\pgfmathresult
	\ifdim\pgfplots@xmax@mod pt>\pgfplots@xmin@mod pt
		\def\b@pgfplots@polar@limit@around@zero{0}%
	\else
		\def\b@pgfplots@polar@limit@around@zero{1}%
	\fi
	%
	\pgfplots@initsizes@original
}%

\def\pgfplots@BB@for@plotbox@get@unit@scales@for@limits@polar#1#2#3{%
	% #1 is the angle ... and that does not need to be squeezed into
	% the box.
	%
	% use only y (the radius).
	\if1\b@pgfplots@plotbox@yisunit
		% we do not need to compute max-min as for standard axes (because the inner part
		% characterized by ymin does not enter the scaling).
		%
		% However, we have to keep in mind that our range is TWICE as
		% large because [0,ymax] is just a radius, and we have to
		% scale for the diameter.
		\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{parsenumber}{2}%
		\let\pgfplots@loc@TMPa=\pgfmathresult
		%
		\let\pgfmathresult=\pgfplots@ymax
		\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{parsenumber}{\pgfmathresult}%
		\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{op}{multiply}{{\pgfmathresult}{\pgfplots@loc@TMPa}}%
		\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{tofixed}{\pgfmathresult}%
	\else
		\def\pgfmathresult{2}% not 1: the factor 2 is for 2*radius
	\fi
	\let#1=\pgfmathresult
	\let#2=\pgfmathresult
	\def#3{1}% FIXME : z ?
}%

\def\pgfplots@handle@invalid@range@defaultlimits@polar{%
	\def\pgfplots@loc@TMPa{0}%
	\ifx\pgfplots@xmin\pgfplots@invalidrange@xmin
		\def\pgfplots@loc@TMPa{1}%
	\fi
	\ifx\pgfplots@xmax\pgfplots@invalidrange@xmax
		\def\pgfplots@loc@TMPa{1}%
	\fi
	\if\pgfplots@loc@TMPa1%
		\pgfplotscoordmath{x}{parsenumber}{0}%
		\global\let\pgfplots@xmin=\pgfmathresult
		\pgfplotscoordmath{x}{parsenumber}{360}%
		\global\let\pgfplots@xmax=\pgfmathresult
		\global\let\pgfplots@data@xmin=\pgfplots@xmin
		\global\let\pgfplots@data@xmax=\pgfplots@xmax
	\fi
	%
	\pgfplotscoordmath{y}{parsenumber}{0}%
	\global\let\pgfplots@ymin=\pgfmathresult
	\pgfplotscoordmath{y}{parsenumber}{1}%
	\global\let\pgfplots@ymax=\pgfmathresult
	\global\let\pgfplots@data@ymin=\pgfplots@ymin
	\global\let\pgfplots@data@ymax=\pgfplots@ymax
}

\let\pgfplots@show@ticklabel@@orig=\pgfplots@show@ticklabel@
\def\pgfplots@show@ticklabel@@polar#1#2{%
	\def\pgfmathresult{#2}%
	\if#1x%
		\ifdim#2pt>360pt
			\pgfmath@basic@mod@{#2}{360}%
		\fi
	\fi
	\def\pgfplots@loc@TMPa{\pgfplots@show@ticklabel@@orig{#1}}%
	\expandafter\pgfplots@loc@TMPa\expandafter{\pgfmathresult}%
}%

\let\pgfplots@xtick@check@tickshow@orig=\pgfplots@xtick@check@tickshow%
\def\pgfplots@xtick@check@tickshow@polar{%
	\if1\pgfplots@xtick@disable@last@tick
		\pgfplotsmath@ifapproxequal@dim
			{\pgfplots@tmpa}{\pgfplots@xmax pt}
			{\pgfplots@loc@tick@placement@tolerance}
			{%
				\pgfplots@tickshowfalse
			}{%
				\pgfplots@xtick@check@tickshow@orig
			}%
	\else
		\pgfplots@xtick@check@tickshow@orig
	\fi
}

\let\pgfplots@enlarge@limit@for@orig=\pgfplots@enlarge@limit@for
\def\pgfplots@enlarge@limit@for@polar#1{%
	\if#1x%
		% ignore 'enlarge x limits' (degrees).
	\else
		% allow 'enlarge y limits', but only for UPPER radius
		\def\bool@pgfplots@loc@enlargelimits@min{0}%
		\pgfplots@enlarge@limit@for@orig{#1}%
	\fi
}%

\let\pgfplots@assign@default@tick@foraxis@normalizetickdist@orig=\pgfplots@assign@default@tick@foraxis@normalizetickdist
\def\pgfplots@assign@default@tick@foraxis@normalizetickdist@polar#1#2{%
	\if#1x%
		% special handling for the angles:
		\begingroup
		\pgfmathfloattofixed{#2}%
		\let\H=\pgf@xb
		\H=\pgfmathresult pt
		% only allow step sizes of
		% 90, 45, 30, 15, 10, 5.
		%
		% Prefer the LARGER step size during the snap-to-nearest.
		% The following decision boundaries are heuristics and have no
		% mathematical foundation.
		\ifdim\H>67pt
			\H=90pt
		\else
			\ifdim\H>30pt
				\H=45pt
			\else
				\ifdim\H>18pt
					\H=30pt
				\else
					\ifdim\H>10pt
						\H=15pt
					\else
						\ifdim\H>6pt
							\H=10pt
						\else
							\H=5pt
						\fi
					\fi
				\fi
			\fi
		\fi
		\edef\pgfplots@loc@TMPa{\pgf@sys@tonumber\H}%
		\pgfmathfloatparsenumber{\pgfplots@loc@TMPa}%
		\pgfmath@smuggleone\pgfmathresult
		\endgroup
	\else
		\pgfplots@assign@default@tick@foraxis@normalizetickdist@orig{#1}{#2}%
	\fi
}%

\let\pgfplots@limits@ready@orig=\pgfplots@limits@ready
\def\pgfplots@limits@ready@polar{%
	\pgfplots@limits@ready@orig
	%
	% Avoid tick labels at upper *and* lower angle range if both are the
	% same:
	\pgfmath@basic@subtract@{\pgfplots@xmax}{\pgfplots@xmin}%
	\pgfmath@basic@mod@{\pgfmathresult}{360}%
	\pgfplotsmath@ifapproxequal@dim
		{\pgfmathresult pt}{0pt}%
		{0.002pt}
		{%
			\def\pgfplots@xtick@disable@last@tick{1}%
		}{%
		}%
	%
}%
\endinput
