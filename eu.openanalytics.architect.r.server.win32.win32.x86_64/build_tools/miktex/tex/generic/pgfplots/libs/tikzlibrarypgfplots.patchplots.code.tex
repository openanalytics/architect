%--------------------------------------------
%
% Package pgfplots, library for higher order patch plots.
% It contains advanced patch plots like quadratic triangles,
% biquadratic quadrilaterals, coons patches and others.
% The basic implementation for patches supports already line, triangle
% and rectangle (=2 triangles) patches.
%
% Copyright 2007/2008/2009 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

	% NOTES:
	% In general, a Bezier spline C:[0,1] -> \R of order n fulfills
	% C'(0) = n ( P_1 - P_0 ),
	% C'(1) = n ( P_n - P_{n-1} ).
	% For n=3 and given P_0 and P_3, I can directly compute P_1 and P_2 once I know
	% the derivatives at t=0 and t=1.
	%
	%
	%
%--------------------------------------------------
% 4-point Lagrange interpolation on {0,1/3,2/3,1}:
% C(x) =
% a * (1/3 - x)/(1/3) * (2/3-x)/(2/3) * (1-x) +
% b * (0   - x)/(0 - 1/3) * (2/3-x)/(2/3-1/3)  * (1-x)/(1-1/3) +
% c * (0   - x)/(0 - 2/3) * (1/3-x)/(1/3-2/3) *  (1-x)/(1-2/3) +
% d * (0   - x)/(0 - 1)   * (1/3-x)/(1/3-1)   *  (2/3-x) /(2/3-1)
%
%
% Derivative:
%
% (-9*c + 2*d + 72*c*x - 18*d*x - 81*c*x^2 + 27*d*x^2 +
%   a*(-11 + 36*x - 27*x^2) + 9*b*(2 - 10*x + 9*x^2))/2
%
% bezier control points are
% P1 = (-5*a)/6 + 3*b - (3*c)/2 + d/3
% 	=  -0.833333 a + 3. b - 1.5 c + 0.333333 d
%
% P2 =  0.333333 (0.5 (2. a - 9. b + 18. c - 11. d) + 3. d)
%   =  0.333333 a - 1.5 b + 3. c - 0.833333 d
%--------------------------------------------------



% A quadratic spline in the ordering
%
% <left> <right> <middle>
%
% where <left> is the function value at the left end of the spline
% segmment, <right> the function value at the right end, and <middle>
% the function value in the middle of the spline segment.
\pgfplotsdeclarepatchclass{quadratic spline}{%
	get dimension=\def\pgfplotsretval{1},
	supports global path=\def\pgfplotsretval{1},
	new=\def\pgfplotspatchclass@qspline@no{A},
	set next vertex={%
		% EXPECTED ORDERING: first 2 corners, then 1 mid nodes
		% (interpolatory).
		% defines \pgfplotspatchclass@qspline@A ... \pgfplotspatchclass@qspline@C (3 points)
		\expandafter\edef\csname pgfplotspatchclass@qspline@\pgfplotspatchclass@qspline@no\endcsname{#1}%
		\if C\pgfplotspatchclass@qspline@no
			\def\pgfplotspatchclass@qspline@no{A}%
			\pgfplotspatchready
		\else
			\expandafter\let\expandafter\pgfplotspatchclass@qspline@no\csname pgfpptchindexnext@\pgfplotspatchclass@qspline@no\endcsname
		\fi
	},
	if current point can be first last={%
		\pgfplots@loc@tmptrue
		\if A\pgfplotspatchclass@qspline@no
			% Ah - the current point is the 'C' point, i.e. the
			% control point (we have advanced the '@no' counter)
			\pgfplots@loc@tmpfalse
		\fi
		\ifpgfplots@loc@tmp
			#1\relax%
		\else
			#2\relax
		\fi
	},
	sample in unit cube={%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{0.5}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\pgfplotspatchready
	},%
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qspline@A\endvertex,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qspline@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qspline@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qspline@C\endvertex #1%
	},
	fill path={%
		\begingroup
		% Draw the patch boundary using a bezier curves.
		%
		% Since I have lagrange points to describe the patch (i.e.
		% points the patch passes through), I have to convert the
		% lagrange representation to bezier.
		%
		% Furthermore, I convert to *cubic* bezier since pdf only
		% supports cubic curves.
		%
		% See the docs for 'biquadratic::fill path' for more details,
		% in does the same.
		\def\pgfplots@edge{%
			\ifx\pgfplotspatchclass@qspline@A\PA
				\pgfplotsplothandlermesh@pathmoveto{\expandafter\pgfplotspointpatchvertex\PA\endvertex}%
			\fi
			\pgfpathcurveto	{%
				\pgfpointadd
					{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
					{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PC\endvertex}}%
			}{%
				\pgfpointadd
					{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
					{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PA\endvertex}}%
			}{%
				\expandafter\pgfplotspointpatchvertex\PC\endvertex
			}%
		}%
		\let\PA=\pgfplotspatchclass@qspline@A
		\let\PB=\pgfplotspatchclass@qspline@C
		\let\PC=\pgfplotspatchclass@qspline@B
		\pgfplots@edge
		\pgfplotsplothandlermesh@setlastpoint{\expandafter\pgfplotspointpatchvertex\PC\endvertex}%
		\endgroup
	},
	triangulate class=\def\pgfplotsretval{line},
	triangulate={%
		\let\pgfplotsplothandlermesh@patchclass@=\pgfplotsplothandlermesh@patchclass
		\def\pgfplotsplothandlermesh@patchclass{line}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{new}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@B}%
		\let\pgfplotsplothandlermesh@patchclass=\pgfplotsplothandlermesh@patchclass@
	},%
	recursive refine@={%
		\pgfplotspatchclass{\pgfplotspatchclassname}{new}%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qspline@A\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qspline@B\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qspline@C\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qspline@AC
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@AC}%
		#1%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qspline@A\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qspline@B\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qspline@C\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qspline@CB
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@B}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qspline@CB}%
		#1%
		%
	},%
	get pdf shading type=0,
	get num vertices=\def\pgfplotsretval{3},
}%

\pgfplotsdeclarepatchclass{cubic spline}{%
	get dimension=\def\pgfplotsretval{1},
	supports global path=\def\pgfplotsretval{1},
	new=\def\pgfplotspatchclass@cspline@no{A},
	set next vertex={%
		% EXPECTED ORDERING: first 2 corners, then 1 mid nodes
		% (interpolatory).
		% defines \pgfplotspatchclass@cspline@A ... \pgfplotspatchclass@cspline@D (4 points)
		\expandafter\edef\csname pgfplotspatchclass@cspline@\pgfplotspatchclass@cspline@no\endcsname{#1}%
		\if D\pgfplotspatchclass@cspline@no
			\def\pgfplotspatchclass@cspline@no{A}%
			\pgfplotspatchready
		\else
			\expandafter\let\expandafter\pgfplotspatchclass@cspline@no\csname pgfpptchindexnext@\pgfplotspatchclass@cspline@no\endcsname
		\fi
	},
	if current point can be first last={%
		\pgfplots@loc@tmpfalse
		\if B\pgfplotspatchclass@cspline@no
			% Ah - the current point is the 'A' point (we have
			% advanced the '@no' counter)
			\pgfplots@loc@tmptrue
		\fi
		\if C\pgfplotspatchclass@cspline@no
			% Ah - the current point is the 'B' point (we have
			% advanced the '@no' counter)
			\pgfplots@loc@tmptrue
		\fi
		\ifpgfplots@loc@tmp
			#1\relax%
		\else
			#2\relax
		\fi
	},
	sample in unit cube={%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{0.3333333}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{0.6666666}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\pgfplotspatchready
	},%
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@A\endvertex,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@C\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@D\endvertex #1%
	},
	fill path={%
		% Draw the patch boundary using a bezier curve.
		\pgfplotsplothandlermesh@pathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@cspline@A\endvertex}%
		\pgfplotspathcubicfrominterpolation
			{\pgfplotspatchclass@cspline@A}%
			{\pgfplotspatchclass@cspline@C}%
			{\pgfplotspatchclass@cspline@D}%
			{\pgfplotspatchclass@cspline@B}%
		\pgfplotsplothandlermesh@setlastpoint{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@cspline@B\endvertex}%
	},
	triangulate class=\def\pgfplotsretval{line},
	triangulate={%
		\let\pgfplotsplothandlermesh@patchclass@=\pgfplotsplothandlermesh@patchclass
		\def\pgfplotsplothandlermesh@patchclass{line}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{new}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@B}%
		\let\pgfplotsplothandlermesh@patchclass=\pgfplotsplothandlermesh@patchclass@
	},%
	recursive refine@={%
		% The 4-point lagrangian interpolation formular is shown on
		% the top of this page. What I do here is simply to evaluate
		% C(i*1/9) for i =0,...,9:
		% 0
		% 0.493827 A +0.740741 C -0.296296 D +0.0617284 B
		% 0.17284 A +1.03704 C -0.259259 D +0.0493827 B
		% 1/3
		% -0.0617284 A +0.740741 C +0.37037 D -0.0493827 B
		% -0.0493827 A +0.37037 C +0.740741 D -0.0617284 B
		% 2/3
		% 0.0493827 A -0.259259 C +1.03704 D +0.17284 B
		% 0.0617284 A -0.296296 C +0.740741 D +0.493827 B
		% 1
		\pgfplotspatchclass{\pgfplotspatchclassname}{new}%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@A\times{0.493827}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@B\times{0.0617284}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@C\times{0.740741}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@D\times{-0.296296}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@cspline@AA
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@A\times{0.17284}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@B\times{0.0493827}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@C\times{1.03704}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@D\times{-0.259259}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@cspline@AB
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@AA}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@AB}%
		#1%
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@A\times{-0.0617284}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@B\times{-0.0493827}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@C\times{0.740741}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@D\times{0.37037}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@cspline@AA
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@A\times{-0.0493827}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@B\times{-0.0617284}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@C\times{0.37037}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@D\times{0.740741}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@cspline@AB
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@AA}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@AB}%
		#1%
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@A\times{0.0493827}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@B\times{0.17284}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@C\times{-0.259259}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@D\times{+1.03704}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@cspline@AA
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@A\times{0.0617284}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@B\times{0.493827}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@C\times{-0.296296}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@cspline@D\times{0.740741}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@cspline@AB
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@B}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@AA}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@AB}%
		#1%
	},
	get pdf shading type=0,
	get num vertices=\def\pgfplotsretval{4},
}%

\def\pgfplotspathcubicfrominterpolation#1#2#3#4{%
	% switch basis from lagrange to bezier (see formular on top of
	% this file)
	\pgfpathcurveto	{%
		\begingroup
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexaddXY#1\times{-0.833333}%
		\expandafter\pgfplotspatchvertexaddXY#2\times{3}%
		\expandafter\pgfplotspatchvertexaddXY#3\times{-1.5}%
		\expandafter\pgfplotspatchvertexaddXY#4\times{0.3333333}%
		\pgfplotspatchvertexfinish\pgfplots@loc@TMPa
		\expandafter\pgfplotspointpatchvertex\pgfplots@loc@TMPa\endvertex
		\endgroup
	}{%
		\begingroup
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexaddXY#1\times{0.333333}%
		\expandafter\pgfplotspatchvertexaddXY#2\times{-1.5}%
		\expandafter\pgfplotspatchvertexaddXY#3\times{3}%
		\expandafter\pgfplotspatchvertexaddXY#4\times{-0.833333}%
		\pgfplotspatchvertexfinish\pgfplots@loc@TMPa
		\expandafter\pgfplotspointpatchvertex\pgfplots@loc@TMPa\endvertex
		\endgroup
	}{%
		\expandafter\pgfplotspointpatchvertex#4\endvertex
	}%
}%

% This is JUST a curveto operation! Nothing special.
\pgfplotsdeclarepatchclass{bezier spline}{%
	get dimension=\def\pgfplotsretval{1},
	supports global path=\def\pgfplotsretval{1},
	new=\def\pgfplotspatchclass@cspline@no{A},
	set next vertex={%
		% EXPECTED ORDERING: first 2 corners, then 2 control points
		% (NOT interpolatory).
		% defines \pgfplotspatchclass@cspline@A ... \pgfplotspatchclass@cspline@D (4 points)
		\expandafter\edef\csname pgfplotspatchclass@cspline@\pgfplotspatchclass@cspline@no\endcsname{#1}%
		\if D\pgfplotspatchclass@cspline@no
			\def\pgfplotspatchclass@cspline@no{A}%
			\pgfplotspatchready
		\else
			\expandafter\let\expandafter\pgfplotspatchclass@cspline@no\csname pgfpptchindexnext@\pgfplotspatchclass@cspline@no\endcsname
		\fi
	},
	if current point can be first last={%
		\pgfplots@loc@tmpfalse
		\if B\pgfplotspatchclass@cspline@no
			% Ah - the current point is the 'A' point (we have
			% advanced the '@no' counter)
			\pgfplots@loc@tmptrue
		\fi
		\if C\pgfplotspatchclass@cspline@no
			% Ah - the current point is the 'B' point (we have
			% advanced the '@no' counter)
			\pgfplots@loc@tmptrue
		\fi
		\ifpgfplots@loc@tmp
			#1\relax%
		\else
			#2\relax
		\fi
	},
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@A\endvertex,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@C\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@cspline@D\endvertex #1%
	},
	fill path={%
		% Draw the patch boundary using a bezier curve.
		\pgfplotsplothandlermesh@pathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@cspline@A\endvertex}%
		\pgfpathcurveto	{
			\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@cspline@C\endvertex
		}{
			\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@cspline@D\endvertex
		}{%
			\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@cspline@B\endvertex
		}%
		\pgfplotsplothandlermesh@setlastpoint{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@cspline@B\endvertex}%
	},
	triangulate class=\def\pgfplotsretval{line},
	triangulate={%
		\let\pgfplotsplothandlermesh@patchclass@=\pgfplotsplothandlermesh@patchclass
		\def\pgfplotsplothandlermesh@patchclass{line}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{new}%
		% XXX : very poor quality ...
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@cspline@B}%
		\let\pgfplotsplothandlermesh@patchclass=\pgfplotsplothandlermesh@patchclass@
	},%
	get pdf shading type=0,
	get num vertices=\def\pgfplotsretval{4},
}%



% make a linearized sequence around the edge of the quad.triangle.
% note the ordering: first 3 corners, then 3 mid nodes:
\def\pgfplots@qtri@next@A{D}%
\def\pgfplots@qtri@next@B{E}%
\def\pgfplots@qtri@next@C{F}%
\def\pgfplots@qtri@next@D{B}%
\def\pgfplots@qtri@next@E{C}%
\def\pgfplots@qtri@next@F{A}%

\def\pgfplots@qtri@rnext@A{F}%
\def\pgfplots@qtri@rnext@B{D}%
\def\pgfplots@qtri@rnext@C{E}%
\def\pgfplots@qtri@rnext@D{A}%
\def\pgfplots@qtri@rnext@E{B}%
\def\pgfplots@qtri@rnext@F{C}%

\def\pgfplotspatchclass@qtri@recursiverefine@newnames{%
	\let\pgfplotspatchclass@qtri@A@=\pgfplotspatchclass@qtri@A%
	\let\pgfplotspatchclass@qtri@B@=\pgfplotspatchclass@qtri@B%
	\let\pgfplotspatchclass@qtri@C@=\pgfplotspatchclass@qtri@C%
	\let\pgfplotspatchclass@qtri@D@=\pgfplotspatchclass@qtri@D%
	\let\pgfplotspatchclass@qtri@E@=\pgfplotspatchclass@qtri@E%
	\let\pgfplotspatchclass@qtri@F@=\pgfplotspatchclass@qtri@F%
}%


% A 3-point interpolatory patch which draws quadratic polynomial
% splines (functions f(x), x 1d).
\pgfplotsdeclarepatchclass{triangle quadr}{%
	uses view depth=\def\pgfplotsretval{1},% used by the shader: we reorder corners.
	new=\def\pgfplotspatchclass@qtri@no{A}\let\pgfplotspatchclass@qtrie@AB\relax,
	set next vertex={%
		% EXPECTED ORDERING: first 3 corners, then 3 mid nodes.
		% defines \pgfplotspatchclass@qtri@A ... \pgfplotspatchclass@qtri@F (6 points)
		\expandafter\edef\csname pgfplotspatchclass@qtri@\pgfplotspatchclass@qtri@no\endcsname{#1}%
		\if F\pgfplotspatchclass@qtri@no
			\def\pgfplotspatchclass@qtri@no{A}%
			\pgfplotspatchready
		\else
			\expandafter\let\expandafter\pgfplotspatchclass@qtri@no\csname pgfpptchindexnext@\pgfplotspatchclass@qtri@no\endcsname
		\fi
	},
	sample in unit cube={%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{1}%
		#1%
		%
		\def\pgfplotspatchclassx{0.5}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{0.5}%
		\def\pgfplotspatchclassy{0.5}%
		#1%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0.5}%
		#1%
		\pgfplotspatchready
		%
		%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{1}%
		#1%
		%
		\def\pgfplotspatchclassx{0.5}%
		\def\pgfplotspatchclassy{0.5}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0.5}%
		#1%
		\def\pgfplotspatchclassx{0.5}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\pgfplotspatchready
	},%
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@A\endvertex,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@C\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@D\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@E\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@F\endvertex #1%
	},
	foreach cdata vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@C\endvertex #1%
	},
	fill path={%
		\begingroup
		% Draw the patch boundary using three bezier curves.
		%
		% Since I have lagrange points to describe the patch (i.e.
		% points the patch passes through), I have to convert the
		% lagrange representation to bezier.
		%
		% Furthermore, I convert to *cubic* bezier since pdf only
		% supports cubic curves.
		%
		% See the docs for 'biquadratic::fill path' for more details,
		% in does the same.
		\def\pgfplots@edge{%
			\ifx\pgfplotspatchclass@qtri@A\PA
				\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\PA\endvertex}%
			\fi
			\pgfpathcurveto	{%
				\pgfpointadd
					{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
					{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PC\endvertex}}%
			}{%
				\pgfpointadd
					{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
					{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PA\endvertex}}%
			}{%
				\expandafter\pgfplotspointpatchvertex\PC\endvertex
			}%
		}%
		\let\PA=\pgfplotspatchclass@qtri@A
		\let\PB=\pgfplotspatchclass@qtri@D
		\let\PC=\pgfplotspatchclass@qtri@B
		\pgfplots@edge
		%
		\let\PA=\pgfplotspatchclass@qtri@B
		\let\PB=\pgfplotspatchclass@qtri@E
		\let\PC=\pgfplotspatchclass@qtri@C
		\pgfplots@edge
		%
		\let\PA=\pgfplotspatchclass@qtri@C
		\let\PB=\pgfplotspatchclass@qtri@F
		\let\PC=\pgfplotspatchclass@qtri@A
		\pgfplots@edge
		\endgroup
		\pgfpathclose
	},
	%--------------------------------------------------
	% stroke path={%
	% 	\ifx\pgfplotspatchclass@qtrie@AB\relax
	% 		\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@A\endvertex}%
	% 		\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@B\endvertex}%
	% 		\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@C\endvertex}%
	% 		\pgfpathclose
	% 	\else
	% 		\if1\pgfplotspatchclass@qtrie@AB
	% 			\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@A\endvertex}%
	% 			\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@B\endvertex}%
	% 		\fi
	% 		\if1\pgfplotspatchclass@qtrie@BC
	% 			\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@B\endvertex}%
	% 			\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@C\endvertex}%
	% 		\fi
	% 		\if1\pgfplotspatchclass@qtrie@CA
	% 			\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@C\endvertex}%
	% 			\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@qtri@A\endvertex}%
	% 		\fi
	% 	\fi
	% },
	%--------------------------------------------------
	stream to shader={%
		% create a degenerate coons patch:
		\begingroup
%\message{EDGE INIT^^J}%
		% this defines \Pcur and \Pnextseq :
		\pgfplotspatchclass@tri@to@coonspatch@findshadingsequence@for@depth
		%
		\pgfutil@namelet{Pstart}{pgfplotspatchclass@qtri@\Pcur}%
		%
		% see the docus for "fill path" about these 1.33333 and -0.33333 factors
		\def\pgfplots@coonsedge{%
%\message{EDGE \Pcur^^J}%
			\expandafter\let\expandafter\PA\csname pgfplotspatchclass@qtri@\Pcur\endcsname
			\edef\Pcur{\csname pgfplots@qtri@\Pnextseq next@\Pcur\endcsname}%
%\message{---> \Pcur^^J}%
			\expandafter\let\expandafter\PB\csname pgfplotspatchclass@qtri@\Pcur\endcsname
			\edef\Pcur{\csname pgfplots@qtri@\Pnextseq next@\Pcur\endcsname}%
%\message{---> \Pcur^^J}%
			\expandafter\let\expandafter\PC\csname pgfplotspatchclass@qtri@\Pcur\endcsname
			\ifx\PA\Pstart
				\expandafter\pgfplotspatchvertex\PA\endvertex
					\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
					\pgfplotsaxisvisphasetransformpointmeta
				\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
				% degenerate: the "edge" \PA -- \PA collabses into one
				% point.
				% Per construction, the "edge" is the FOREGROUND.
%\message{STREAMING COLLAPSED EDGE AT START POINT^^J}%
				\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
				\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
				\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
			\fi
			\pgfplotslibrarysurfstreamcoord{%
				\pgfpointadd
					{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
					{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PC\endvertex}}%
			}{}%
			\pgfplotslibrarysurfstreamcoord{%
				\pgfpointadd
					{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
					{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PA\endvertex}}%
			}{}%
			\ifx\PC\Pstart
			\else
				\expandafter\pgfplotspatchvertex\PC\endvertex
					\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
					\pgfplotsaxisvisphasetransformpointmeta
				\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
			\fi
		}%
		\pgfplots@coonsedge
		%
		\pgfplots@coonsedge
		%
		\pgfplots@coonsedge
		%
		%
		\endgroup
	},%
	triangulate={%
		\let\pgfplotsplothandlermesh@patchclass@=\pgfplotsplothandlermesh@patchclass
		\def\pgfplotsplothandlermesh@patchclass{triangle}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{new}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}01%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}11%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}20%
		% Ok. Now create 4 triangles. The ordering is not arbitrary
		% (unless z buffer=sort is in effect). Let's assume that the
		% AB edge is BACKGROUND and the CD edge is FOREGROUND. Then
		% this sequence here should have approximately the same depth
		% ordering:
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@F}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@D}%
		%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}00%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}10%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@F}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@E}%
		%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}01%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}11%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@B}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@E}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@E}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@F}%
		\let\pgfplotsplothandlermesh@patchclass=\pgfplotsplothandlermesh@patchclass@
	},%
	set edge visible={%
		\ifcase#1
			\edef\pgfplotspatchclass@qtrie@AB{#2}%
		\or
			\edef\pgfplotspatchclass@qtrie@BC{#2}%
		\or
			\edef\pgfplotspatchclass@qtrie@CA{#2}%
		\fi
	},
	serialize except vertices={%
		\ifx\pgfplotspatchclass@qtrie@AB\relax
			\let\pgfplotsretval\pgfutil@empty%
		\else
			\edef\pgfplotsretval{%
				\noexpand\def\noexpand\pgfplotspatchclass@qtrie@AB{\pgfplotspatchclass@qtrie@AB}%
				\noexpand\def\noexpand\pgfplotspatchclass@qtrie@BC{\pgfplotspatchclass@qtrie@BC}%
				\noexpand\def\noexpand\pgfplotspatchclass@qtrie@CA{\pgfplotspatchclass@qtrie@CA}%
			}%
		\fi
	},%
	deserialize except vertices=%
		\let\pgfplotspatchclass@qtrie@AB\relax
		#1,
	recursive refine@={%
		\pgfplotspatchclass@qtri@recursiverefine@newnames
		%
		\pgfplotspatchclass{\pgfplotspatchclassname}{new}%
		%--------------------------------------------------
		% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}01%
		% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}11%
		% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}20%
		%--------------------------------------------------
		% The ordering is not arbitrary
		% (unless z buffer=sort is in effect). Let's assume that the
		% AB edge is BACKGROUND and the CD edge is FOREGROUND. Then
		% this sequence here should have approximately the same depth
		% ordering:
		%
		% I used the reference triangle and shape functions as listed in
		% http://www.colorado.edu/engineering/CAS/courses.d/IFEM.d/
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@A\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@B\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@D\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@AD
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@B\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@C\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@D\times{0.5}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@E\times{0.25}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@F\times{0.5}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@DF
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@A\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@C\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@F\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@AF
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@F@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@A@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@D@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@AF}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@AD}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@DF}%
		%
		#1\pgfplotspatchclass@qtri@recursiverefine@newnames
		%
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@B\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@C\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@D\times{0.5}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@E\times{0.25}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@F\times{0.5}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@DF
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@A\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@C\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@D\times{0.5}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@E\times{0.5}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@F\times{0.25}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@DE
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@A\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@B\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@D\times{0.25}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@E\times{0.5}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@F\times{0.5}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@EF
		%
		%
		%--------------------------------------------------
		% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}00%
		% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}10%
		%--------------------------------------------------
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@F@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@D@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@E@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@DF}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@DE}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@EF}%
		% %
		% %--------------------------------------------------
		% % \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}01%
		% % \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}11%
		% %--------------------------------------------------
		#1\pgfplotspatchclass@qtri@recursiverefine@newnames
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@A\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@B\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@D\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@DB
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@A\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@C\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@D\times{0.5}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@E\times{0.5}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@F\times{0.25}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@DE
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@B\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@C\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@E\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@BE
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@D@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@B@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@E@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@DB}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@BE}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@DE}%
		%
		#1\pgfplotspatchclass@qtri@recursiverefine@newnames
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@B\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@C\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@E\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@EC
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@A\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@B\times{-.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@D\times{0.25}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@E\times{0.5}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@F\times{0.5}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@EF
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@A\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@C\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@qtri@F\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@qtri@CF
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@E@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@C@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@F@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@EC}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@CF}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@qtri@EF}%
		%
		#1%
		%
	},%
	get pdf shading type=6,
	get num vertices=\def\pgfplotsretval{6},
	get num cdata vertices=\def\pgfplotsretval{3},
}%


% see
% \pgfplotspatchclass@rect@to@coonspatch@findshadingsequence@for@depth
% and its documentation.
%
% POSTCONDITION:
% 	\Pcur and \Pnextseq are defined.
\def\pgfplotspatchclass@tri@to@coonspatch@findshadingsequence@for@depth{%
	\def\Pcur{A}%
	\def\Pnextseq{}%
	%
	\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@A\endvertex
	\ifx\pgfplotspatchvertexdepth\pgfutil@empty
	\else
		% ah. We have view depth. Use it!
		% The idea here is as follows.
		% According to pdf standard, the COONS Shading is
		% generated in the unit cube and then mapped to the
		% shading. If u,v in [0,1] are the coordinates in the unit
		% cube, pixel values for v=1 overwrite values for v=0.
		% If pixel values have the same v, u=1 overwrites u=0.
		% In other words, the loop is
		% for v= 0 to Nv
		% 	for u = 0 to Nu
		% 	   shade pixel for (u,v)
		%
		% BB-------CC   <--v=1
		%  |        |
		%  |        |
		%  |        |
		% AA-------DD   <--v=0
		%  |        |
		%  u=0      u=1
		%
		%
		% IDEA: re-order the sequence of vertices such that z
		% buffering is obtained.
		%
		% APPROACH:
		%  the edge BB--CC collapses into just one point, namely
		%  the FOREGROUND point (i.e. it is drawn on top of
		%  everything else).
		%
		%  The AA point is the second nearest foreground point.
		%  The sequence is chosen such that AA,BB is the first
		%  edge.
		%
		%  What is to do (besides determining the vertices for AA
		%  and BB)? Well, make sure, that we can arrange them in
		%  the desired order. This involves a periodic "next vertex"
		%  algorithm which might either go forward
		%  or backward.
		%
		% sort according to depth.
		% To do so, prepare macros \PA,\PB,\PC for use in
		% \pgfplotsutilsortthree. FORMAT:
		% \PA={<sortkey>pt <originalindex>}
		\edef\PA{\pgfplotspatchvertexdepth pt A}%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@B\endvertex
		\edef\PB{\pgfplotspatchvertexdepth pt B}%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@qtri@C\endvertex
		\edef\PC{\pgfplotspatchvertexdepth pt C}%
		\pgfplotsutilsortthree\PA\PB\PC
		\def\toCHAR##1pt ##2{##2}% get original index
		%
		\edef\Pcur{\expandafter\toCHAR\PB}%%
		\edef\Pnext{\csname pgfplots@qtri@next@\Pcur\endcsname}%
		\edef\Pnext{\csname pgfplots@qtri@next@\Pnext\endcsname}%
		\if\Pnext\PA
			% ok, next(next(AA)) = BB.
			% that means we have to advance forward.
			\def\Pnextseq{}%
		\else
			% well, since we have a triangle, there only remains
			% the backwards direction.
			\def\Pnextseq{r}%
		\fi
%\message{FOREGROUND VERTEX = \PA.^^J}%
%\message{SECOND NEAREST VERTEX = \PB.^^J}%
	\fi
}
\def\pgfplotspatchclass@tri@to@coonspatch@findshadingsequence@for@depth@no@op{%
	\def\Pcur{A}%
	\def\Pnextseq{}%
}

% bilinear is the same as 'rectangle', but it uses a different shader.
\pgfplotsdeclarepatchclass{bilinear}{%
	allow matrix=\def\pgfplotsretval{1},
	new=\def\pgfplotspatchclass@rect@no{0},
	set next vertex={%
		\ifcase\pgfplotspatchclass@rect@no\relax
			\edef\pgfplotspatchclass@rect@A{#1}%
			\def\pgfplotspatchclass@rect@no{1}%
		\or
			\edef\pgfplotspatchclass@rect@B{#1}%
			\def\pgfplotspatchclass@rect@no{2}%
		\or
			\edef\pgfplotspatchclass@rect@C{#1}%
			\def\pgfplotspatchclass@rect@no{3}%
		\or
			\edef\pgfplotspatchclass@rect@D{#1}%
			\def\pgfplotspatchclass@rect@no{0}%
			\pgfplotspatchready%
		\fi
	},
	sample in unit cube={%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\pgfplotspatchready
	},%
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@rect@A\endvertex,
	first vertex before z buffer=\pgfplotspatchclass@rect@first@before@z@buffer,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@rect@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@rect@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@rect@C\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@rect@D\endvertex #1%
	},
	stream to shader={%
		% create a coons patch:
		\begingroup
		\pgfplotspatchclass@rect@to@coonspatch@findshadingsequence@for@depth
			{pgfplotspatchclass@rect@}{\Pcur}{\Pnextseq}%
		%
		\pgfutil@namelet{Pstart}{pgfplotspatchclass@rect@\Pcur}%
		\def\pgfplots@coonsedge{%
%\message{EDGE \Pcur^^J}%
			\expandafter\let\expandafter\PA\csname pgfplotspatchclass@rect@\Pcur\endcsname
			\edef\Pcur{\csname pgfplots@rect@\Pnextseq next@\Pcur\endcsname}%
%\message{---> \Pcur^^J}%
			\expandafter\let\expandafter\PB\csname pgfplotspatchclass@rect@\Pcur\endcsname
			\ifx\PA\Pstart
				\expandafter\pgfplotspatchvertex\PA\endvertex
					\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
					\pgfplotsaxisvisphasetransformpointmeta
				\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
			\fi
			%
			% CONTROL POINT A+1/3(B-A)
			\pgfplotslibrarysurfstreamcoord{%
				\pgfpointadd
					{\pgfqpointscale{0.6666666}{\expandafter\pgfplotspointpatchvertex\PA\endvertex}}%
					{\pgfqpointscale{0.3333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
			}{}%
			% CONTROL POINT A+2/3(B-A)
			\pgfplotslibrarysurfstreamcoord{%
				\pgfpointadd
					{\pgfqpointscale{0.3333333}{\expandafter\pgfplotspointpatchvertex\PA\endvertex}}%
					{\pgfqpointscale{0.6666666}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
			}{}%
			\ifx\PB\Pstart
			\else
				\expandafter\pgfplotspatchvertex\PB\endvertex
					\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
					\pgfplotsaxisvisphasetransformpointmeta
				\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
			\fi
		}%
		%
		\pgfplots@coonsedge
		%
		\pgfplots@coonsedge
		%
		\pgfplots@coonsedge
		%
		\pgfplots@coonsedge
		%
		\endgroup
	},%
	fill path={%
		\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@rect@A\endvertex}%
		\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@rect@B\endvertex}%
		\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@rect@C\endvertex}%
		\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@rect@D\endvertex}%
		\pgfpathclose
	},
	triangulate={%
		\pgfplotscoordmath{meta}{parsenumber}{0.25}%
		\let\pgfplots@loc@scale=\pgfmathresult
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@A\endvertex\times{0.25}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@B\endvertex\times{0.25}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@C\endvertex\times{0.25}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@D\endvertex\times{0.25}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@M
		%
		\let\pgfplotsplothandlermesh@patchclass@=\pgfplotsplothandlermesh@patchclass
		\def\pgfplotsplothandlermesh@patchclass{triangle}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{new}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}01%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}10%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}20%
		% Ok. Now create 4 triangles. The ordering is not arbitrary
		% (unless z buffer=sort is in effect). Let's assume that the
		% AB edge is BACKGROUND and the CD edge is FOREGROUND. Then
		% this sequence here should have approximately the same depth
		% ordering:
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@B}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@M}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@B}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@M}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@M}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@M}%
		\let\pgfplotsplothandlermesh@patchclass=\pgfplotsplothandlermesh@patchclass@
	},%
	recursive refine@={%
		\pgfplotspatchclass@rect@refine@{#1}%
	},%
	serialize except vertices=\let\pgfplotsretval\pgfutil@empty,%
	deserialize except vertices=,
	get pdf shading type=6,
	get num vertices=\def\pgfplotsretval{4},
}%

\pgfplotsdeclarepatchclass{rectangle}{%
	recursive refine@={%
		\pgfplotspatchclass@rect@refine@{#1}%
	},%
}
\def\pgfplotspatchclass@rect@refine@#1{%
	\pgfplotspatchclass@rect@recursiverefine@newnames
	%
	\pgfplotspatchclass{\pgfplotspatchclassname}{new}%
	%--------------------------------------------------
	% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}01%
	% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}11%
	% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}20%
	%--------------------------------------------------
	% The ordering is not arbitrary
	% (unless z buffer=sort is in effect). Let's assume that the
	% AB edge is BACKGROUND and the CD edge is FOREGROUND. Then
	% this sequence here should have approximately the same depth
	% ordering:
	%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@A\times{0.25}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@B\times{0.25}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@C\times{0.25}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@D\times{0.25}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@M
	%
	\expandafter\pgfplotspatchclass@rect@refine@@\expandafter{\pgfplotspatchclass@rect@M}{#1}%
}
\def\pgfplotspatchclass@rect@refine@@#1#2{%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@A\times{0.5}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@B\times{0.5}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@AB
	%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@A\times{0.5}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@D\times{0.5}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@DA
	%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@A@}%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@AB}%
	\pgfplotsplothandlermesh@setnextvertex{#1}%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@DA}%
	#2\pgfplotspatchclass@rect@recursiverefine@newnames
	%
	%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@A\times{0.5}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@B\times{0.5}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@AB
	%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@B\times{0.5}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@C\times{0.5}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@BC
	%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@AB}%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@B@}%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@BC}%
	\pgfplotsplothandlermesh@setnextvertex{#1}%
	#2\pgfplotspatchclass@rect@recursiverefine@newnames
	%
	%
	%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@C\times{0.5}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@D\times{0.5}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@CD
	%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@B\times{0.5}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@C\times{0.5}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@BC
	%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@BC}%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@C@}%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@CD}%
	\pgfplotsplothandlermesh@setnextvertex{#1}%
	#2\pgfplotspatchclass@rect@recursiverefine@newnames
	%
	%
	%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@C\times{0.5}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@D\times{0.5}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@CD
	%
	\pgfplotspatchvertexaccumstart
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@D\times{0.5}%
	\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@rect@A\times{0.5}%
	\pgfplotspatchvertexfinish\pgfplotspatchclass@rect@DA
	%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@CD}%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@D@}%
	\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@rect@DA}%
	\pgfplotsplothandlermesh@setnextvertex{#1}%
	#2\pgfplotspatchclass@rect@recursiverefine@newnames
	%
}%

\def\pgfplotspatchclass@rect@recursiverefine@newnames{%
	\let\pgfplotspatchclass@rect@A@=\pgfplotspatchclass@rect@A%
	\let\pgfplotspatchclass@rect@B@=\pgfplotspatchclass@rect@B%
	\let\pgfplotspatchclass@rect@C@=\pgfplotspatchclass@rect@C%
	\let\pgfplotspatchclass@rect@D@=\pgfplotspatchclass@rect@D%
}%


% An arbitrary poligy specified in the sequence
% D <-- C
% |     ^
% v     |
% A --> B
%
\pgfkeyssetvalue{/pgfplots/vertex count}{0}%
\pgfplotsdeclarepatchclass{polygon}{%
	new=\def\pgfplotspatchclass@poly@no{0},
	set next vertex={%
		\pgfplotspatchclass@poly@checkcount
		\expandafter\edef\csname pgfplotspatchclass@poly@\pgfplotspatchclass@poly@no\endcsname{#1}%
		\pgfplotsutil@advancestringcounter\pgfplotspatchclass@poly@no
		\ifnum\pgfplotspatchclass@poly@no=\pgfkeysvalueof{/pgfplots/vertex count} %
			\def\pgfplotspatchclass@poly@no{0}%
			\pgfplotspatchready%
		\fi
	},
	first vertex=\expandafter\expandafter\expandafter\pgfplotspatchvertex\csname pgfplotspatchclass@poly@0\endcsname\endvertex,
	foreach vertex={%
		\pgfplotspatchclass@poly@foreach@loop{0}{#1}%
	},
	init pdf shading={%
		\pgfplots@error{Sorry, patch type=polygon does not support shadings}%
	},
	serialize except vertices=\let\pgfplotsretval\pgfutil@empty,%
	deserialize except vertices=,
	get pdf shading type=4,
	get num vertices=\def\pgfplotsretval{\pgfkeysvalueof{/pgfplots/vertex count}},
}%
\def\pgfplotspatchclass@poly@checkcount{%
	\ifnum\pgfkeysvalueof{/pgfplots/vertex count}>0
	\else
		\pgfplots@error{Sorry, 'patch type=polygon' *requires* that 'vertex count=<num>' is set (note: it is allowed if multiple vertices have the same coordinates).}%
	\fi
}%
\long\def\pgfplotspatchclass@poly@foreach@loop#1#2{%
	\ifnum#1<\pgfkeysvalueof{/pgfplots/vertex count} %
		\expandafter\expandafter\expandafter\pgfplotspatchvertex\csname pgfplotspatchclass@poly@#1\endcsname\endvertex #2%
		\begingroup
		\c@pgf@counta=#1 %
		\advance\c@pgf@counta by1 %
		\t@pgfplots@toka={#2}%
		\xdef\pgfplots@glob@TMPc{\noexpand\pgfplotspatchclass@poly@foreach@loop{\the\c@pgf@counta}{\the\t@pgfplots@toka}}%
		\endgroup
	\else
		\gdef\pgfplots@glob@TMPc{}%
	\fi
	\pgfplots@glob@TMPc
}%

\def\pgfplots@biquad@next@A{E}
\def\pgfplots@biquad@next@B{F}
\def\pgfplots@biquad@next@C{G}
\def\pgfplots@biquad@next@D{H}
\def\pgfplots@biquad@next@E{B}
\def\pgfplots@biquad@next@F{C}
\def\pgfplots@biquad@next@G{D}
\def\pgfplots@biquad@next@H{A}


\def\pgfplots@biquad@rnext@A{H}
\def\pgfplots@biquad@rnext@B{E}
\def\pgfplots@biquad@rnext@C{F}
\def\pgfplots@biquad@rnext@D{G}
\def\pgfplots@biquad@rnext@E{A}
\def\pgfplots@biquad@rnext@F{B}
\def\pgfplots@biquad@rnext@G{C}
\def\pgfplots@biquad@rnext@H{D}

\def\pgfplotspatchclass@biquad@recursiverefine@newnames{%
	\let\pgfplotspatchclass@biquad@A@=\pgfplotspatchclass@biquad@A%
	\let\pgfplotspatchclass@biquad@B@=\pgfplotspatchclass@biquad@B%
	\let\pgfplotspatchclass@biquad@C@=\pgfplotspatchclass@biquad@C%
	\let\pgfplotspatchclass@biquad@D@=\pgfplotspatchclass@biquad@D%
	\let\pgfplotspatchclass@biquad@E@=\pgfplotspatchclass@biquad@E%
	\let\pgfplotspatchclass@biquad@F@=\pgfplotspatchclass@biquad@F%
	\let\pgfplotspatchclass@biquad@G@=\pgfplotspatchclass@biquad@G%
	\let\pgfplotspatchclass@biquad@H@=\pgfplotspatchclass@biquad@H%
	\let\pgfplotspatchclass@biquad@I@=\pgfplotspatchclass@biquad@I%
}%


% mathematica shape functions parameterized in
% (xi,eta) in [-1,1]x[-1,1]:
%f[xi_, eta_] =
%   a*1/4*(1 - xi) (1 - eta) xi*eta +
%    b 1/4 (-1 - xi) (1 - eta) xi*eta +
%   c*  1/4 (-1 - xi) (-1 - eta) xi*eta +
%    d *1/4 (1 - xi) (-1 - eta) xi*eta +
%   e * 1/2 (xi^2 - 1) (1 - eta) eta +
%   f*1/2 (-1 - xi) (eta^2 - 1) xi +
%   g* -1/2 (1 - xi^2) (-1 - eta) eta +
%   h* -1/2 (1 - xi) (1 - eta^2) xi +
%   i*(1 - xi^2) (1 - eta^2)
% here, a,b,...,i are the 9 nodes.
\pgfplotsdeclarepatchclass{biquadratic}{%
	new=\def\pgfplotspatchclass@biquad@no{A}\let\pgfplotspatchclass@biquade@AB\relax,
	set next vertex={%
		% defines \pgfplotspatchclass@biquad@A ... \pgfplotspatchclass@biquad@I (9 points)
		\expandafter\edef\csname pgfplotspatchclass@biquad@\pgfplotspatchclass@biquad@no\endcsname{#1}%
		\if I\pgfplotspatchclass@biquad@no
			\def\pgfplotspatchclass@biquad@no{A}%
			\pgfplotspatchready
		\else
			\expandafter\let\expandafter\pgfplotspatchclass@biquad@no\csname pgfpptchindexnext@\pgfplotspatchclass@biquad@no\endcsname
		\fi
	},
	sample in unit cube={%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\def\pgfplotspatchclassx{0.5}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0.5}%
		#1%
		\def\pgfplotspatchclassx{0.5}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0.5}%
		#1%
		\def\pgfplotspatchclassx{0.5}%
		\def\pgfplotspatchclassy{0.5}%
		#1%
		\pgfplotspatchready
	},%
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@A\endvertex,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@C\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@D\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@E\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@F\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@G\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@H\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@I\endvertex #1%
	},
	foreach cdata vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@C\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@biquad@D\endvertex #1%
	},
	fill path={%
		\begingroup
		% Visualize the patch boundary using four bezier curves.
		%
		% This involves a change from Lagrange to bezier
		% representation of the boundary curves.
		%
		% Furthermore, pdf supports only **cubic** bezier curves. What
		% I am doing here is
		% a) change of basis from 3-point lagrange ---> 3 point quadratic bezier
		% b) expression 3 point quadratic bezier ----> 4 point cubic bezier
		%
		% INPUT:
		% 3 langrange points (i.e. the patch passes through them)
		% \PA,\PB,\PC (start,middle,end)
		%
		% OUTPUT:
		% \PA,bezier control 1, bezier control 2, \PC.
		%
		\def\pgfplots@edge{%
			\ifx\pgfplotspatchclass@biquad@A\PA
				\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\PA\endvertex}%
			\fi
			\pgfpathcurveto	{%
				\pgfpointadd
					{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
					{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PC\endvertex}}%
			}{%
				\pgfpointadd
					{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
					{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PA\endvertex}}%
			}{%
				\expandafter\pgfplotspointpatchvertex\PC\endvertex
			}%
		}%
		\let\PA=\pgfplotspatchclass@biquad@A
		\let\PB=\pgfplotspatchclass@biquad@E
		\let\PC=\pgfplotspatchclass@biquad@B
		\pgfplots@edge
		%
		\let\PA=\pgfplotspatchclass@biquad@B
		\let\PB=\pgfplotspatchclass@biquad@F
		\let\PC=\pgfplotspatchclass@biquad@C
		\pgfplots@edge
		%
		\let\PA=\pgfplotspatchclass@biquad@C
		\let\PB=\pgfplotspatchclass@biquad@G
		\let\PC=\pgfplotspatchclass@biquad@D
		\pgfplots@edge
		%
		\let\PA=\pgfplotspatchclass@biquad@D
		\let\PB=\pgfplotspatchclass@biquad@H
		\let\PC=\pgfplotspatchclass@biquad@A
		\pgfplots@edge
		\endgroup
		\pgfpathclose
	},
	%--------------------------------------------------
	% stroke path={%
	% 	\ifx\pgfplotspatchclass@biquade@AB\relax
	% 		\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@A\endvertex}%
	% 		\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@B\endvertex}%
	% 		\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@C\endvertex}%
	% 		\pgfpathclose
	% 	\else
	% 		\if1\pgfplotspatchclass@biquade@AB
	% 			\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@A\endvertex}%
	% 			\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@B\endvertex}%
	% 		\fi
	% 		\if1\pgfplotspatchclass@biquade@BC
	% 			\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@B\endvertex}%
	% 			\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@C\endvertex}%
	% 		\fi
	% 		\if1\pgfplotspatchclass@biquade@CA
	% 			\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@C\endvertex}%
	% 			\pgfpathlineto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@biquad@A\endvertex}%
	% 		\fi
	% 	\fi
	% },
	%--------------------------------------------------
	stream to shader={%
		\begingroup
		%
		% An early version of this shader used Coons patch shadings
		% (which provides coordinates only for the 9 boundary
		% vertices, not for the inner vertices). That is a little bit
		% simpler than what you see in the following lines of code: a
		% transformation to a tensor bezier shading.
		%
		% What we need is to map the 3x3 data from lagrangrian
		% (interpolation) representation to 4x4 cubic bezier - and
		% handle the four INNER nodes correctly.
		%
		% The algorithm to convert from 1d curves with 3 point langrange to 4 point
		% bezier is well-known and relatively simple. Fortunately, the
		% extension to 3x3 -> 4x4 can be boiled down to a successive
		% application of the 1d algorithm - applied to horizontal and
		% vertical lines in the data matrizes.
		%
		% NOTE: the algorithm in the following lines results in
		% EXACTLY THE SAME four cubic boundary curves as the approach
		% in 'fill path'. The only difference is that it also does the
		% right thing for the inner node.
		%
		% STEP 1: ensure that the patch's coordinates are streamed in
		% a sequence which is compatible with the DEPTH of the
		% corners.
		%
		% we use
		% \pgfplotspatchclass@rect@to@coonspatch@findshadingsequence@for@depth
		% which works for bilinear, biquadratic, and bicubic
		\pgfplotspatchclass@rect@to@coonspatch@findshadingsequence@for@depth
			{pgfplotspatchclass@biquad@}{\Pcur}{\Pnextseq}%
		%
		% STEP 2:
		% now, translate the result into our matrix form.
		% This means to (a) identify the FIRST point which needs to be
		% streamed (it is stored in \Pcur as 'A', 'B', 'C', or 'D')
		% and (b) keep in mind that we have to take care of the
		% sequence in which points are streamed ("forward" means to
		% rotate the matrix elements and "backward" means to transpose
		% the "forward" result).
		%
		% This can be seen as conversion from the "linearized"
		% numbering to matrix indexing - while respecting the "start
		% point".
		%
		% INPUT:
		%
		% D G C
		% H I F
		% A E B
		%
		\if A\Pcur
			% Ah - the point "A" needs to be streamed as first.
			%
			% Well, this is simple: take the matrix as-is!
			% simply copy 1:1
			%
			% i.e. convert
			% D G C
			% H I F
			% A E B
			%
			% to
			%
			% AC BC CC
			% AB BB CB
			% AA BA CA
			\let\P@AA=\pgfplotspatchclass@biquad@A
			\let\P@BA=\pgfplotspatchclass@biquad@E
			\let\P@CA=\pgfplotspatchclass@biquad@B
			\let\P@AB=\pgfplotspatchclass@biquad@H
			\let\P@BB=\pgfplotspatchclass@biquad@I
			\let\P@CB=\pgfplotspatchclass@biquad@F
			\let\P@AC=\pgfplotspatchclass@biquad@D
			\let\P@BC=\pgfplotspatchclass@biquad@G
			\let\P@CC=\pgfplotspatchclass@biquad@C
		\fi
		\if B\Pcur
			% the "B" point needs to be streamed as first.
			%
			% i.e. reorder
			% D G C
			% H I F
			% A E B
			%
			% to
			% A H D     AC BC CC
			% E I G =:  AB BB CB
			% B F C     AA BA CA
			%
			\let\P@AA=\pgfplotspatchclass@biquad@B
			\let\P@BA=\pgfplotspatchclass@biquad@F
			\let\P@CA=\pgfplotspatchclass@biquad@C
			\let\P@AB=\pgfplotspatchclass@biquad@E
			\let\P@BB=\pgfplotspatchclass@biquad@I
			\let\P@CB=\pgfplotspatchclass@biquad@G
			\let\P@AC=\pgfplotspatchclass@biquad@A
			\let\P@BC=\pgfplotspatchclass@biquad@H
			\let\P@CC=\pgfplotspatchclass@biquad@D
		\fi
		\if C\Pcur
			% the "C" point needs to be streamed as first.
			%
			% i.e. reorder
			% D G C
			% H I F
			% A E B
			%
			% to
			% B E A     AC BC CC
			% F I H =:  AB BB CB
			% C G D     AA BA CA
			%
			\let\P@AA=\pgfplotspatchclass@biquad@C
			\let\P@BA=\pgfplotspatchclass@biquad@G
			\let\P@CA=\pgfplotspatchclass@biquad@D
			\let\P@AB=\pgfplotspatchclass@biquad@F
			\let\P@BB=\pgfplotspatchclass@biquad@I
			\let\P@CB=\pgfplotspatchclass@biquad@H
			\let\P@AC=\pgfplotspatchclass@biquad@B
			\let\P@BC=\pgfplotspatchclass@biquad@E
			\let\P@CC=\pgfplotspatchclass@biquad@A
		\fi
		\if D\Pcur
			% the "D" point needs to be streamed as first.
			%
			% i.e. reorder
			% D G C
			% H I F
			% A E B
			%
			% to
			% C F B     AC BC CC
			% G I E =:  AB BB CB
			% D H A     AA BA CA
			%
			\let\P@AA=\pgfplotspatchclass@biquad@D
			\let\P@BA=\pgfplotspatchclass@biquad@H
			\let\P@CA=\pgfplotspatchclass@biquad@A
			\let\P@AB=\pgfplotspatchclass@biquad@G
			\let\P@BB=\pgfplotspatchclass@biquad@I
			\let\P@CB=\pgfplotspatchclass@biquad@E
			\let\P@AC=\pgfplotspatchclass@biquad@C
			\let\P@BC=\pgfplotspatchclass@biquad@F
			\let\P@CC=\pgfplotspatchclass@biquad@B
		\fi
		\ifx\Pnextseq\pgfutil@empty
		\else
			% reverse the ordering. This means to transpose the
			% matrix:
			\pgfplotspatchclass@biquad@transpose
		\fi
		%
		%
		% Step: convert to tensor bezier representation.
		%
		% Converting a 2d tensor product lagrangian interpoland to a
		% 2d tensor product bezier interpoland can be achieved by
		% means of 1d algorithms along LINES in the matrix.
		%
		% The underlying proof for this is related to the tensor
		% product form: the U and V coordinates are orthogonal to each
		% other, so we can redistribute all intermediate results. (I
		% do not have the real proof, so this hand-waving argument has
		% to be enough). I verified its results experimentally.
		%
		% Note that the underlying 1d operation is the same as for
		% 'patch type=quadratic spline' . We only need to apply it to all
		% lines in U direction and afterwards to all lines in V
		% direction.
		%
		\def\pgfplotspatchvertexaddXY@expanded##1\times{%
			\edef\pgfplots@loc@TMPa{##1}%
			\expandafter\pgfplotspatchvertexaddXY\pgfplots@loc@TMPa\times
		}%
		%
		% this macro operates on \pgfplots@line{[ABC]} and defines
		% \pgfplots@line{[ABCD]} (i.e. one dimension more!)
		\def\pgfplots@apply@to@line{%
			\pgfplotspatchvertexaccumstart
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{B}\times{1.333333}%
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{C}\times{-0.333333}%
			\pgfplotspatchvertexfinish\pgfplots@controlpoint@A
			%
			\pgfplotspatchvertexaccumstart
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{A}\times{-0.333333}%
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{B}\times{1.333333}%
			\pgfplotspatchvertexfinish\pgfplots@controlpoint@B
			%
			% ... we output 4 points (cubic!).
			% A= left endpoint (untouched)
			% B= first control
			% C= second control
			% D= right endpoint (untouched, is formerly called 'C')
			\edef\pgfplots@loc@TMPa{\pgfplots@line{C}}%
			\expandafter\expandafter\expandafter\let\pgfplots@line{B}=\pgfplots@controlpoint@A
			\expandafter\expandafter\expandafter\let\pgfplots@line{C}=\pgfplots@controlpoint@B
			\expandafter\expandafter\expandafter\let\pgfplots@line{D}=\pgfplots@loc@TMPa
		}%
		%
		\def\pgfplots@line##1{\csname P@##1A\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@##1B\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@##1C\endcsname}%
		\pgfplots@apply@to@line
		%
		% Now, we have a 3x4 matrix.
		%
		%
		\def\pgfplots@line##1{\csname P@A##1\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@B##1\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@C##1\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@D##1\endcsname}%
		\pgfplots@apply@to@line
		%
		% OK. The tensor product representation is READY.
		%
		% in particular, we have a 4x4 matrix right now:
		%
		\pgfplotsplothandlermesh@shade@cubic@tensor
		\endgroup
	},%
	triangulate={%
		\let\pgfplotsplothandlermesh@patchclass@=\pgfplotsplothandlermesh@patchclass
		\def\pgfplotsplothandlermesh@patchclass{triangle}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{new}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}01%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}10%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}20%
		% Ok. Now create 4 triangles. The ordering is not arbitrary
		% (unless z buffer=sort is in effect). Let's assume that the
		% AB edge is BACKGROUND and the CD edge is FOREGROUND. Then
		% this sequence here should have approximately the same depth
		% ordering:
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@E}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@H}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@A}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@E}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@B}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@B}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@F}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@H}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@D}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@G}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@G}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I}%
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@C}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@F}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I}%
		\let\pgfplotsplothandlermesh@patchclass=\pgfplotsplothandlermesh@patchclass@
	},%
	%--------------------------------------------------
	% set edge visible={%
	% 	\ifcase#1
	% 		\edef\pgfplotspatchclass@biquade@AB{#2}%
	% 	\or
	% 		\edef\pgfplotspatchclass@biquade@BC{#2}%
	% 	\or
	% 		\edef\pgfplotspatchclass@biquade@CA{#2}%
	% 	\fi
	% },
	%--------------------------------------------------
	serialize except vertices={%
		\ifx\pgfplotspatchclass@biquade@AB\relax
			\let\pgfplotsretval\pgfutil@empty%
		\else
			\edef\pgfplotsretval{%
				\noexpand\def\noexpand\pgfplotspatchclass@biquade@AB{\pgfplotspatchclass@biquade@AB}%
				\noexpand\def\noexpand\pgfplotspatchclass@biquade@BC{\pgfplotspatchclass@biquade@BC}%
				\noexpand\def\noexpand\pgfplotspatchclass@biquade@CA{\pgfplotspatchclass@biquade@CA}%
			}%
		\fi
	},%
	deserialize except vertices=%
		\let\pgfplotspatchclass@biquade@AB\relax
		#1,
	recursive refine@={%
		\pgfplotspatchclass@biquad@recursiverefine@newnames
		%
		\pgfplotspatchclass{\pgfplotspatchclassname}{new}%
		%--------------------------------------------------
		% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}01%
		% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}11%
		% \pgfplotspatchclass{\pgfplotspatchclassname}{set edge visible}20%
		%--------------------------------------------------
		% The ordering is not arbitrary
		% (unless z buffer=sort is in effect). Let's assume that the
		% AB edge is BACKGROUND and the CD edge is FOREGROUND. Then
		% this sequence here should have approximately the same depth
		% ordering:
		%
		% I used the reference triangle and shape functions as listed in
		% http://www.colorado.edu/engineering/CAS/courses.d/IFEM.d/,
		% see above for the definition of f[xi,eta]
		%
		% N[{f[-1/2, -1], f[0, -1/2], f[-1/2, 0], f[-1, -1/2], f[-1/2, -1/2]}]
		% {0.375` a - 0.125` b + 0.75` e,
		%  0.375` e - 0.125` g + 0.75` i,
		%   -0.125` f + 0.375` h + 0.75` i,
		%    0.375` a - 0.125` d + 0.75` h,
		%     0.140625` a - 0.046875` b + 0.015625` c - 0.046875` d +
		%       0.28125` e -  0.09375` f - 0.09375` g + 0.28125` h +
		%       0.5625` i}
		%--------------------------------------------------
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@A\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@B\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@AE
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@EI
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@HI
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@A\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@D\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@AH
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@A\times{0.140625}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@B\times{-0.046875}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@C\times{0.015625}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@D\times{-0.046875}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{0.28125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{-0.09375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{-0.09375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{0.28125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.5625}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@AEIH
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@A@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@E@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@H@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@AE}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@EI}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@HI}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@AH}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@AEIH}%
		%
		#1\pgfplotspatchclass@biquad@recursiverefine@newnames
		%
		% N[{f[1/2, -1],   f[1, -1/2],    f[1/2, 0],  f[1/2, -1/2]}]
		% {-0.125` a + 0.375` b + 0.75` e,
		% 0.375` b - 0.125` c + 0.75` f,
		% 0.375` f - 0.125` h + 0.75` i,
		% -0.046875 a + 0.140625 b - 0.046875 c + 0.015625 d + 0.28125 e + 0.28125 f - 0.09375 g - 0.09375 h + 0.5625 i}
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@A\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@B\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@EB
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@B\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@C\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@BF
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@FI
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@EI
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@A\times{-0.046875}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@B\times{0.140625}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@C\times{-0.046875}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@D\times{0.015625}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{0.28125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{0.28125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{-0.09375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{-0.09375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.5625}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@EBFI
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@E@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@B@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@F@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@EB}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@BF}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@FI}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@EI}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@EBFI}%
		%
		#1\pgfplotspatchclass@biquad@recursiverefine@newnames
		%
		%
		% N[ {f[1, 1/2],   f[1/2, 1],   f[0, 1/2],    f[1/2, 1/2]}]
		% {-0.125` b + 0.375` c + 0.75` f,
		% 0.375` c - 0.125` d + 0.75` g,
		% -0.125` e + 0.375` g + 0.75` i,
		% 0.015625` a - 0.046875` b + 0.140625` c - 0.046875` d - 0.09375` e + 0.28125` f + 0.28125` g - 0.09375` h + 0.5625` i}
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@B\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@C\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@FC
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@C\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@D\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@CG
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@GI
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@FI
		%
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@A\times{0.015625}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@B\times{-0.046875}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@C\times{0.140625}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@D\times{-0.046875}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{-0.09375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{0.28125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{0.28125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{-0.09375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.5625}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@IFCG
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@F@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@C@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@G@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@FI}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@FC}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@CG}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@GI}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@IFCG}%
		%
		#1\pgfplotspatchclass@biquad@recursiverefine@newnames
		%
		%
		% N[{f[-1/2, 1],  f[-1, 1/2],  f[-1/2, 1/2]}]
		% {-0.125 c + 0.375 d + 0.75 g,
		% -0.125 a + 0.375 d + 0.75 h,
		%  -0.046875 a + 0.015625 b - 0.046875 c + 0.140625 d - 0.09375 e - 0.09375 f + 0.28125 g + 0.28125 h + 0.5625 i}
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@C\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@D\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@GD
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@A\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@D\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@DH
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@GI
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{-0.125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{0.375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@HI
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@A\times{-0.046875}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@B\times{0.015625}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@C\times{-0.046875}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@D\times{0.140625}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@E\times{-0.09375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@F\times{-0.09375}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@G\times{0.28125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@H\times{0.28125}%
		\expandafter\pgfplotspatchvertexadd\pgfplotspatchclass@biquad@I\times{0.5625}%
		\pgfplotspatchvertexfinish\pgfplotspatchclass@biquad@HIGD
		%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@H@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@I@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@G@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@D@}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@HI}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@GI}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@GD}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@DH}%
		\expandafter\pgfplotsplothandlermesh@setnextvertex\expandafter{\pgfplotspatchclass@biquad@HIGD}%
		%
		#1%
		%
	},%
	get pdf shading type*={%
		\if1\b@pgfplotsplothandlermesh@enable@fixed@biquadratic
			\def\pgfplotsretval{7}%
		\else
			\def\pgfplotsretval{6}%
		\fi
	},%
	get num vertices=\def\pgfplotsretval{9},
	get num cdata vertices=\def\pgfplotsretval{4},
}%

% set this to 0 to revert to an older implementation (which was buggy,
% though)
\def\b@pgfplotsplothandlermesh@enable@fixed@biquadratic{1}%


% see docs in 'biquadratic::stream to shader' for details.
% PRECONDITION: to be used inside of 'stream to shader'.
\def\pgfplotspatchclass@biquad@coonsedge{%
%\message{EDGE \Pcur^^J}%
	\expandafter\let\expandafter\PA\csname pgfplotspatchclass@biquad@\Pcur\endcsname
	\edef\Pcur{\csname pgfplots@biquad@\Pnextseq next@\Pcur\endcsname}%
	\expandafter\let\expandafter\PB\csname pgfplotspatchclass@biquad@\Pcur\endcsname
%\message{---> \Pcur^^J}%
	\edef\Pcur{\csname pgfplots@biquad@\Pnextseq next@\Pcur\endcsname}%
	\expandafter\let\expandafter\PC\csname pgfplotspatchclass@biquad@\Pcur\endcsname
%\message{---> \Pcur^^J}%
	\ifx\PA\Pstart
		\expandafter\pgfplotspatchvertex\PA\endvertex
			\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
			\pgfplotsaxisvisphasetransformpointmeta
		\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
	\fi
	\pgfplotslibrarysurfstreamcoord{%
		\pgfpointadd
			{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
			{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PC\endvertex}}%
	}{}%
	\pgfplotslibrarysurfstreamcoord{%
		\pgfpointadd
			{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
			{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PA\endvertex}}%
	}{}%
	\ifx\PC\Pstart
	\else
		\expandafter\pgfplotspatchvertex\PC\endvertex
			\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
			\pgfplotsaxisvisphasetransformpointmeta
		\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
	\fi
}%
\def\pgfplotspatchclass@biquad@innercontrolpoints{%
	\begingroup
		%
		% This here computes the FOUR INNER CONTROL POINTS of a tensor
		% cubic bezier patch (Shading Type 7).
		%
		%
		% the following point coordinates have been acquired from
		% biquadratic::recursive refine. See above for documentation.
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@A\times{0.375}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@B\times{-0.125}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@E\times{0.75}%
		\pgfplotspatchvertexfinishXY\pgfplotspatchclass@biquad@AE
		%
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@F\times{-0.125}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@H\times{0.375}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinishXY\pgfplotspatchclass@biquad@HI
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@A\times{-0.125}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@B\times{0.375}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@E\times{0.75}%
		\pgfplotspatchvertexfinishXY\pgfplotspatchclass@biquad@EB
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@F\times{0.375}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@H\times{-0.125}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@I\times{0.75}%
		\pgfplotspatchvertexfinishXY\pgfplotspatchclass@biquad@FI
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@C\times{0.375}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@D\times{-0.125}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@G\times{0.75}%
		\pgfplotspatchvertexfinishXY\pgfplotspatchclass@biquad@CG
		%
		\pgfplotspatchvertexaccumstart
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@C\times{-0.125}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@D\times{0.375}%
		\expandafter\pgfplotspatchvertexaddXY\pgfplotspatchclass@biquad@G\times{0.75}%
		\pgfplotspatchvertexfinishXY\pgfplotspatchclass@biquad@GD
		%
		%
		\let\PA=\pgfplotspatchclass@biquad@AE
		\let\PB=\pgfplotspatchclass@biquad@HI
		\let\PC=\pgfplotspatchclass@biquad@GD
		\pgfplotspatchclass@biquad@innercontrolpoints@PREPARE\pgfplotspatchclass@biquad@@A\pgfplotspatchclass@biquad@@D
		%
		\let\PA=\pgfplotspatchclass@biquad@EB
		\let\PB=\pgfplotspatchclass@biquad@FI
		\let\PC=\pgfplotspatchclass@biquad@CG
		\pgfplotspatchclass@biquad@innercontrolpoints@PREPARE\pgfplotspatchclass@biquad@@B\pgfplotspatchclass@biquad@@C
		%
		%
		\let\Pcur=\Pstartidx
		\pgfplotslibrarysurfstreamcoord{\csname pgfplotspatchclass@biquad@@\Pcur\endcsname}{}%
		%
		\edef\Pcur{\csname pgfplots@rect@\Pnextseq next@\Pcur\endcsname}%
		\pgfplotslibrarysurfstreamcoord{\csname pgfplotspatchclass@biquad@@\Pcur\endcsname}{}%
		%
		\edef\Pcur{\csname pgfplots@rect@\Pnextseq next@\Pcur\endcsname}%
		\pgfplotslibrarysurfstreamcoord{\csname pgfplotspatchclass@biquad@@\Pcur\endcsname}{}%
		%
		\edef\Pcur{\csname pgfplots@rect@\Pnextseq next@\Pcur\endcsname}%
		\pgfplotslibrarysurfstreamcoord{\csname pgfplotspatchclass@biquad@@\Pcur\endcsname}{}%
	\endgroup
}%
\def\pgfplotspatchclass@biquad@innercontrolpoints@PREPARE#1#2{%
	\pgfpointadd
		{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
		{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PC\endvertex}}%
	\edef#1{\global\pgf@x=\the\pgf@x\space\global\pgf@y=\the\pgf@y\space}%
	%
	\pgfpointadd
		{\pgfqpointscale{1.333333}{\expandafter\pgfplotspointpatchvertex\PB\endvertex}}%
		{\pgfqpointscale{-0.333333}{\expandafter\pgfplotspointpatchvertex\PA\endvertex}}%
	\edef#2{\global\pgf@x=\the\pgf@x\space\global\pgf@y=\the\pgf@y\space}%
	%
\pgfpathcircle{\expandafter\pgfplotspointpatchvertex\PA\endvertex}{1pt}\pgfusepath{fill}%
\pgfpathcircle{\expandafter\pgfplotspointpatchvertex\PB\endvertex}{1pt}\pgfusepath{fill}%
\pgfpathcircle{\expandafter\pgfplotspointpatchvertex\PC\endvertex}{1pt}\pgfusepath{fill}%
\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\PA\endvertex}%
\pgfpathcurveto{#1}{#2}{\expandafter\pgfplotspointpatchvertex\PC\endvertex}%
\pgfusepath{stroke}%
}

% Direct interface to coons patches (pdf shading type 6).
% See manual and/or pdf reference
\pgfplotsdeclarepatchclass{coons}{%
	new=\def\pgfplotspatchclass@coons@no{A},
	set next vertex={%
		% defines \pgfplotspatchclass@coons@A ... \pgfplotspatchclass@coons@L (12 points)
		\expandafter\edef\csname pgfplotspatchclass@coons@\pgfplotspatchclass@coons@no\endcsname{#1}%
		\if L\pgfplotspatchclass@coons@no
			\def\pgfplotspatchclass@coons@no{A}%
			\pgfplotspatchready
		\else
			\expandafter\let\expandafter\pgfplotspatchclass@coons@no\csname pgfpptchindexnext@\pgfplotspatchclass@coons@no\endcsname
		\fi
	},
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@A\endvertex,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@C\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@D\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@E\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@F\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@G\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@H\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@I\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@J\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@K\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@L\endvertex #1%
	},
	foreach cdata vertex={%
		% 0, 3, 6, 9
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@D\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@G\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@coons@J\endvertex #1%
	},
	fill path={%
		\pgfpathmoveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@A\endvertex}%
		\pgfpathcurveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@B\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@C\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@D\endvertex}%
		\pgfpathcurveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@E\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@F\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@G\endvertex}%
		\pgfpathcurveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@H\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@I\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@J\endvertex}%
		\pgfpathcurveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@K\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@L\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@coons@A\endvertex}%
		\pgfpathclose
	},
	serialize except vertices=\let\pgfplotsretval\pgfutil@empty,%
	deserialize except vertices=,
	get pdf shading type=6,
	get num vertices=\def\pgfplotsretval{12},
	get num cdata vertices=\def\pgfplotsretval{4},
}%

% Direct interface to tensor product bezier patches (pdf shading type 7).
% See manual and/or pdf reference
\pgfplotsdeclarepatchclass{tensor bezier}{%
	new=\def\pgfplotspatchclass@tensor@no{A},
	set next vertex={%
		% defines \pgfplotspatchclass@tensor@A ... \pgfplotspatchclass@tensor@P (16 points)
		\expandafter\edef\csname pgfplotspatchclass@tensor@\pgfplotspatchclass@tensor@no\endcsname{#1}%
		\if P\pgfplotspatchclass@tensor@no
			\def\pgfplotspatchclass@tensor@no{A}%
			\pgfplotspatchready
		\else
			\expandafter\let\expandafter\pgfplotspatchclass@tensor@no\csname pgfpptchindexnext@\pgfplotspatchclass@tensor@no\endcsname
		\fi
	},
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@A\endvertex,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@B\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@C\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@D\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@E\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@F\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@G\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@H\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@I\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@J\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@K\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@L\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@M\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@N\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@O\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@P\endvertex #1%
	},
	foreach cdata vertex={%
		% 0, 3, 6, 9
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@A\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@D\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@G\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@tensor@J\endvertex #1%
	},
	fill path={%
		\pgfpathmoveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@A\endvertex}%
		\pgfpathcurveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@B\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@C\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@D\endvertex}%
		\pgfpathcurveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@E\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@F\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@G\endvertex}%
		\pgfpathcurveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@H\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@I\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@J\endvertex}%
		\pgfpathcurveto	{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@K\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@L\endvertex}%
						{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@tensor@A\endvertex}%
		\pgfpathclose
	},
	serialize except vertices=\let\pgfplotsretval\pgfutil@empty,%
	deserialize except vertices=,
	get pdf shading type=7,
	get num vertices=\def\pgfplotsretval{16},
	get num cdata vertices=\def\pgfplotsretval{4},
}%

% A bicubic patch with 16 points.
%
% It expects points in the order (i.e. in matrix ordering, row-wise):
%
% AD BD CD DD
% AC BC CC DC
% AB BB CB DB
% AA BA CA DA
%
\pgfplotsdeclarepatchclass{bicubic}{%
	new=\def\pgfplotspatchclass@bicubic@row{A}\def\pgfplotspatchclass@bicubic@col{A},
	set next vertex={%
		% defines \pgfplotspatchclass@bicubic@AA ... \pgfplotspatchclass@bicubic@DD (16 points)
		\expandafter\edef\csname pgfplotspatchclass@bicubic@\pgfplotspatchclass@bicubic@row\pgfplotspatchclass@bicubic@col\endcsname{#1}%
		\if D\pgfplotspatchclass@bicubic@row
			\def\pgfplotspatchclass@bicubic@row{A}%
			\if D\pgfplotspatchclass@bicubic@col
				\def\pgfplotspatchclass@bicubic@col{A}%
				\pgfplotspatchready
			\else
				\expandafter\let\expandafter\pgfplotspatchclass@bicubic@col\csname pgfpptchindexnext@\pgfplotspatchclass@bicubic@col\endcsname
			\fi
		\else
			\expandafter\let\expandafter\pgfplotspatchclass@bicubic@row\csname pgfpptchindexnext@\pgfplotspatchclass@bicubic@row\endcsname
		\fi
	},
	sample in unit cube={%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{0.333333333}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{0.666666666}%
		\def\pgfplotspatchclassy{0}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0}%
		#1%
		%
		%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0.333333333}%
		#1%
		\def\pgfplotspatchclassx{0.333333333}%
		\def\pgfplotspatchclassy{0.333333333}%
		#1%
		\def\pgfplotspatchclassx{0.666666666}%
		\def\pgfplotspatchclassy{0.333333333}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0.333333333}%
		#1%
		%
		%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{0.666666666}%
		#1%
		\def\pgfplotspatchclassx{0.333333333}%
		\def\pgfplotspatchclassy{0.666666666}%
		#1%
		\def\pgfplotspatchclassx{0.666666666}%
		\def\pgfplotspatchclassy{0.666666666}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{0.666666666}%
		#1%
		%
		%
		\def\pgfplotspatchclassx{0}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\def\pgfplotspatchclassx{0.333333333}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\def\pgfplotspatchclassx{0.666666666}%
		\def\pgfplotspatchclassy{1}%
		#1%
		\def\pgfplotspatchclassx{1}%
		\def\pgfplotspatchclassy{1}%
		#1%
		%
		%
		%
		\pgfplotspatchready
	},%
	first vertex=\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@AA\endvertex,
	foreach vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@AA\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@BA\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@CA\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@DA\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@AB\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@BB\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@CB\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@DB\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@AC\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@BC\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@CC\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@DC\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@AD\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@BD\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@CD\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@DD\endvertex #1%
	},
	foreach cdata vertex={%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@AA\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@DA\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@DD\endvertex #1%
		\expandafter\pgfplotspatchvertex\pgfplotspatchclass@bicubic@AD\endvertex #1%
	},
	fill path={%
		% Visualize the patch boundary using four bezier curves.
		%
		% This involves a change from Lagrange to bezier
		% representation of the boundary curves.
		%
		\pgfpathmoveto{\expandafter\pgfplotspointpatchvertex\pgfplotspatchclass@bicubic@AA\endvertex}%
		\pgfplotspathcubicfrominterpolation
			{\pgfplotspatchclass@bicubic@AA}
			{\pgfplotspatchclass@bicubic@BA}
			{\pgfplotspatchclass@bicubic@CA}
			{\pgfplotspatchclass@bicubic@DA}%
		\pgfplotspathcubicfrominterpolation
			{\pgfplotspatchclass@bicubic@DA}
			{\pgfplotspatchclass@bicubic@DB}
			{\pgfplotspatchclass@bicubic@DC}
			{\pgfplotspatchclass@bicubic@DD}%
		\pgfplotspathcubicfrominterpolation
			{\pgfplotspatchclass@bicubic@DD}
			{\pgfplotspatchclass@bicubic@CD}
			{\pgfplotspatchclass@bicubic@BD}
			{\pgfplotspatchclass@bicubic@AD}%
		\pgfplotspathcubicfrominterpolation
			{\pgfplotspatchclass@bicubic@AD}
			{\pgfplotspatchclass@bicubic@AC}
			{\pgfplotspatchclass@bicubic@AB}
			{\pgfplotspatchclass@bicubic@AA}%
		\pgfpathclose
	},
	stream to shader={%
		\begingroup
		%
		% AD BD CD DD
		% AC BC CC DC
		% AB BB CB DB
		% AA BA CA DA
		%
		% STEP 1: ensure that the patch's coordinates are streamed in
		% a sequence which is compatible with the DEPTH of the
		% corners.
		%
		% we use
		% \pgfplotspatchclass@rect@to@coonspatch@findshadingsequence@for@depth
		% which works for bilinear, biquadratic, and bicubic
		%
		% define helper macros which are input for
		% \pgfplotspatchclass@rect@to@coonspatch@findshadingsequence@for@depth:
		\let\pgfplotspatchclass@rect@A=\pgfplotspatchclass@bicubic@AA
		\let\pgfplotspatchclass@rect@B=\pgfplotspatchclass@bicubic@DA
		\let\pgfplotspatchclass@rect@C=\pgfplotspatchclass@bicubic@DD
		\let\pgfplotspatchclass@rect@D=\pgfplotspatchclass@bicubic@AD
		\pgfplotspatchclass@rect@to@coonspatch@findshadingsequence@for@depth
			{pgfplotspatchclass@rect@}{\Pcur}{\Pnextseq}%
		%
		%\message{using \Pcur\space(set = \Pnextseq)^^J}%
		% now, translate the result into our matrix form.
		% This means to (a) identify the FIRST point which needs to be
		% streamed (it is stored in \Pcur as 'A', 'B', 'C', or 'D')
		% and (b) keep in mind that we have to take care of the
		% sequence in which points are streamed ("forward" means to
		% rotate the matrix elements and "backward" means to transpose
		% the "forward" result).
		%
		\if A\Pcur
			% Ah - the point "AA" needs to be streamed as first.
			%
			% Well, this is simple: take the matrix as-is!
			% simply copy 1:1
			\let\P@AA=\pgfplotspatchclass@bicubic@AA
			\let\P@BA=\pgfplotspatchclass@bicubic@BA
			\let\P@CA=\pgfplotspatchclass@bicubic@CA
			\let\P@DA=\pgfplotspatchclass@bicubic@DA
			\let\P@AB=\pgfplotspatchclass@bicubic@AB
			\let\P@BB=\pgfplotspatchclass@bicubic@BB
			\let\P@CB=\pgfplotspatchclass@bicubic@CB
			\let\P@DB=\pgfplotspatchclass@bicubic@DB
			\let\P@AC=\pgfplotspatchclass@bicubic@AC
			\let\P@BC=\pgfplotspatchclass@bicubic@BC
			\let\P@CC=\pgfplotspatchclass@bicubic@CC
			\let\P@DC=\pgfplotspatchclass@bicubic@DC
			\let\P@AD=\pgfplotspatchclass@bicubic@AD
			\let\P@BD=\pgfplotspatchclass@bicubic@BD
			\let\P@CD=\pgfplotspatchclass@bicubic@CD
			\let\P@DD=\pgfplotspatchclass@bicubic@DD
		\fi
		\if B\Pcur
			% the "DA" point needs to be streamed as first.
			%
			% Reorder
			% AD BD CD DD
			% AC BC CC DC
			% AB BB CB DB
			% AA BA CA DA
			% to
			% AA AB AC AD
			% BA BB BC BD
			% CA CB CC CD
			% DA DB DC DD
			%
			\let\P@AA=\pgfplotspatchclass@bicubic@DA
			\let\P@BA=\pgfplotspatchclass@bicubic@DB
			\let\P@CA=\pgfplotspatchclass@bicubic@DC
			\let\P@DA=\pgfplotspatchclass@bicubic@DD
			\let\P@AB=\pgfplotspatchclass@bicubic@CA
			\let\P@BB=\pgfplotspatchclass@bicubic@CB
			\let\P@CB=\pgfplotspatchclass@bicubic@CC
			\let\P@DB=\pgfplotspatchclass@bicubic@CD
			\let\P@AC=\pgfplotspatchclass@bicubic@BA
			\let\P@BC=\pgfplotspatchclass@bicubic@BB
			\let\P@CC=\pgfplotspatchclass@bicubic@BC
			\let\P@DC=\pgfplotspatchclass@bicubic@BD
			\let\P@AD=\pgfplotspatchclass@bicubic@AA
			\let\P@BD=\pgfplotspatchclass@bicubic@AB
			\let\P@CD=\pgfplotspatchclass@bicubic@AC
			\let\P@DD=\pgfplotspatchclass@bicubic@AD
		\fi
		\if C\Pcur
			% the "DD" point needs to be streamed as first.
			%
			% Reorder
			% AD BD CD DD
			% AC BC CC DC
			% AB BB CB DB
			% AA BA CA DA
			% to
			% DA CA BA AA
			% DB CB BB AB
			% DC CC BC AC
			% DD CD BD AD
			%
			\let\P@AA=\pgfplotspatchclass@bicubic@DD
			\let\P@BA=\pgfplotspatchclass@bicubic@CD
			\let\P@CA=\pgfplotspatchclass@bicubic@BD
			\let\P@DA=\pgfplotspatchclass@bicubic@AD
			\let\P@AB=\pgfplotspatchclass@bicubic@DC
			\let\P@BB=\pgfplotspatchclass@bicubic@CC
			\let\P@CB=\pgfplotspatchclass@bicubic@BC
			\let\P@DB=\pgfplotspatchclass@bicubic@AC
			\let\P@AC=\pgfplotspatchclass@bicubic@DB
			\let\P@BC=\pgfplotspatchclass@bicubic@CB
			\let\P@CC=\pgfplotspatchclass@bicubic@BB
			\let\P@DC=\pgfplotspatchclass@bicubic@AB
			\let\P@AD=\pgfplotspatchclass@bicubic@DA
			\let\P@BD=\pgfplotspatchclass@bicubic@CA
			\let\P@CD=\pgfplotspatchclass@bicubic@BA
			\let\P@DD=\pgfplotspatchclass@bicubic@AA
		\fi
		\if D\Pcur
			% the "AD" point needs to be streamed as first.
			%
			% Reorder
			% AD BD CD DD
			% AC BC CC DC
			% AB BB CB DB
			% AA BA CA DA
			% to
			% DD DC DB DA
			% CD CC CB CA
			% BD BC BB BA
			% AD AC AB AA
			%
			\let\P@AA=\pgfplotspatchclass@bicubic@AD
			\let\P@BA=\pgfplotspatchclass@bicubic@AC
			\let\P@CA=\pgfplotspatchclass@bicubic@AB
			\let\P@DA=\pgfplotspatchclass@bicubic@AA
			\let\P@AB=\pgfplotspatchclass@bicubic@BD
			\let\P@BB=\pgfplotspatchclass@bicubic@BC
			\let\P@CB=\pgfplotspatchclass@bicubic@BB
			\let\P@DB=\pgfplotspatchclass@bicubic@BA
			\let\P@AC=\pgfplotspatchclass@bicubic@CD
			\let\P@BC=\pgfplotspatchclass@bicubic@CC
			\let\P@CC=\pgfplotspatchclass@bicubic@CB
			\let\P@DC=\pgfplotspatchclass@bicubic@CA
			\let\P@AD=\pgfplotspatchclass@bicubic@DD
			\let\P@BD=\pgfplotspatchclass@bicubic@DC
			\let\P@CD=\pgfplotspatchclass@bicubic@DB
			\let\P@DD=\pgfplotspatchclass@bicubic@DA
		\fi
		\ifx\Pnextseq\pgfutil@empty
		\else
			% reverse the ordering. This means to transpose the
			% matrix:
			\pgfplotspatchclass@bicubic@transpose
		\fi
		%
		% Step: convert to tensor bezier representation.
		%
		% Converting a 2d tensor product lagrangian interpoland to a
		% 2d tensor product bezier interpoland can be achieved by
		% means of 1d algorithms along LINES in the matrix.
		%
		% The underlying proof for this is related to the tensor
		% product form: the U and V coordinates are orthogonal to each
		% other, so we can redistribute all intermediate results. (I
		% do not have the real proof, so this hand-waving argument has
		% to be enough). I verified its results experimentally.
		%
		% Note that the underlying 1d operation is the same as for
		% 'patch type=cubic spline' . We only need to apply it to all
		% lines in U direction and afterwards to all lines in V
		% direction.
		%
		\def\pgfplotspatchvertexaddXY@expanded##1\times{%
			\edef\pgfplots@loc@TMPa{##1}%
			\expandafter\pgfplotspatchvertexaddXY\pgfplots@loc@TMPa\times
		}%
		%
		% this macro operates on \pgfplots@line{[ABCD]}, see below:
		\def\pgfplots@apply@to@line{%
			\pgfplotspatchvertexaccumstart
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{A}\times{-0.833333}%
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{B}\times{3}%
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{C}\times{-1.5}%
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{D}\times{0.3333333}%
			\pgfplotspatchvertexfinish\pgfplots@controlpoint@A
			%
			\pgfplotspatchvertexaccumstart
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{A}\times{0.333333}%
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{B}\times{-1.5}%
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{C}\times{3}%
			\pgfplotspatchvertexaddXY@expanded\pgfplots@line{D}\times{-0.833333}%
			\pgfplotspatchvertexfinish\pgfplots@controlpoint@B
			%
			\expandafter\expandafter\expandafter\let\pgfplots@line{B}=\pgfplots@controlpoint@A
			\expandafter\expandafter\expandafter\let\pgfplots@line{C}=\pgfplots@controlpoint@B
		}%
		%
		\def\pgfplots@line##1{\csname P@##1A\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@##1B\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@##1C\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@##1D\endcsname}%
		\pgfplots@apply@to@line
		%
		%
		\def\pgfplots@line##1{\csname P@A##1\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@B##1\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@C##1\endcsname}%
		\pgfplots@apply@to@line
		%
		\def\pgfplots@line##1{\csname P@D##1\endcsname}%
		\pgfplots@apply@to@line
		%
		% OK. The tensor product representation is READY.
		%
		\pgfplotsplothandlermesh@shade@cubic@tensor
		\endgroup
	},
	triangulate={%
		\let\pgfplotsplothandlermesh@patchclass@=\pgfplotsplothandlermesh@patchclass
		\def\pgfplotsplothandlermesh@patchclass{triangle}%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{new}%
		% Ok. Now create a lot of triangles.
		%
		% FIXME: The ordering is not arbitrary (unless z buffer=sort is in effect).
		%
		% ##1: the row index of the cell to be triangulated (either A,B,or C)
		% ##2: the col index of the cell to be triangulated (either A,B,or C)
		% ##3: the 1. 'set edge visible' value for the first triangle
		% ##4: the 2. 'set edge visible' value for the first triangle
		% ##5: the 3. 'set edge visible' value for the first triangle
		% ##6: the 1. 'set edge visible' value for the second triangle
		% ##7: the 2. 'set edge visible' value for the second triangle
		% ##8: the 3. 'set edge visible' value for the second triangle
		\def\pgfplots@bicubic@triangulate@cell##1##2##3##4##5##6##7##8{%
			\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}0##3%
			\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}1##4%
			\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}2##5%
			\pgfplotsplothandlermesh@setnextvertex{\csname pgfplotspatchclass@bicubic@##1##2\endcsname}%
			\pgfplotsplothandlermesh@setnextvertex{\csname pgfplotspatchclass@bicubic@\csname pgfpptchindexnext@##1\endcsname##2\endcsname}%
			\pgfplotsplothandlermesh@setnextvertex{\csname pgfplotspatchclass@bicubic@\csname pgfpptchindexnext@##1\endcsname \csname pgfpptchindexnext@##2\endcsname\endcsname}%
			%
			\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}0##6%
			\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}1##7%
			\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}2##8%
			\pgfplotsplothandlermesh@setnextvertex{\csname pgfplotspatchclass@bicubic@##1\csname pgfpptchindexnext@##2\endcsname\endcsname}%
			\pgfplotsplothandlermesh@setnextvertex{\csname pgfplotspatchclass@bicubic@##1##2\endcsname}%
			\pgfplotsplothandlermesh@setnextvertex{\csname pgfplotspatchclass@bicubic@\csname pgfpptchindexnext@##1\endcsname \csname pgfpptchindexnext@##2\endcsname\endcsname}%
			%
		}%
		%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}01%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}10%
		\pgfplotspatchclass{\pgfplotsplothandlermesh@patchclass}{set edge visible}20%
		\pgfplots@bicubic@triangulate@cell AA100 100%
		\pgfplots@bicubic@triangulate@cell BA100 000%
		\pgfplots@bicubic@triangulate@cell CA110 000%
		%
		\pgfplots@bicubic@triangulate@cell AB000 100%
		\pgfplots@bicubic@triangulate@cell BB000 000%
		\pgfplots@bicubic@triangulate@cell CB010 000%
		%
		\pgfplots@bicubic@triangulate@cell AC000 101%
		\pgfplots@bicubic@triangulate@cell BC000 001%
		\pgfplots@bicubic@triangulate@cell CC010 001%
		\let\pgfplotsplothandlermesh@patchclass=\pgfplotsplothandlermesh@patchclass@
	},%
	serialize except vertices=\let\pgfplotsretval\pgfutil@empty,%
	deserialize except vertices=,
	get pdf shading type=7,
	get num vertices=\def\pgfplotsretval{16},
	get num cdata vertices=\def\pgfplotsretval{4},
}%

% Transpose a bicubic matrix (4x4).
%
% Reorder
% AD BD CD DD
% AC BC CC DC
% AB BB CB DB
% AA BA CA DA
% to
% DA DB DC DD
% CA CB CC CD
% BA BB BC BD
% AA AB AC AD
\def\pgfplotspatchclass@bicubic@transpose{%
	\pgfplotsutil@swap\P@AB\P@BA
	\pgfplotsutil@swap\P@CA\P@AC
	\pgfplotsutil@swap\P@DA\P@AD
	\pgfplotsutil@swap\P@CB\P@BC
	\pgfplotsutil@swap\P@BD\P@DB
	\pgfplotsutil@swap\P@DC\P@CD
}

% Transpose a bicubic matrix (4x4).
%
% Reorder
% AC BC CC
% AB BB CB
% AA BA CA
% to
% CA CB CC
% BA BB BC
% AA AB AC
\def\pgfplotspatchclass@biquad@transpose{%
	\pgfplotsutil@swap\P@AB\P@BA
	\pgfplotsutil@swap\P@CA\P@AC
	\pgfplotsutil@swap\P@CB\P@BC
}

% Expects that a 4x4 matrix in tensor bezier representation where
% A = left end point
% B = first control point
% C = second control point
% D = right end point
%
% and the coordinates are stored in \csname P@[ABCD][ABCD]\endcsname
%
% Streaming starts with \P@AA and is applied rowwise.
\def\pgfplotsplothandlermesh@shade@cubic@tensor{%
	% Stream it to the shader. Note that the shader has a
	% DIFFERENT ordering; it expects points in the cyclic ordering
	%
	% AA BA CA DA   DB DC DD  CD BD AD   AC AB    BB CB CC BC
	%
	% note furthermore that only the corners have "point meta" in
	% this shading :-(
	%
	\expandafter\pgfplotspatchvertex\P@AA\endvertex
		\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
		\pgfplotsaxisvisphasetransformpointmeta
	\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
	\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@BA\endvertex}{\pgfplotspointmetatransformed}%
	\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@CA\endvertex}{\pgfplotspointmetatransformed}%
	\expandafter\pgfplotspatchvertex\P@DA\endvertex
		\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
		\pgfplotsaxisvisphasetransformpointmeta
	\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
	%
	\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@DB\endvertex}{\pgfplotspointmetatransformed}%
	\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@DC\endvertex}{\pgfplotspointmetatransformed}%
	\expandafter\pgfplotspatchvertex\P@DD\endvertex
		\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
		\pgfplotsaxisvisphasetransformpointmeta
	\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
	%
	\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@CD\endvertex}{\pgfplotspointmetatransformed}%
	\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@BD\endvertex}{\pgfplotspointmetatransformed}%
	\expandafter\pgfplotspatchvertex\P@AD\endvertex
		\let\pgfplots@current@point@meta=\pgfplotspatchvertexmeta
		\pgfplotsaxisvisphasetransformpointmeta
	\pgfplotslibrarysurfstreamcoord{\pgfqpoint\pgfplotspatchvertexx\pgfplotspatchvertexy}{\pgfplotspointmetatransformed}%
	%
	\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@AC\endvertex}{\pgfplotspointmetatransformed}%
	\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@AB\endvertex}{\pgfplotspointmetatransformed}%
	%
	%
	\pgfplotspatchclass{\pgfplotspatchclassname}{get pdf shading type}%
	\if 7\pgfplotsretval
		\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@BB\endvertex}{\pgfplotspointmetatransformed}%
		\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@CB\endvertex}{\pgfplotspointmetatransformed}%
		\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@CC\endvertex}{\pgfplotspointmetatransformed}%
		\pgfplotslibrarysurfstreamcoord{\expandafter\pgfplotspointpatchvertex\P@BC\endvertex}{\pgfplotspointmetatransformed}%
	\else
		% assume 'get pdf shading type=6' - it does not contain the
		% inner vertices.
	\fi
}
\endinput
